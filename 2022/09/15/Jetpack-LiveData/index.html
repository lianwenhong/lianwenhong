<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="LiveData简介LiveData是一种可观察的数据存储器类。与常规的可观察类不同，LiveData具有生命周期感知能力，意指它遵循其他应用组件（如activity、fragment或service）的生命周期。这种感知能力可确保LiveData仅更新处于活跃生命周期状态的应用组件观察者。 如果观察者（由 Observer类表示）的生命周期处于STARTED或RESUMED状态，则LiveDat">
<meta property="og:type" content="article">
<meta property="og:title" content="Jetpack-LiveData">
<meta property="og:url" content="http://example.com/2022/09/15/Jetpack-LiveData/index.html">
<meta property="og:site_name" content="连文弘的学习笔记">
<meta property="og:description" content="LiveData简介LiveData是一种可观察的数据存储器类。与常规的可观察类不同，LiveData具有生命周期感知能力，意指它遵循其他应用组件（如activity、fragment或service）的生命周期。这种感知能力可确保LiveData仅更新处于活跃生命周期状态的应用组件观察者。 如果观察者（由 Observer类表示）的生命周期处于STARTED或RESUMED状态，则LiveDat">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/09/15/Jetpack-LiveData/LiveData%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg">
<meta property="article:published_time" content="2022-09-15T10:47:11.000Z">
<meta property="article:modified_time" content="2022-09-30T14:31:24.926Z">
<meta property="article:author" content="lianwenhong">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/09/15/Jetpack-LiveData/LiveData%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          
            <link rel="icon" type="image/png" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=192" sizes="192x192">
          
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Jetpack-LiveData</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.4.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/lianwenhong?tab=repositories">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2022/09/17/Jetpack-LiveData%E5%8E%9F%E7%90%86%E8%A1%A5%E5%85%85/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/09/06/Jetpack-ViewModel/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/09/15/Jetpack-LiveData/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/09/15/Jetpack-LiveData/&text=Jetpack-LiveData"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/09/15/Jetpack-LiveData/&title=Jetpack-LiveData"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/09/15/Jetpack-LiveData/&is_video=false&description=Jetpack-LiveData"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Jetpack-LiveData&body=Check out this article: http://example.com/2022/09/15/Jetpack-LiveData/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/09/15/Jetpack-LiveData/&title=Jetpack-LiveData"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/09/15/Jetpack-LiveData/&title=Jetpack-LiveData"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/09/15/Jetpack-LiveData/&title=Jetpack-LiveData"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/09/15/Jetpack-LiveData/&title=Jetpack-LiveData"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/09/15/Jetpack-LiveData/&name=Jetpack-LiveData&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/09/15/Jetpack-LiveData/&t=Jetpack-LiveData"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#LiveData%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">LiveData简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-LiveData-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">2.</span> <span class="toc-text">使用 LiveData 的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LiveData%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">LiveData的简单使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LiveData%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">LiveData原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-LiveData-gt-observe"><span class="toc-number">4.1.</span> <span class="toc-text">1. LiveData-&gt;observe()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-LiveData-gt-setValue"><span class="toc-number">4.2.</span> <span class="toc-text">2. LiveData-&gt;setValue()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LiveData-gt-postValue-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.3.</span> <span class="toc-text">LiveData-&gt;postValue()如何保证线程安全?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">使用总结</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Jetpack-LiveData
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">lianwenhong</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-09-15T10:47:11.000Z" itemprop="datePublished">2022-09-15</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Android/">Android</a>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="LiveData简介"><a href="#LiveData简介" class="headerlink" title="LiveData简介"></a>LiveData简介</h2><p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/androidx/lifecycle/LiveData">LiveData</a>是一种可观察的数据存储器类。与常规的可观察类不同，LiveData具有生命周期感知能力，意指它遵循其他应用组件（如activity、fragment或service）的生命周期。这种感知能力可确保LiveData仅更新处于活跃生命周期状态的应用组件观察者。</p>
<p>如果观察者（由 Observer类表示）的生命周期<strong>处于STARTED或RESUMED状态</strong>，则LiveData会认为该观察者处于活跃状态。LiveData只会将更新通知给活跃的观察者。为观察LiveData对象而注册的非活跃观察者不会收到更改通知。</p>
<p>您可以注册与实现LifecycleOwner接口的对象配对的观察者。有了这种关系，当相应的Lifecycle对象的状态变为DESTROYED时，便可移除此观察者。这对于activity和fragment特别有用，因为它们可以放心地观察 LiveData 对象，而不必担心内存泄露（当 activity 和 fragment 的生命周期被销毁时，系统会立即退订它们）。</p>
<p>LiveData一般声明在ViewModel中搭配ViewModel一起使用。</p>
<h2 id="使用-LiveData-的优势"><a href="#使用-LiveData-的优势" class="headerlink" title="使用 LiveData 的优势"></a>使用 LiveData 的优势</h2><ol>
<li><strong>确保界面符合数据状态</strong><blockquote>
<p>LiveData 遵循观察者模式。当底层数据发生变化时，LiveData会通知 Observer对象。您可以整合代码以在这些Observer对象中更新界面。这样一来，您无需在每次应用数据发生变化时更新界面，因为观察者会替您完成更新。</p>
</blockquote>
</li>
<li><strong>不会发生内存泄漏</strong><blockquote>
<p>观察者会绑定到Lifecycle对象，并在其关联的生命周期遭到销毁后进行自我清理。</p>
</blockquote>
</li>
<li><strong>不会因 Activity 停止而导致崩溃</strong><blockquote>
<p>如果观察者的生命周期处于非活跃状态（如返回堆栈中的activity），它便不会接收任何LiveData事件。</p>
</blockquote>
</li>
<li><strong>不再需要手动处理生命周期</strong><blockquote>
<p>界面组件只是观察相关数据，不会停止或恢复观察。LiveData会在内部自动管理所有这些操作，因为它在观察时可以通过LifecycleOwner感知相关的生命周期状态变化。</p>
</blockquote>
</li>
<li><strong>数据始终保持最新状态</strong><blockquote>
<p>如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据，并且如果在非活跃状态时数据经过了多次变化也只会收到最新的那次的通知。例如，曾经在后台的Activity会在返回前台后立即接收最新的数据。</p>
</blockquote>
</li>
<li><strong>适当的配置更改</strong><blockquote>
<p>如果由于配置更改（如设备旋转）而重新创建了activity或fragment，它会立即接收最新的可用数据。当然这也归功于其LiveData和ViewModel的搭配使用，这样才能是的LiveData在配置更改后依然保留在内存中。</p>
</blockquote>
</li>
<li><strong>共享资源</strong><blockquote>
<p>您可以使用单例模式扩展LiveData对象以封装系统服务，以便在应用中共享它们。LiveData对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察LiveData对象。如需了解详情，请参阅<a target="_blank" rel="noopener" href="https://developer.android.google.cn/topic/libraries/architecture/livedata.html#extend_livedata">扩展LiveData</a>。</p>
</blockquote>
</li>
</ol>
<h2 id="LiveData的简单使用"><a href="#LiveData的简单使用" class="headerlink" title="LiveData的简单使用"></a>LiveData的简单使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class MainViewModel : ViewModel() &#123;</span><br><span class="line">    val userName: MutableLiveData&lt;String&gt; by lazy &#123;</span><br><span class="line">        MutableLiveData&lt;String&gt;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    val viewModel: ViewModel by lazy &#123;</span><br><span class="line">        ViewModelProvider(this).get(MainViewModel::class.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        initView()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun initView() &#123;</span><br><span class="line"></span><br><span class="line">        txtName = findViewById(R.id.txt_name)</span><br><span class="line">        btnChangeInMain = findViewById(R.id.btn_change_in_main)</span><br><span class="line">        btnChangeInOther = findViewById(R.id.btn_change_in_other)</span><br><span class="line">        </span><br><span class="line">        demoLiveData()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun demoLiveData() &#123;</span><br><span class="line">        viewModel?.userName?.observe(this) &#123; txtName?.text = &quot;NAME:$it&quot; &#125;</span><br><span class="line">        viewModel?.userName?.observe(this) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;USERNAME改变&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        btnChangeInMain?.setOnClickListener &#123;</span><br><span class="line">            viewModel?.userName?.value = &quot;MAIN&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnChangeInOther?.setOnClickListener &#123;</span><br><span class="line">            val thread = Thread &#123;</span><br><span class="line">                viewModel?.userName?.postValue(&quot;OTHER&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            SystemClock.sleep(2000)</span><br><span class="line">            thread.start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中以最简单的<code>MutableLiveData</code>为例，它继承自抽象类<code>LiveData</code>。</p>
<ul>
<li>我们在MainViewModel中用MutableLiveData容器存储一个String类型的userName</li>
<li>在页面中使用observe()方法传入Observer观察者对象和LifecycleOwner对象使得userName内数据发生变化时或者页面生命周期发生变化时会将userName最新的值回调到Observer的onChanged()方法中。</li>
</ul>
<h2 id="LiveData原理解析"><a href="#LiveData原理解析" class="headerlink" title="LiveData原理解析"></a>LiveData原理解析</h2><p>讲解LiveData之前最好是先对<strong>Lifecycle</strong> 和<strong>ViewModel</strong> 的实现原理有足够的了解否则对本文阅读可能有点不知所云，特别是对了解《页面生命周期变化时如何将最新的LiveData数据通知给数据观察者以达到更新UI的目的》这部分会比较难理解。</p>
<p>如果不了解可以看我前面2篇文章：<a target="_blank" rel="noopener" href="https://lianwenhong.top/2022/08/23/Jetpack-Lifecycle/">Jetpack-Lifecycle</a>，<a target="_blank" rel="noopener" href="https://lianwenhong.top/2022/09/06/Jetpack-ViewModel/">Jetpack-ViewModel</a></p>
<p>从2个角度来分析LiveData的运行原理：LiveData观察者绑定<strong>LiveData-&gt;observe()</strong> 和LiveData数据发生改变 <strong>LiveData-&gt;setValue()</strong></p>
<p>在讲解过程中我们将实现<code>LifecycleEventObserver</code>的接口称为生命周期观察者，将<code>ObserverWrapper</code>的实现类称为数据观察者，这两者所观察的目标不一样，前者观察页面的生命周期，后者观察LiveData的value变化。</p>
<h3 id="1-LiveData-gt-observe"><a href="#1-LiveData-gt-observe" class="headerlink" title="1. LiveData-&gt;observe()"></a>1. LiveData-&gt;observe()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    // 1.注册过程必须在主线程执行</span><br><span class="line">    assertMainThread(&quot;observe&quot;);</span><br><span class="line">    // 2.注册过程必须是LifecycleOwner处于活跃状态，也就是页面处于活跃状态</span><br><span class="line">    if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        // ignore</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.封装一个生命周期感知的观察者包装类LifecycleBoundObserver(把注册进来的observer包装成 一个具有生命周边边界的观察者，其能感知LifecycleOwner的生命周期变化)</span><br><span class="line">    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    // 4.判断观察者是否已经存在并且同一个观察者只能感知一个页面的生命周期</span><br><span class="line">    if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot add the same observer&quot;</span><br><span class="line">                + &quot; with different lifecycles&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (existing != null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 5.将wrapper注册进LifecycleOwner对应的生命周期观察者列表中，这样才最终实现LifecycleBoundObserver对LifecycleOwner的生命周期感知</span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个注册过程并不复杂</p>
<ul>
<li>先判断当前是否处于主线程，因为其实LiveData主要的作用就是让页面能及时响应数据的变化，而UI改变需要在主线程中执行，所以这一步也是可以理解的</li>
<li>判断当前页面是否处于活跃状态，如果此时传入的页面对应的LifecycleOwner生命周期处于非活跃状态则不进行观察，例如如果页面已经被关闭或者处于后台中，那你观察该数据来更新UI对于用户也是无感知的，所以没有意义。如果你非要在后台更新数据，那么你可以直接使用observeForever(@NonNull Observer&lt;? super T&gt; observer)这个方法来实现，后果是你得自己去维护这个LiveData与观察者的解除绑定关系。</li>
<li>将LifecycleOwner和Observer封装在一个LifecycleBoundObserver包装类中并保存在LiveData的mObservers中以便后续数据发生变化时能及时响应到各个观察者中，LifecycleBoundObserver可以感知LifecycleOwner的生命周期变化，因为其实现了<code>LifecycleEventObserver</code>接口，下面再详解</li>
<li>在使用过程中需要注意第4点，同一个Observer数据观察者绑定的LifecycleOwner必须是同一个否则会抛异常。也不难理解，假如同一个数据观察者绑定的页面不一样那么2个页面的生命周期不一样时数据观察者应该响应哪个页面的生命周期就是个问题！</li>
<li>最后将该LifecycleBoundObserver包装类注册给LifecycleOwner，这样当页面生命周期发生变化时就会回调到LifecycleBoundObserver-&gt;onStateChanged()方法中，在onStateChanged中就会在合适的时机去通知观察者LiveData的数据发生变化了，需要更新UI的请开始吧</li>
</ul>
<p>LifecycleBoundObserver是LiveData的内部类，LiveData通过这个内部类将观察者（Observer）和页面的生命周期组合在一起使得每一个观察者都对应响应一个页面的生命周期（LifecycleOwner）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver &#123;</span><br><span class="line">    @NonNull</span><br><span class="line">    final LifecycleOwner mOwner; // 用来获取页面最新生命周期以及判断数据观察者重新绑定时LifecycleOwner是否是同一个</span><br><span class="line"></span><br><span class="line">    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">        super(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean shouldBeActive() &#123;</span><br><span class="line">        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当mOwner对应的页面生命周期发生变化时，Lifecycle会回调该方法并传入最新的生命周期状态通知该生命周期观察者</span><br><span class="line">    @Override</span><br><span class="line">    public void onStateChanged(@NonNull LifecycleOwner source,</span><br><span class="line">            @NonNull Lifecycle.Event event) &#123;</span><br><span class="line">        Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">        // 当页面处于非活跃状态时移除数据观察者，这样能避免没必要的通知提升效率。</span><br><span class="line">        // 这就是为什么在Fragment中使用LiveData时observe中应该传入viewLifecycleOwner而不是传入this，后面再详解</span><br><span class="line">        if (currentState == DESTROYED) &#123;</span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Lifecycle.State prevState = null;</span><br><span class="line">        while (prevState != currentState) &#123;</span><br><span class="line">            prevState = currentState;</span><br><span class="line">            // 页面生命周期变化原因通知数据观察者的入口</span><br><span class="line">            activeStateChanged(shouldBeActive());</span><br><span class="line">            currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean isAttachedTo(LifecycleOwner owner) &#123;</span><br><span class="line">        return mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 移除生命周期观察者</span><br><span class="line">    @Override</span><br><span class="line">    void detachObserver() &#123;</span><br><span class="line">        mOwner.getLifecycle().removeObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void activeStateChanged(boolean newActive) &#123;</span><br><span class="line">    // 如果页面的活跃状态并没有发生变化就直接return，这是一个优化避免不必要的重复通知</span><br><span class="line">    if (newActive == mActive) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // immediately set active state, so we&#x27;d never dispatch anything to inactive</span><br><span class="line">    // owner</span><br><span class="line">    mActive = newActive;</span><br><span class="line">    // 更新一下当前LiveData中有多少个活跃的页面中有数据观察者正在观察它的value，活跃页面数量0-1调用：onActive()，1-0调用：onInactive()。</span><br><span class="line">    // 不重要，好像是有时候用于判断LiveData是否开始正常工作</span><br><span class="line">    changeActiveCounter(mActive ? 1 : -1);</span><br><span class="line">    if (mActive) &#123;</span><br><span class="line">        // 如果页面从非活跃变为活跃状态，则开始处理通知数据观察者的逻辑。</span><br><span class="line">        dispatchingValue(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>LifecycleBoundObserver内部主要工作是监听页面的生命周期变化并在收到生命周期变化回调时及时响应给LiveData的数据观察者。</li>
<li>其实LifecycleBoundObserver只关注页面是否存在活跃和非活跃状态之间的切换而不关心具体处于哪个生命周期。这也不难理解，监听页面生命周期无非就是想要在页面从非活跃到活跃状态时能及时的刷新页面上的UI，如果不存在非活跃到活跃状态的切换时并没有必要去刷新页面，例如在页面从STARTED-&gt;RESUMED时页面一直处于活跃状态，这时候activeStateChanged()直接执行了return。因为在这过程中首先STARTED中肯定已经通知过数据观察者一次了，即使STARTED-&gt;RESUMED过程中LiveData.value又发生过改变就会执行setValue()，setValue()中会通知该LiveData的所有数据观察者，所以在这里也没有必要再重复通知。</li>
<li>真正的分发是dispatchingValue(this);注意这里传入的是this，我们放在setValue()流程时再一起解析它</li>
</ul>
<h3 id="2-LiveData-gt-setValue"><a href="#2-LiveData-gt-setValue" class="headerlink" title="2. LiveData-&gt;setValue()"></a>2. LiveData-&gt;setValue()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">protected void setValue(T value) &#123;</span><br><span class="line">    // 这是主线程更新值的方式，在子线程中调用就会报错</span><br><span class="line">    assertMainThread(&quot;setValue&quot;);</span><br><span class="line">    // LiveData数据的每一次改动都会促使这个版本号+1，后续当需要通知给观察者时会使用这个值和每个数据观察者内部的版本做判断，如果mVersion版本比较高才会回调onChanged()</span><br><span class="line">    mVersion++;</span><br><span class="line">    // 赋值，这就是真正</span><br><span class="line">    mData = value;</span><br><span class="line">    // 通知数据观察者，此处传入的是null</span><br><span class="line">    dispatchingValue(null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;WeakerAccess&quot;) /* synthetic access */</span><br><span class="line">void dispatchingValue(@Nullable ObserverWrapper initiator) &#123;</span><br><span class="line">    if (mDispatchingValue) &#123;</span><br><span class="line">        // 如果当前正处于在通知数据观察者阶段，则将其设置为无效</span><br><span class="line">        mDispatchInvalidated = true;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = true;</span><br><span class="line">    do &#123;</span><br><span class="line">        mDispatchInvalidated = false;</span><br><span class="line">        // 这是页面生命周期变化触发的通知数据观察者更新</span><br><span class="line">        if (initiator != null) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 这是调用setValue()或者postValue()触发的通知数据观察者更新</span><br><span class="line">            for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                if (mDispatchInvalidated) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (mDispatchInvalidated);</span><br><span class="line">    mDispatchingValue = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private void considerNotify(ObserverWrapper observer) &#123;</span><br><span class="line">    // 如果当前数据观察者绑定的页面为非活跃状态，则直接return不通知</span><br><span class="line">    if (!observer.mActive) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span><br><span class="line">    //</span><br><span class="line">    // we still first check observer.active to keep it as the entrance for events. So even if</span><br><span class="line">    // the observer moved to an active state, if we&#x27;ve not received that event, we better not</span><br><span class="line">    // notify for a more predictable notification order.</span><br><span class="line">    // 如果在多线程情况下数据观察者绑定的页面生命周期又发生了变化从活跃变为非活跃，那也不更新并且将这个数据观察者内部的活跃状态更新一下</span><br><span class="line">    if (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(false);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果数据观察者内部的版本号&gt;=当前要更新的数据的版本号那说明数据已经被更新过了，不需要重复更新，return掉</span><br><span class="line">    if (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    // 最终调用了数据观察者的onChanged()方法</span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实LiveData.setValue()过程很简单，主要做的就是<code>mData = value;</code>给LiveData的数据赋值，然后<code>observer.mObserver.onChanged((T) mData);</code>通知给数据观察者说我的值发生了变化。</p>
<p>既然只做了这么点儿事为什么有这么一大堆的代码，还有什么版本判断啊各种？其实这些代码只是为了兼容多线程场景避免数据失效和冗余通知让逻辑更加健壮而已，对于我们普通开发者其实并不会遇到多线程中通知数据观察者的情况。只有当Lifecycle触发生命周期回调时才有可能出现多线程场景，也就是说<code>LifecycleBoundObserver.onStateChanged()</code>存在多线程的可能（原因结尾再说，不是本章重点）。</p>
<p><strong>dispatchingValue(@Nullable ObserverWrapper initiator)的2种取值</strong></p>
<ul>
<li>页面生命周期回调中通知数据观察者时传入的是this，通过内部的代码逻辑可以看出当initiator有值时只通知给initiator这个观察者，这很好理解，当某个页面生命周期发生变化时，肯定我们只想通知在该页面中监听LiveData的数据观察者去刷新页面，没必要把这个LiveData的全部数据观察者都刷新一遍，因为其他页面中注册的数据观察者完全会在它自己所属的页面从非活跃到活跃状态切换时得到通知。</li>
<li>而当setValue(null)时是因为数据源发生了变更而发出的通知，肯定要让所有数据观察者都知道这个数据的变化，即使某些页面处于非活跃状态本次更新并不会立马被渲染到页面上那也得通知以便更新数据观察者内部的数据源以及mVersion版本号。</li>
<li>dispatchingValue()处理过程是先判断当前是否有正在分发的通知，如果有则将mDispatchInvalidated置为true表示将正在分发的通知置为无效，下面的动do-while循环会继续通过判断mDispatchInvalidated的值来确保最新的值能通知给数据观察者。当然，这一过程是一个多线程下可能发生的场景，所以正常使用的情况下其实不需要关心这一套逻辑，只需要知道dispatchingValue()方法最终调用了considerNotify()方法去最终通知数据观察者。</li>
</ul>
<p>considerNotify()处理过程只要熬过了3个if那么就能真正通知到数据观察者(onChanged)。1、先判断当前数据观察者绑定的页面还是否处于活跃状态，2、再重新获取一次数据观察者绑定的页面生命周期状态值避免多线程情况下页面生命周期已经发生变化并且数据观察者内部还没及时更新这个状态，因为毕竟observer.mActive是在别的方法写的。3、判断数据观察者最后一次收到通知时数据的版本号，只有版本号小于数据当前的版本号才说明数据有更新。满足这三个if之后最终onChanged()才能得到执行，流程完毕。</p>
<h3 id="LiveData-gt-postValue-如何保证线程安全"><a href="#LiveData-gt-postValue-如何保证线程安全" class="headerlink" title="LiveData-&gt;postValue()如何保证线程安全?"></a>LiveData-&gt;postValue()如何保证线程安全?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">final Object mDataLock = new Object();</span><br><span class="line"></span><br><span class="line">private final Runnable mPostValueRunnable = new Runnable() &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Object newValue;</span><br><span class="line">        synchronized (mDataLock) &#123;</span><br><span class="line">            newValue = mPendingData;</span><br><span class="line">            mPendingData = NOT_SET;</span><br><span class="line">        &#125;</span><br><span class="line">        setValue((T) newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">protected void postValue(T value) &#123;</span><br><span class="line">    boolean postTask;</span><br><span class="line">    synchronized (mDataLock) &#123;</span><br><span class="line">        postTask = mPendingData == NOT_SET;</span><br><span class="line">        mPendingData = value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!postTask) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先postValue()是通过Handler将LiveData数据源更新的逻辑从子线程发送到主线程中去执行，并且通过同步锁的方式实现线程安全。具体实现是将newValue和mPendingData的赋值过程加锁保证当主线程正在执行newValue数据更新之前如果子线程再次调用postValue()会被直接过滤掉后面这次postValue()然后主线程会使用最新的newValue去执行setValue()。即保证了性能上的优化过滤掉了不必要的setValue()流程又保证了值的准确性。</p>
<h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><ol>
<li>LiveData-&gt;observer(lifecycleOwner,observer)时不要把同一个observer对象和不同的lifecycleOwner绑定否则会抛出异常</li>
<li>在Fragment中使用LiveData时请使用viewLifecycleOwner而不要使用Fragment或者Activity实例</li>
<li>也可以通过observeForever()来设置一个不在乎页面生命周期的数据观察者，此时不管设置监听时处于什么页面也不管页面是否活跃都会收到LiveData数据变化的通知，但是这种监听需要我们手动去解除绑定</li>
</ol>
<p>随便说说LiveData存储结构：</p>
<img src="/2022/09/15/Jetpack-LiveData/LiveData%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg" class="" title="LiveData存储结构">


<p>遗留问题：<br><strong>LiveData粘性事件</strong></p>
<p><strong>Fragment中使用LiveData为什么要传入viewLifecycleOwner?</strong></p>
<p><strong>为什么LiveData-&gt;setValue()-&gt;dispatchingValue()过程中会有多线程的场景兼容？</strong></p>
<p>还有一些关于LiveData的知识点由于篇幅原因放在下一篇文章中：<a target="_blank" rel="noopener" href="https://lianwenhong.top/2022/09/17/Jetpack-LiveData%E5%8E%9F%E7%90%86%E8%A1%A5%E5%85%85/">Jetpack-LiveData 原理补充</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/lianwenhong?tab=repositories">项目</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#LiveData%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">LiveData简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-LiveData-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">2.</span> <span class="toc-text">使用 LiveData 的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LiveData%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">LiveData的简单使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LiveData%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">LiveData原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-LiveData-gt-observe"><span class="toc-number">4.1.</span> <span class="toc-text">1. LiveData-&gt;observe()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-LiveData-gt-setValue"><span class="toc-number">4.2.</span> <span class="toc-text">2. LiveData-&gt;setValue()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LiveData-gt-postValue-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.3.</span> <span class="toc-text">LiveData-&gt;postValue()如何保证线程安全?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">使用总结</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/09/15/Jetpack-LiveData/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/09/15/Jetpack-LiveData/&text=Jetpack-LiveData"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/09/15/Jetpack-LiveData/&title=Jetpack-LiveData"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/09/15/Jetpack-LiveData/&is_video=false&description=Jetpack-LiveData"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Jetpack-LiveData&body=Check out this article: http://example.com/2022/09/15/Jetpack-LiveData/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/09/15/Jetpack-LiveData/&title=Jetpack-LiveData"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/09/15/Jetpack-LiveData/&title=Jetpack-LiveData"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/09/15/Jetpack-LiveData/&title=Jetpack-LiveData"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/09/15/Jetpack-LiveData/&title=Jetpack-LiveData"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/09/15/Jetpack-LiveData/&name=Jetpack-LiveData&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/09/15/Jetpack-LiveData/&t=Jetpack-LiveData"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2023
    lianwenhong
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/lianwenhong?tab=repositories">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
