<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android-Resource解析</title>
    <url>/2022/04/02/Android-Resource%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android版本号对应关系</title>
    <url>/2022/03/29/Android%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="Android系统版本对应API"><a href="#Android系统版本对应API" class="headerlink" title="Android系统版本对应API"></a>Android系统版本对应API</h3><table>
<thead>
<tr>
<th align="left">API版本号</th>
<th align="right">版本名称（英&#x2F;汉）</th>
<th align="center">发布时间</th>
</tr>
</thead>
<tbody><tr>
<td align="left">API 31</td>
<td align="right">android 12.0 Snow Cone</td>
<td align="center">2021.10</td>
</tr>
<tr>
<td align="left">API 30</td>
<td align="right">android 11.0 R</td>
<td align="center">2020.9</td>
</tr>
<tr>
<td align="left">API 29</td>
<td align="right">android 10.0 Q</td>
<td align="center">2019.8</td>
</tr>
<tr>
<td align="left">API 28</td>
<td align="right">android 9.0 Pie&#x2F;馅饼</td>
<td align="center">2018.8</td>
</tr>
<tr>
<td align="left">API 27</td>
<td align="right">android 8.1 Oreo&#x2F;奥利奥</td>
<td align="center">2017.12</td>
</tr>
<tr>
<td align="left">API 26</td>
<td align="right">android 8.0 Oreo&#x2F;奥利奥</td>
<td align="center">2017.8</td>
</tr>
<tr>
<td align="left">API 25</td>
<td align="right">android 7.1 Nougat&#x2F;牛轧糖</td>
<td align="center">2016.10</td>
</tr>
<tr>
<td align="left">API 24</td>
<td align="right">android 7.0 Nougat&#x2F;牛轧糖</td>
<td align="center">2016.8</td>
</tr>
<tr>
<td align="left">API 23</td>
<td align="right">android 6.0 Marshmallow&#x2F;棉花糖</td>
<td align="center">2015.8</td>
</tr>
<tr>
<td align="left">API 22</td>
<td align="right">android 5.1 Lollipop&#x2F;棒棒糖</td>
<td align="center">2014.12</td>
</tr>
<tr>
<td align="left">API 21</td>
<td align="right">android 5.0 Lollipop&#x2F;棒棒糖</td>
<td align="center">2014.10</td>
</tr>
<tr>
<td align="left">API 20</td>
<td align="right">android 4.4W KitKat&#x2F;奇巧巧克力棒</td>
<td align="center">2013底</td>
</tr>
<tr>
<td align="left">API 19</td>
<td align="right">android 4.4 KitKat&#x2F;奇巧巧克力棒</td>
<td align="center">2013.11</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android源码解析-App的ClassLoader</title>
    <url>/2022/04/14/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-App%E7%9A%84ClassLoader/</url>
    <content><![CDATA[<h2 id="Android中的默认类加载器："><a href="#Android中的默认类加载器：" class="headerlink" title="Android中的默认类加载器："></a>Android中的默认类加载器：</h2><p>Android虚拟机就是一个特殊的JVM，不管是以前的dalvik还是现在的ART。所以其类加载流程一样遵循jvm的规则（双亲委托机制）</p>
<p>如果对jvm的类加载流程不熟悉可以阅读另一篇文章：<a href="http://lianwenhong.top/2022/04/16/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-ClassLoader%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#more">java类加载原理(ClassLoader工作原理)</a></p>
<p>Android类加载器之相较于Java类加载器的最大区别在于：</p>
<p>java类加载器是从某个目录中去直接加载.class文件或者是从目录下的zip、jar包等归档文件中加载.class文件</p>
<p>而Android类加载器是从某个目录下去直接加载.dex文件或者是从目录下的zip、jar、apk等文件中的.dex文件中去加载.class文件，如果不是.dex文件的话加载不了。</p>
<span id="more"></span>

<img src="/2022/04/14/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-App%E7%9A%84ClassLoader/Android%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" class="" title="Android默认类加载器关系图">

<p>以上类关系图清楚的描述了Android中的默认类加载器以及它们的父子关系。<br>图中有涉及到了DexPathList这个类简单来说是存放该类加载器的加载区域中的所有dex文件，在Android的插件化方案和热修复方案中经常会使用将补丁包或者插件包中的dex插入这个数组的第一个来实现热修复或者加载插件的功能。具体详情可看另一个文章：<a href="http://lianwenhong.top/2022/04/13/android%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%B0%8F%E8%AE%B0/#more">android热修复小记</a></p>
<h2 id="app中的类加载器"><a href="#app中的类加载器" class="headerlink" title="app中的类加载器"></a>app中的类加载器</h2><p>在Android开发中例如在Activity中会调用getClassLoader()来获取类加载器，这时候这个类加载器是怎么来的呢？来分析一下</p>
<p>Activity类中并没有getClassLoader()，从继承关系上可以知道最终调用的是<code>ContextWrapper.getClassLoader()</code>，最终的实现在<strong>ContextImpl</strong>中。如果不知道的话可以看下我另外一篇文章：<a href="http://lianwenhong.top/2022/03/29/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-Context%E8%A7%A3%E6%9E%90/#more">Android源码小记-Context解析</a>，可以清楚了解Context的继承关系以及Activity和Context之间是如何关联以及与ContextImpl之间的联系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ContextImpl.java</span><br><span class="line"></span><br><span class="line">public ClassLoader getClassLoader() &#123;</span><br><span class="line">    return mPackageInfo != null ?</span><br><span class="line">            mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个mPackageInfo对象是一个LoadedApk，持有apk的所有信息，是apk在内存中的表现形态。（<a href="http://lianwenhong.top/2022/04/14/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-LoadedApk/">ANdroid源码小记-LoadedApk</a>）,而它是在构造ContextImpl的时候传进来并赋值的。</p>
<p>在启动Activity时，最终会走ActivityThread中的handleLaunchActivity()方法，这个方法里就会最终调用到先知性Instrumentation.newActivity()通过类加载器创建一个Activity实例，然后调用createBaseContextForActivity()去创建一个处理提供Activity运行环境的ContextImpl，此时就会给mPackageInfo赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123;</span><br><span class="line">    int displayId = Display.DEFAULT_DISPLAY;</span><br><span class="line">    try &#123;</span><br><span class="line">        displayId = ActivityManagerNative.getDefault().getActivityDisplayId(r.token);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建提供Activity运行环境的ContextImpl用于之后attach给Activity，此时传入的LoadedApk是r.packageInfo</span><br><span class="line">    ContextImpl appContext = ContextImpl.createActivityContext(</span><br><span class="line">            this, r.packageInfo, r.token, displayId, r.overrideConfig);</span><br><span class="line">    appContext.setOuterContext(activity);</span><br><span class="line">    Context baseContext = appContext;</span><br><span class="line"></span><br><span class="line">    final DisplayManagerGlobal dm = DisplayManagerGlobal.getInstance();</span><br><span class="line">    // For debugging purposes, if the activity&#x27;s package name contains the value of</span><br><span class="line">    // the &quot;debug.use-second-display&quot; system property as a substring, then show</span><br><span class="line">    // its content on a secondary display if there is one.</span><br><span class="line">    String pkgName = SystemProperties.get(&quot;debug.second-display.pkg&quot;);</span><br><span class="line">    if (pkgName != null &amp;&amp; !pkgName.isEmpty()</span><br><span class="line">            &amp;&amp; r.packageInfo.mPackageName.contains(pkgName)) &#123;</span><br><span class="line">        for (int id : dm.getDisplayIds()) &#123;</span><br><span class="line">            if (id != Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">                Display display =</span><br><span class="line">                        dm.getCompatibleDisplay(id, appContext.getDisplayAdjustments(id));</span><br><span class="line">                baseContext = appContext.createDisplayContext(display);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return baseContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<strong>r.packageInfo</strong>其实就是在应用刚启动时在**ActivityThread.handleBindApplication()<strong>方法中的</strong>data.info &#x3D; getPackageInfoNoCheck(data.appInfo, data.compatInfo);**这里创建的，这时候创建出一个表示本应用的LoadedApk,正常情况下全局都共用这个LoadedApk对象，创建Activity的ContextImpl时也不例外。</p>
<p>回到ContextImpl.getClassLoader()中，mPackageInfo已经知道怎么来了，那再来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ClassLoader getClassLoader() &#123;</span><br><span class="line">    return mPackageInfo != null ?</span><br><span class="line">            mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时mPackageInfo不为空走<code>mPackageInfo.getClassLoader()</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ClassLoader getClassLoader() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mClassLoader == null) &#123;</span><br><span class="line">            createOrUpdateClassLoaderLocked(null /*addedPaths*/);</span><br><span class="line">        &#125;</span><br><span class="line">        return mClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常走到这里因为我们的应用报名肯定不是”android”，因为packageName.equals(“android”)是系统本身，所以我们最终只能走到<code>createOrUpdateClassLoaderLocked()</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void createOrUpdateClassLoaderLocked(List&lt;String&gt; addedPaths) &#123;</span><br><span class="line">    if (mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">        // 系统的情况不看，我们走不到</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (!mIncludeCode) &#123;</span><br><span class="line">        if (mClassLoader == null) &#123;</span><br><span class="line">            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();</span><br><span class="line">            // 创建ClassLoader</span><br><span class="line">            mClassLoader = ApplicationLoaders.getDefault().getClassLoader(</span><br><span class="line">                &quot;&quot; /* codePath */, mApplicationInfo.targetSdkVersion, isBundledApp,</span><br><span class="line">                librarySearchPath, libraryPermittedPath, mBaseClassLoader);</span><br><span class="line">            StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (mClassLoader == null) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip,</span><br><span class="line">                mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath,</span><br><span class="line">                libraryPermittedPath, mBaseClassLoader);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (addedPaths != null &amp;&amp; addedPaths.size() &gt; 0) &#123;</span><br><span class="line">        final String add = TextUtils.join(File.pathSeparator, addedPaths);</span><br><span class="line">        // 添加主工程的源码路径</span><br><span class="line">        ApplicationLoaders.getDefault().addPath(mClassLoader, add);</span><br><span class="line">        // Setup the new code paths for profiling.</span><br><span class="line">        needToSetupJitProfiles = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的最后还是通过<code>ApplicationLoaders.getClassLoader()</code>来创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ClassLoader getClassLoader(String zip, int targetSdkVersion, boolean isBundled,</span><br><span class="line">                                  String librarySearchPath, String libraryPermittedPath,</span><br><span class="line">                                  ClassLoader parent) &#123;</span><br><span class="line">    // 传入的是系统ClassLoader，阅读源码其实是PathClassLoader，可以看ClassLoader.createSystemClassLoader()，其parent是BootClassLoader，所有此时baseParent = BootClassLoader</span><br><span class="line">    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line"></span><br><span class="line">    synchronized (mLoaders) &#123;</span><br><span class="line">        if (parent == null) &#123;</span><br><span class="line">            parent = baseParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        // 如果是lib库中的类返回的加载区域为lib目录的类加载器</span><br><span class="line">        if (parent == baseParent) &#123;</span><br><span class="line">            ClassLoader loader = mLoaders.get(zip);</span><br><span class="line">            if (loader != null) &#123;</span><br><span class="line">                return loader;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line"></span><br><span class="line">            PathClassLoader pathClassloader = PathClassLoaderFactory.createClassLoader(</span><br><span class="line">                                                  zip,</span><br><span class="line">                                                  librarySearchPath,</span><br><span class="line">                                                  libraryPermittedPath,</span><br><span class="line">                                                  parent,</span><br><span class="line">                                                  targetSdkVersion,</span><br><span class="line">                                                  isBundled);</span><br><span class="line"></span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;setupVulkanLayerPath&quot;);</span><br><span class="line">            setupVulkanLayerPath(pathClassloader, librarySearchPath);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">            mLoaders.put(zip, pathClassloader);</span><br><span class="line">            return pathClassloader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">        // 应用主工程中的类返回的是加载区域为apk的sourceDir所在目录的PathClassLoader</span><br><span class="line">        PathClassLoader pathClassloader = new PathClassLoader(zip, parent);</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        return pathClassloader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后可以得出结论：首先反正返回的肯定是PathClassLoader，调用getClassLoader()的类属于不同的位置（主工程或者lib工程)则创建的PathClassLoader对应的加载区域也是不同的，具体要看住工程的加载区域可以跟踪一下，在创建的时候传入的zip是””，则它是通过addPath()方法传入的，该方法在BaseDexClassLoader中，而创建出来的PathClassLoader调用这个方法的地方是在ApplicationLoader.addPath():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void addPath(ClassLoader classLoader, String dexPath) &#123;</span><br><span class="line">    if (!(classLoader instanceof PathClassLoader)) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;class loader is not a PathClassLoader&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final PathClassLoader baseDexClassLoader = (PathClassLoader) classLoader;</span><br><span class="line">    baseDexClassLoader.addDexPath(dexPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法在刚才的<code>LoadedApk.createOrUpdateClassLoaderLocked()</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (addedPaths != null &amp;&amp; addedPaths.size() &gt; 0) &#123;</span><br><span class="line">    final String add = TextUtils.join(File.pathSeparator, addedPaths);</span><br><span class="line">    ApplicationLoaders.getDefault().addPath(mClassLoader, add);</span><br><span class="line">    // Setup the new code paths for profiling.</span><br><span class="line">    needToSetupJitProfiles = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续追溯add参数的来源是LoadedApk.makePaths(),最后的结论就是这个路径是ApplicationInfo的sourceDir。</p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>在Activity中调用getClassLoader()返回的是PathClassLoader,它的父类加载器是系统的类加载器也是个PathClassLoader，再往上是BootClassLoader。</p>
<p>温馨提示：</p>
<p>要清楚明白的知道ActivityThread、Activity、Application、Context、LoadedApk、Instrumentation这些类的关系对阅读Android源码很有帮助。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android源码小记-LoadedApk</title>
    <url>/2022/04/14/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-LoadedApk/</url>
    <content><![CDATA[<p>文章基于API25分析，源码地址：<a href="http://androidxref.com/7.1.1_r6/">http://androidxref.com/7.1.1_r6/</a></p>
<h2 id="什么是LoadedApk"><a href="#什么是LoadedApk" class="headerlink" title="什么是LoadedApk"></a>什么是LoadedApk</h2><p>看下源码中对LoadedApk的注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Local state maintained about a currently loaded .apk.</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">public final class LoadedApk &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>翻译过来就是维护当前加载的 .apk 的本地状态。大白话讲LoadedApk就是一个.apk文件在内存中的表现形式。</p>
<blockquote>
<p>换句话说LoadedApk是apk安装文件在内存中的数据，可以在LoadedApk中得到apk文件中的代码、资源文件、Activity、Service组件、manifest配置文件等等信息，这些都封装在LoadedApk这个类中。</p>
</blockquote>
<p>我们知道应用启动是通过Zygote进程fork出一个应用进程之后调用ActivityThread.main()方法才走到应用自身。</p>
<p><strong>1个apk应用对应1个ActivityThread</strong></p>
<p><strong>1个apk应用也对应1个LoadedApk</strong></p>
<span id="more"></span>

<p>早前我在阅读源码的时候一直有一个疑惑，既然LoadedApk是apk文件在内存中的表现形态，那我们的应用的ActivityThread里面为什么mPackages、mResourcePackages这俩属性为什么要用map来定义呢？那不是说明会有很多个LoadedApk？而且我之前看一个文章上有一句话：<em>一个进程可以加载多个apk</em>。我一直不理解？</p>
<p>直到后来我了解插件化的时候我想明白了！插件化有一种方式是定义一个插件LoadedApk然后插入ActivityThread的mPackages集合中，这样在宿主工程中就能轻松访跳转插件中的Activity。原理是使用插件LoadedApk获取到插件的ClassLoader并加载出插件中的Activity类（具体原理我会再行撰文）。这就理解了一个进程是可以加载多个apk的。</p>
<p>既然LoadedApk是apk在内存中的表现形式，其内部包含了整个<code>mApplicationInfo</code>，那就可以理解用它能做很多事</p>
<ul>
<li>创建一个Application放在这个类中再合适不过，因为LoadedApk本身就包含了manifest配置文件中的信息。</li>
<li>用它来获取Resources也合情合理，因为资源文件也包含其中。</li>
<li>…<br>也就是说其实在各个地方只要获取到这个LoadedApk对象就能获取应用的所有信息。</li>
</ul>
<h2 id="LoadedApk创建过程源码分析"><a href="#LoadedApk创建过程源码分析" class="headerlink" title="LoadedApk创建过程源码分析"></a>LoadedApk创建过程源码分析</h2><p>我们了解了App启动流程之后（如不了解看我另一文章 xxx）知道，一个App进程启动之后会立马调用到ActivityThread.main()方法中来，在内部会执行attach()然后调用AMS.attachApplication(IApplicationThread)方法让AMS进程去初始化应用最后将结果通过IApplication这个接口返回给应用进程。此时应用进程会通过H这个Handler走到handleBindApplication()这个方法，应用就开始处理并创建Application了，LoadedApk也是在这一步生成的。</p>
<blockquote>
<p>ActivityThread.attach() -&gt; AMS.attachApplication(IApplicationThread thread) -&gt; ApplicationThread.bindApplication() -&gt; H -&gt; ActivityThread.handleBindApplication() -&gt; ActivityThread. getPackageInfoNoCheck(data.appInfo, data.compatInfo) -&gt; LoadedApk.构造()</p>
</blockquote>
<p>直接分析getPackageInfoNoCheck():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityThread.java</span><br><span class="line"></span><br><span class="line">public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,CompatibilityInfo compatInfo) &#123;</span><br><span class="line">    return getPackageInfo(ai, compatInfo, null, false, true, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,</span><br><span class="line">        ClassLoader baseLoader, boolean securityViolation, boolean includeCode,</span><br><span class="line">        boolean registerPackage) &#123;</span><br><span class="line">    // 判断应用uid，一般正常安装的apk differentUser值为false，除非是手动去加载的其他apk</span><br><span class="line">    final boolean differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));</span><br><span class="line">    synchronized (mResourcesManager) &#123;</span><br><span class="line">        WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        if (differentUser) &#123;</span><br><span class="line">            // Caching not supported across users</span><br><span class="line">            ref = null;</span><br><span class="line">        &#125; else if (includeCode) &#123;</span><br><span class="line">            // 传入的includeCode为true，所以从缓存中取出LoadedApk对象</span><br><span class="line">            ref = mPackages.get(aInfo.packageName);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ref = mResourcePackages.get(aInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LoadedApk packageInfo = ref != null ? ref.get() : null;</span><br><span class="line">        // 如果是刚进应用则缓存中就不存在该apk对应的LoadedApk，就会去走创建流程</span><br><span class="line">        if (packageInfo == null || (packageInfo.mResources != null</span><br><span class="line">                &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;</span><br><span class="line">            if (localLOGV) Slog.v(TAG, (includeCode ? &quot;Loading code package &quot;</span><br><span class="line">                    : &quot;Loading resource-only package &quot;) + aInfo.packageName</span><br><span class="line">                    + &quot; (in &quot; + (mBoundApplication != null</span><br><span class="line">                            ? mBoundApplication.processName : null)</span><br><span class="line">                    + &quot;)&quot;);</span><br><span class="line">            // 创建一个新的LoadedApk对象，里面包含了ApplicationInfo，CompatibilityInfo等信息</span><br><span class="line">            packageInfo =</span><br><span class="line">                new LoadedApk(this, aInfo, compatInfo, baseLoader,</span><br><span class="line">                        securityViolation, includeCode &amp;&amp;</span><br><span class="line">                        (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);</span><br><span class="line"></span><br><span class="line">            if (mSystemThread &amp;&amp; &quot;android&quot;.equals(aInfo.packageName)) &#123;</span><br><span class="line">                packageInfo.installSystemApplicationInfo(aInfo,</span><br><span class="line">                        getSystemContext().mPackageInfo.getClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (differentUser) &#123;</span><br><span class="line">                // Caching not supported across users</span><br><span class="line">            &#125; else if (includeCode) &#123;</span><br><span class="line">                // 创建完成之后会将其缓存起来，后面系统流程中需要使用的时候直接根据对应的包名从缓存中获取</span><br><span class="line">                mPackages.put(aInfo.packageName,</span><br><span class="line">                        new WeakReference&lt;LoadedApk&gt;(packageInfo));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mResourcePackages.put(aInfo.packageName,</span><br><span class="line">                        new WeakReference&lt;LoadedApk&gt;(packageInfo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return packageInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是应用的LoadedApk的创建流程，只是简单理解不去深究里面的ApplicationInfo、CompatibilityInfo这些是如何构造的就很简单，要深究的话一篇也讲不完。</p>
<p>在App的启动过程中，LoadedApk做的一个很关键的事情就是创建Application对象，我们简单看看<code>handleBindApplication</code>内通过LoadedApk去创建一个Application的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityThread.java</span><br><span class="line"></span><br><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用到<code>LoadedApk.makeApplication()</code>方法去了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,Instrumentation instrumentation) &#123;</span><br><span class="line">    if (mApplication != null) &#123;</span><br><span class="line">        return mApplication;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;makeApplication&quot;);</span><br><span class="line"></span><br><span class="line">    Application app = null;</span><br><span class="line"></span><br><span class="line">    // 获取manifest配置文件中指定的Application，如果我们自定义了那么appClass就是我们自定义Application的类名，否则系统默认创建类名为&quot;android.app.Application&quot;的默认Application对象</span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">        appClass = &quot;android.app.Application&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //  获取应用类加载器，正常情况下取出来的会是PathClassLoader</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        // 表示非系统应用</span><br><span class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                    &quot;initializeJavaContextClassLoader&quot;);</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">        // 先创建一个ContextImpl对象后续赋值给Application对应的mBase，完成Application对ContextImpl的代理，此处会将本LoadedApk实例传给Application对应的ContextImpl，其实如果了解Activity的构建的话可以去看下，Activity对应的ContextImpl中也传入了这个LoadedApk对象。正常情况如果没有加载多个apk的话，全局都是共用的这一个LoadedApk对象</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">        // 调用ActivityThread的mInstrumentation传入类名和类加载器执行创建实例操作，内部是用的反射来实现的创建。</span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate application &quot; + appClass</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActivityThread.mAllApplications.add(app);</span><br><span class="line">    mApplication = app;</span><br><span class="line"></span><br><span class="line">    if (instrumentation != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            instrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Rewrite the R &#x27;constants&#x27; for all library apks.</span><br><span class="line">    SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread)</span><br><span class="line">            .getAssignedPackageIdentifiers();</span><br><span class="line">    final int N = packageIdentifiers.size();</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        final int id = packageIdentifiers.keyAt(i);</span><br><span class="line">        if (id == 0x01 || id == 0x7f) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码注释中清楚解释了如何使用LoadedApk去构建Application。其中涉及到了Instrumentation对象，其实这个对象只是一个对Application和Activity创建和生命周期流程等操作的统一封装，这样能使代码结构更加清晰。并且其内部还有一些模拟按键的方法。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>LoadedApk是apk安装文件在内存中的数据，可以在LoadedApk中得到apk文件中的代码、资源文件、Activity、Service组件、manifest配置文件等等信息，这些都封装在LoadedApk这个类中。</li>
<li>在正常情况下同一个安装包下的Activity和Application等这些组件都是公用的一个LoadedApk对象。</li>
<li>在任何场景下只要获取了LoadedApk对象就能获取到应用的信息，例如Activity中获取资源其实也是通过ContextImpl获取了应用的LoadedApk对象实例然后去调用的<code>ActivityThread.getTopLevelResources();</code>方法。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>System.load()与System.loadLibrary()实现及so热修复</title>
    <url>/2022/04/13/Android%E4%B8%A4%E7%A7%8Dso%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8F%8Aso%E7%83%AD%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<p>文章基于API25分析，源码地址：<a href="http://androidxref.com/7.1.1_r6/">http://androidxref.com/7.1.1_r6/</a></p>
<h3 id="ClassLoader简单复习（必要前提）"><a href="#ClassLoader简单复习（必要前提）" class="headerlink" title="ClassLoader简单复习（必要前提）"></a>ClassLoader简单复习（必要前提）</h3><p>在分析System类之前，先简单复习一下ClassLoader的类加载机制。</p>
<img src="/2022/04/13/Android%E4%B8%A4%E7%A7%8Dso%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8F%8Aso%E7%83%AD%E4%BF%AE%E5%A4%8D/ClassLoader%E7%B1%BB%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E5%9B%BE%E4%BB%A5%E5%8F%8A%E6%9B%BF%E6%8D%A2dexElements%E5%AE%9E%E7%8E%B0%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86.jpg" class="" title="ClassLoader类结构关系图以及替换dexElements实现热修复原理">

<span id="more"></span>

<p>Android应用中模式使用的类加载器是<strong>PathClassLoader</strong>。想要了解可简单看下<strong>Application.getClassLoader()</strong> 的调用栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Application.getClassLoader() -&gt; ContextImpl.getClassLoader -&gt;</span><br><span class="line">LoadedApk.getClassLoader() -&gt; ... -&gt; ClassLoader.createSystemClassLoader() -&gt; new PathClassLoader(...)</span><br></pre></td></tr></table></figure>
<p>而<strong>PathClassLoader</strong>只是重载了几个构造方法，真正的代码实现都在父类<strong>BaseDexClassLoader</strong>中。</p>
<p>BaseDexClassLoader中pathList:DexPathList类说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final class DexPathList &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // List of dex/resource (class path) elements.意思是class文件转化结果:dex文件集合</span><br><span class="line">    private Element[] dexElements;</span><br><span class="line"></span><br><span class="line">    // List of native library path elements. 意思是native层so文件集合  </span><br><span class="line">    // 在热修复技术中so修复可以将新的so库路径追加到此数组之前达到热修效果，其实它是将例如xxx/xxx/abc.so分别以dir:xxx/xxx/、zip:abc.so这样区分存储而已，为了使用方便</span><br><span class="line">    private final Element[] nativeLibraryPathElements;</span><br><span class="line"></span><br><span class="line">    // List of application native library directories. 意思是native层so文件的路径集合，只表示路径。</span><br><span class="line">    private final List&lt;File&gt; nativeLibraryDirectories;</span><br><span class="line"></span><br><span class="line">    // List of system native library directories.意思是系统so文件路径集合</span><br><span class="line">    private final List&lt;File&gt; systemNativeLibraryDirectories;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Element &#123;</span><br><span class="line">    private final File dir; // 路径</span><br><span class="line">    private final boolean isDirectory; // 该Element是否是文件夹</span><br><span class="line">    private final File zip; // 路径下对应的文件</span><br><span class="line">    private final DexFile dexFile; // 路径下对应的dex文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类加载机制了解简单了解完开始分析<strong>System</strong>类。</p>
<h3 id="System-load"><a href="#System-load" class="headerlink" title="System.load():"></a>System.load():</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void load(String filename) &#123;</span><br><span class="line">    Runtime.getRuntime().load0(VMStack.getStackClass1(), filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用Runtime类中的load0()方法将文件名传入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized void load0(Class fromClass, String filename) &#123;</span><br><span class="line">    if (!(new File(filename).isAbsolute())) &#123;</span><br><span class="line">        throw new UnsatisfiedLinkError(</span><br><span class="line">            &quot;Expecting an absolute path of the library: &quot; + filename);</span><br><span class="line">    &#125;</span><br><span class="line">    if (filename == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;filename == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 最终调用此方法去load so文件，其内部是去调用native方法</span><br><span class="line">    String error = doLoad(filename, fromClass.getClassLoader());</span><br><span class="line">    if (error != null) &#123;</span><br><span class="line">        throw new UnsatisfiedLinkError(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 注释大概意思是我们日常应用进程是从Zygote进程fork出来的所以都是公用的同一个LD_LIBRARY_PATH路径。</span><br><span class="line"> * 开放这个方法是为了用户能动态的加载不同路径下的so库而不是只有启动的时候从单一的目录加载一次。</span><br><span class="line"> * 理由是因为一个进程可能会运行多个apk并且用户可能会手动实现自己的BaseDexClassLoader，</span><br><span class="line"> * 所以有必要为用户提供一个差异化so加载的能力</span><br><span class="line"> */</span><br><span class="line">private String doLoad(String name, ClassLoader loader) &#123;</span><br><span class="line">    // Android apps are forked from the zygote, so they can&#x27;t have a custom LD_LIBRARY_PATH,</span><br><span class="line">    // which means that by default an app&#x27;s shared library directory isn&#x27;t on LD_LIBRARY_PATH.</span><br><span class="line"></span><br><span class="line">    // The PathClassLoader set up by frameworks/base knows the appropriate path, so we can load</span><br><span class="line">    // libraries with no dependencies just fine, but an app that has multiple libraries that</span><br><span class="line">    // depend on each other needed to load them in most-dependent-first order.</span><br><span class="line"></span><br><span class="line">    // We added API to Android&#x27;s dynamic linker so we can update the library path used for</span><br><span class="line">    // the currently-running process. We pull the desired path out of the ClassLoader here</span><br><span class="line">    // and pass it to nativeLoad so that it can call the private dynamic linker API.</span><br><span class="line"></span><br><span class="line">    // We didn&#x27;t just change frameworks/base to update the LD_LIBRARY_PATH once at the</span><br><span class="line">    // beginning because multiple apks can run in the same process and third party code can</span><br><span class="line">    // use its own BaseDexClassLoader.</span><br><span class="line"></span><br><span class="line">    // We didn&#x27;t just add a dlopen_with_custom_LD_LIBRARY_PATH call because we wanted any</span><br><span class="line">    // dlopen(3) calls made from a .so&#x27;s JNI_OnLoad to work too.</span><br><span class="line"></span><br><span class="line">    // So, find out what the native library search path is for the ClassLoader in question...</span><br><span class="line">    String librarySearchPath = null;</span><br><span class="line">    if (loader != null &amp;&amp; loader instanceof BaseDexClassLoader) &#123;</span><br><span class="line">        BaseDexClassLoader dexClassLoader = (BaseDexClassLoader) loader;</span><br><span class="line">        // 调用BaseDexClassLoader中的方法用于将所有native的lib路径以：拼接在一起然后给native层去load so文件</span><br><span class="line">        librarySearchPath = dexClassLoader.getLdLibraryPath();</span><br><span class="line">    &#125;</span><br><span class="line">    // nativeLoad should be synchronized so there&#x27;s only one LD_LIBRARY_PATH in use regardless</span><br><span class="line">    // of how many ClassLoaders are in the system, but dalvik doesn&#x27;t support synchronized</span><br><span class="line">    // internal natives.</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        // 最终调用native方法去load so库。Android所有的so库都是通过这个方法加载进内存的</span><br><span class="line">        return nativeLoad(name, loader, librarySearchPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TODO: should be synchronized, but dalvik doesn&#x27;t support synchronized internal natives.</span><br><span class="line">    private static native String nativeLoad(String filename, ClassLoader loader,</span><br><span class="line">                                            String librarySearchPath);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上是<strong>System.load()</strong> 的全部流程。</p>
<h3 id="System-loadLibrary"><a href="#System-loadLibrary" class="headerlink" title="System.loadLibrary()"></a>System.loadLibrary()</h3><p>System.loadLibrary()相比System.load()会复杂一些。因为它不再是从你随便指定的路径中去加载so，而是从系统给你的路径中加载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void loadLibrary(String libname) &#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一样是走到Runtime类中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized void loadLibrary0(ClassLoader loader, String libname) &#123;</span><br><span class="line">    if (libname.indexOf((int)File.separatorChar) != -1) &#123;</span><br><span class="line">        // 如果传入的是带/的文件路径则抛异常，这个类型的异常如果进行ndk相关开发肯定见过</span><br><span class="line">        throw new UnsatisfiedLinkError(</span><br><span class="line">&quot;Directory separator should not appear in library name: &quot; + libname);</span><br><span class="line">    &#125;</span><br><span class="line">    String libraryName = libname;</span><br><span class="line">    if (loader != null) &#123;</span><br><span class="line"></span><br><span class="line">        // 从类加载器中查找so文件名并以全路径返回，类加载器中查找so时的路径是在其构造的时候指定的。</span><br><span class="line">        String filename = loader.findLibrary(libraryName);</span><br><span class="line">        if (filename == null) &#123;</span><br><span class="line">            // It&#x27;s not necessarily true that the ClassLoader used</span><br><span class="line">            // System.mapLibraryName, but the default setup does, and it&#x27;s</span><br><span class="line">            // misleading to say we didn&#x27;t find &quot;libMyLibrary.so&quot; when we</span><br><span class="line">            // actually searched for &quot;liblibMyLibrary.so.so&quot;.</span><br><span class="line">            throw new UnsatisfiedLinkError(loader + &quot; couldn&#x27;t find \&quot;&quot; +</span><br><span class="line">                                           System.mapLibraryName(libraryName) + &quot;\&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到就加载</span><br><span class="line">        String error = doLoad(filename, loader);</span><br><span class="line">        if (error != null) &#123;</span><br><span class="line">            throw new UnsatisfiedLinkError(error);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果类加载器为空，则获取到比如xxx.so，然后从系统提供的目录中查找(例如：/vendor/lib:/system/lib)，一样判断是否只读如果是则调用doLoad()加载</span><br><span class="line">    String filename = System.mapLibraryName(libraryName);</span><br><span class="line">    List&lt;String&gt; candidates = new ArrayList&lt;String&gt;();</span><br><span class="line">    String lastError = null;</span><br><span class="line">    for (String directory : getLibPaths()) &#123;</span><br><span class="line">        String candidate = directory + filename;</span><br><span class="line">        candidates.add(candidate);</span><br><span class="line"></span><br><span class="line">        if (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">            String error = doLoad(candidate, loader);</span><br><span class="line">            if (error == null) &#123;</span><br><span class="line">                return; // We successfully loaded the library. Job done.</span><br><span class="line">            &#125;</span><br><span class="line">            lastError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (lastError != null) &#123;</span><br><span class="line">        throw new UnsatisfiedLinkError(lastError);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new UnsatisfiedLinkError(&quot;Library &quot; + libraryName + &quot; not found; tried &quot; + candidates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当类加载器不是空的时候，调用<code> load.findLibrary(libraryName)</code>最终会调用到DexPathList中去:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String findLibrary(String libraryName) &#123;</span><br><span class="line">    String fileName = System.mapLibraryName(libraryName);</span><br><span class="line"></span><br><span class="line">    for (Element element : nativeLibraryPathElements) &#123;</span><br><span class="line">        String path = element.findNativeLibrary(fileName);</span><br><span class="line"></span><br><span class="line">        if (path != null) &#123;</span><br><span class="line">            return path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里我们就可以跟做Dex补丁一样的方式在这个Element数组前面插入补丁SO文件, 这样在findLibrary的时候就会优先返回插入的SO文件, 并执行doLoad加载插入的SO文件. 那插入的时机是什么时候? findLibrary的动作是在调用了System.loadLibrary后才执行的,所以插入补丁的动作应该是要放在System.loadLibrary之前才能确保加载的时候更新SO文件.</p>
<p>所以到最后其实System.loadLibrary()只是从特定的路径中去加载so库最终还是回调给Runtime.doLoad()，然后再调用Runtime.nativeLoad()这个native方法来执行的so加载。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>System.load()和System.loadLibrary()方法其实最终原理都一样，是通过调用Runtime.doLoad()最终Runtime.nativeLoad()调用到native层实现的so库加载，两者的区别在于查找so库的路径上。</p>
<p>关于热更新so库有两种实现</p>
<ol>
<li>和dex热更新一样，将补丁包的路径插入到DexPathList.nativeLibraryPathElements属性的最前面达到抢先加载的目的。这样的好处是开发者在加载so库的时候和往常一样直接System.loadLibrary(xxx)即可，缺点是需要考虑到Android系统不断在更新可能导致的api变动，毕竟这种方案是通过反射来修改的值。并且还需要考虑不同cpu架构插入不同so的问题，比如arm&#x2F;intel</li>
<li>使用System.load(xxx)去直接加载补丁包路径下的so，这种方式的好处在于你不需要去关心系统版本兼容和cpu架构等问题，缺点是开发者使用的时候需要改成System.load(xxx)这种加载方式，对于开发者不够透明。</li>
</ol>
<p>附上so热修复实现图：</p>
<img src="/2022/04/13/Android%E4%B8%A4%E7%A7%8Dso%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8F%8Aso%E7%83%AD%E4%BF%AE%E5%A4%8D/Tinker%E7%83%AD%E4%BF%AE%E5%A4%8Dso%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86%E5%9B%BE.png" class="" title="Tinker热修复so修复原理图">


<p>参考文章：<a href="https://blog.csdn.net/l2show/article/details/53573945">https://blog.csdn.net/l2show/article/details/53573945</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>android热修复小记</title>
    <url>/2022/04/13/android%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="认识热修复"><a href="#认识热修复" class="headerlink" title="认识热修复"></a>认识热修复</h2><p>由于Android应用程序需要手动安装apk包的特性，如果应用发布上线之后发现有bug只能再下载新包来修复。这样一来影响用户体验，二来是否下载新包的主动权在用户，所以开发者对bug无法把控。</p>
<h2 id="主流热修复方案"><a href="#主流热修复方案" class="headerlink" title="主流热修复方案"></a>主流热修复方案</h2><ol>
<li>腾讯Tinker</li>
<li>腾讯QZone</li>
<li>阿里sophix</li>
<li>美团Robust</li>
</ol>
<span id="more"></span>


<p>做一些简单对比</p>
<table>
<thead>
<tr>
<th>方案对比</th>
<th>Tinker</th>
<th>QZone</th>
<th>Sophix</th>
<th>Robust</th>
</tr>
</thead>
<tbody><tr>
<td>即时生效</td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>类替换(dex插队)</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>So修复</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>资源修复</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>版本支持</td>
<td>all</td>
<td>all</td>
<td>all</td>
<td>all</td>
</tr>
<tr>
<td>是否开源</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>收费情况</td>
<td>基础免费</td>
<td>免费</td>
<td>到达阈值收费</td>
<td>免费</td>
</tr>
</tbody></table>
<h3 id="Tinker"><a href="#Tinker" class="headerlink" title="Tinker"></a>Tinker</h3><p>腾讯自研的需要<strong>重启生效</strong>的java层实现的热修复方案</p>
<p>类修复是通过将原有的dex文件和修复之后的patch.dex文件进行dexdiff算法生成一个差分包下发给端，端收到差分包之后通过DexPatch算法再将差分包与端上的bug dex进行合并形成新的dex并替换掉dexElements数组来实现的。</p>
<p>资源修复过程构造一个新的AssetManager，并通过反射调用addAssetPath，把这个完 整的新资源包加入到AssetManager中。这样就得到了一个含有所有新资源的AssetManager。然后找到所有之前引用到原有AssetManager的地方通过反射将它们替换为这个新的AssetManager。</p>
<p>so的修复过程最简单，目前支持2种方式：</p>
<blockquote>
<ol>
<li>Hack方式：通过反射将补丁so插入到类加载器(这里我们拿到的就是BaseDexClassLoader)的DexPathList.nativeLibraryPathElements的数组最前面,这样做的好处是开发者只需像往常一样使用System.loadLibrary()来加载so，对开发者完全透明。缺点是是线上需要考虑系统版本兼容，毕竟用到了反射。</li>
<li>System.load()方式：可以加载任意路径下的so，好处是没有用到反射所以没有系统版本兼容问题，但是开发者使用时候加载so库的时候就需要调用System.load()方式而不是System.loadLibrary()。</li>
</ol>
</blockquote>
<blockquote>
<p>关于so的加载load逻辑可以参考文章：<a href="http://lianwenhong.top/2022/04/13/Android%E4%B8%A4%E7%A7%8Dso%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8F%8Aso%E7%83%AD%E4%BF%AE%E5%A4%8D/#more">http://lianwenhong.top/2022/04/13/Android两种so加载方式实现及so热修复/#more</a></p>
</blockquote>
<p>CustomTinker代码仓库：<a href="https://github.com/lianwenhong/CustomTinker.git">https://github.com/lianwenhong/CustomTinker.git</a><br>本工程模拟了dexElements插队实现类修复、AssetManager替换实现资源修复、未模拟so库修复，并且未做差分包，补丁校验等逻辑。仅用于学习。</p>
<h3 id="QZone"><a href="#QZone" class="headerlink" title="QZone"></a>QZone</h3><p>Multidex方案是基于ClassLoader的<strong>纯java实现</strong>的<strong>重启生效</strong>的热修复方案。</p>
<p>其实现原理与Tinker基本相同，不同点在于Tinker的补丁包是差分包而Multidex是全量包。并且它不支持so库修复。</p>
<h3 id="Robust"><a href="#Robust" class="headerlink" title="Robust"></a>Robust</h3><p>Robust是<strong>即时生效</strong>的<strong>Java层实现</strong>的热修复实现方案.</p>
<p>其参考了google的InstantRun方案。<a href="https://www.jb51.net/article/216170.htm#_label0">https://www.jb51.net/article/216170.htm#_label0</a></p>
<p>其主要设计思想就是字节码动态插桩(javassist)，在编译打包时都会通过javassist在程序每个方法里都插入这样一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (changeQuickRedirect != null) &#123;</span><br><span class="line">    //</span><br><span class="line">    return 修复的实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javassist原理：在class转dex的过程中会调用Transform，在该时机修改class对象，完成代码的注入。</p>
<p>当changeQuickRedirect不为空的时候，该方法就会命中<code>if(changeQuickRedirect != null)</code>，从而执行修复的实现代码。当为空的时候，则正常执行原逻辑。</p>
<p>在发生bug之后修复完bug方法时需要在方法上打上@Modify注解，这样在补丁包生成的时候该方法会被加入补丁描述类中。</p>
<p>为什么Robust能即时生效？</p>
<p>在补丁下载完成之后使用DexClassLoader将其加载进内存，然后反射将bug类对应的changeQuickRedirect复制为补丁对象。这样当程序执行到bug方法的时候就会命中changeQuickRedirect!&#x3D;null然后去走补丁中的修复之后的方法。定位bug类和bug方法就是通过之前打注解时自动将其加入补丁描述类中来实现的。</p>
<p>当前Robust支持的动态插桩技术有AspectJ、javassist两种。</p>
<p>javassist demo：<a href="https://github.com/lianwenhong/JavassistDemo.git">https://github.com/lianwenhong/JavassistDemo.git</a></p>
<p>AspectJ demo：<a href="https://github.com/lianwenhong/AspectJDemo.git">https://github.com/lianwenhong/AspectJDemo.git</a></p>
<h3 id="sophix"><a href="#sophix" class="headerlink" title="sophix"></a>sophix</h3><p>在native动态替换java层的方法，通过native层hook java层的代码。</p>
<p>没研究所以不做深入探究</p>
<p>思考：</p>
<p>四大组件的热修复？</p>
<p>资源热修复时会不会有冲突？（系统资源package id 0x01，应用资源package id 0x7f）</p>
<p>参考文章：<a href="https://www.jb51.net/article/216170.htm#_label0">https://www.jb51.net/article/216170.htm#_label0</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>gradle插件开发</title>
    <url>/2022/04/12/gradle%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<hr>
<h3 id="gradle插件开发的方式"><a href="#gradle插件开发的方式" class="headerlink" title="gradle插件开发的方式"></a>gradle插件开发的方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;com.android.application&#x27;</span><br><span class="line">apply plugin: &#x27;com.android.library&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Build script脚本</td>
<td>把插件写在build.gradle文件中，一般用于简单逻辑，作用范围为build.gradle文件</td>
</tr>
<tr>
<td>buildSrc目录</td>
<td>将插件源代码放在buildSrc&#x2F;src&#x2F;main&#x2F;中，作用范围为该项目</td>
</tr>
<tr>
<td>独立项目</td>
<td>一个独立的java项目&#x2F;模块,可将文件发布到仓库(jcenter)，使其他项目可以方便引入</td>
</tr>
</tbody></table>
<hr>
<p>任何可以运行在jvm中的语言都能用来开发gradle插件，比如groovy最终编译产物也是.class文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、aapt 打包资源文件 阶段</span><br><span class="line">2、aidl 转 java 文件 阶段</span><br><span class="line">3、Java 编译（Compilers）生成.class 文件 阶段</span><br><span class="line">4、dex（生成 dex 文件）阶段</span><br><span class="line">5、apkbuilder（生成未签名 apk）阶段</span><br><span class="line">6、Jarsigner（签名）阶段</span><br><span class="line">7、zipalign（对齐） 阶段</span><br><span class="line">[https://juejin.cn/post/6844903850453762055#heading-6](https://juejin.cn/post/6844903850453762055#heading-6)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>java类加载原理(ClassLoader工作原理)</title>
    <url>/2022/04/16/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-ClassLoader%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="什么是类加载"><a href="#什么是类加载" class="headerlink" title="什么是类加载"></a>什么是类加载</h2><p>在java开发中我们在.java文件中编写代码，之后通过javac指令编译成.class文件。当然如果是编写的Android应用后续又会经过dx工具将.class变为.dex文件(这不是本章重点)。</p>
<p>当javac编译成.class文件之后，它是以文件的形式存在的。比如MainActivity.java -&gt; javac -&gt; MainActivity.class。当我们程序中要使用MainActivity的时候，肯定要将这个文件加载到内存中来变成一个类对象这样才能去使用它。</p>
<span id="more"></span>

<img src="/2022/04/16/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-ClassLoader%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86.png" class="" title="类加载原理">

<p><strong>具体来说类加载就是将类的.class文件转为二进制数据读取到虚拟机内存的方法区中，当对象实例进行创建的时候会在堆内存中创建这个类的class对象，用来封装类在方法区中的数据结构。</strong></p>
<p><strong>类加载最终的产物就是这个类对应的Class对象，它封装了方法区中的类的数据结构，并向程序员提供了访问接口。</strong></p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>java的类加载分为3个步骤：</p>
<ol>
<li>装载（Load)：查找并加载类的二进制字节码(.class)文件。</li>
<li>链接（Link）</li>
<li>初始化（Initialize）：<strong>对类的静态变量、静态代码块执行初始化操作</strong>。</li>
</ol>
<p>对于链接这一过程分为3个子过程：</p>
<ol>
<li>验证：确保被加载的类的正确性</li>
<li>准备：为类的静态变量分配内存并初始化为默认值（这个初始化与初始化流程中的初始化不一样，这里是初始化为默认值，下一个流程中是初始化为指定值）</li>
<li>解析：把类中的符号引用转换为直接引用</li>
</ol>
<img src="/2022/04/16/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-ClassLoader%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" class="" title="java类加载过程">

<h4 id="思考1-为什么要有验证阶段？"><a href="#思考1-为什么要有验证阶段？" class="headerlink" title="思考1:为什么要有验证阶段？"></a>思考1:为什么要有验证阶段？</h4><p>由Java编译器编译生成的.class文件一定是符合JVM字节码格式的，由JVM加载并运行，为了避免人为写一个.class文件，用于恶意用途，就需要有验证，不符合格式的不让它继续运行，确保安全。</p>
<h4 id="思考2-链接中的准备过程和初始化过程有什么区别？"><a href="#思考2-链接中的准备过程和初始化过程有什么区别？" class="headerlink" title="思考2:链接中的准备过程和初始化过程有什么区别？"></a>思考2:链接中的准备过程和初始化过程有什么区别？</h4><p>准备过程是初始化为默认值，而初始化过程是将变量赋予正确的值。</p>
<h4 id="什么情况会导致类的初始化？"><a href="#什么情况会导致类的初始化？" class="headerlink" title="什么情况会导致类的初始化？"></a>什么情况会导致类的初始化？</h4><ul>
<li>创建类实例时（也就是new）</li>
<li>访问某个类或者接口的静态变量时（其实接口中的变量都是public final static的），或者是对该静态变量进行赋值时</li>
<li>调用类的静态方法</li>
<li>反射时（Class.forName(clzName)），这种情况下面会有说明</li>
<li>初始化一个类的子类(会首先初始化其父类)</li>
<li>JVM启动时表明的启动类，即文件名和类名相同的那个类</li>
</ul>
<h4 id="系统为我们提供了2种类加载方式："><a href="#系统为我们提供了2种类加载方式：" class="headerlink" title="系统为我们提供了2种类加载方式："></a>系统为我们提供了2种类加载方式：</h4><ul>
<li>Class.forName(clzName)</li>
<li>ClassLoader.loadClass(clzName)</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>类加载器是系统为我们提供的加载类的工具类，基类是ClassLoader，在Java中默认提供了：</p>
<ul>
<li>BootStrap:引导类加载器（启动类加载器）</li>
<li>ExtClassLoader:拓展类加载器</li>
<li>AppClassLoader：系统类加载器<br>除了这几个默认的之外我们也可以自定义一个类加载器去加载指定目录中的类。例如Android中定义了：</li>
<li>BootClassLoader:加载AndroidFramework层class文件（Android系统类）</li>
<li>BaseDexClassLoader(其子类有PathClassLoader、DexClassLoader用于加载指定目录虾的.dex文件中的class类)</li>
</ul>
<p><strong>归根结底其实类加载器就是一个加载类的工具，而不同类加载器的区别就是加载的类所处的目录不同而已</strong>，具体原因后续讲双亲委托机制时详述。</p>
<h4 id="思考3-类加载也是类，那类加载器被谁加载？"><a href="#思考3-类加载也是类，那类加载器被谁加载？" class="headerlink" title="思考3:类加载也是类，那类加载器被谁加载？"></a>思考3:类加载也是类，那类加载器被谁加载？</h4><p>BootStrap不是java类，它是c&#x2F;c++写的，是jvm内核的组成部分，它主要用于加载jvm运行必须的类。而ExtClassLoader和AppClassLoadeer是java类，他们是被BootStrap所加载。BootStrap是无法被java程序直接引用的。</p>
<h2 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h2><img src="/2022/04/16/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-ClassLoader%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6.jpg" class="" title="双亲委托机制">

<h4 id="类加载器的父子结构"><a href="#类加载器的父子结构" class="headerlink" title="类加载器的父子结构"></a>类加载器的父子结构</h4><p>jvm所有的类加载器都采用父子关系的树形结构进行组织（但是注意不是java语法上的父子关系，不是继承），它的原理是在实例化每个类加载器的时候都得为其指定一个父类加载器对象或者默认采用系统类加载器为其父类加载器。（类加载器中有一个parent属性，组织父子结构是通过为parent赋值来实现的）</p>
<p>每个类加载器都有自己的加载区域，它只能在自己的加载区域中寻找类。</p>
<h4 id="双亲委托机制工作原理"><a href="#双亲委托机制工作原理" class="headerlink" title="双亲委托机制工作原理"></a>双亲委托机制工作原理</h4><p><strong>当使用某个类加载器去加载一个类的时候，首先会委托给其父类去加载，当父类还有父类的时候会一层层向上委托直至没有父类。也就是说父类相对于子类来说具有绝对的优先加载权。因此，所有的类加载请求都应该被传递到顶层的引导类加载器中，如果父类加载器加载到类了那就直接返回该类，只有当父类加载器在它的加载区域中找不到所要加载的类时，才会把加载权再归还给子类去加载。</strong></p>
<p>这就是大名鼎鼎的双亲委托机制。</p>
<p>这么设计有什么好处呢？</p>
<ol>
<li>保证了同一个类不会被重复加载（不会被多个类加载器加载）</li>
<li>保证了类加载的安全性（例如假如有人自己创建了一个java.lang.String类也无法替换掉系统中的java.lang.String类，因为类加载会最终委托到父类加载器中，所以系统中的java.lang.String一定是先被找到的）</li>
</ol>
<p><strong>类加载器加载一个类的时候会首先从缓存中找，如果找到了就直接返回类，如果没找到才会继续向上委托。当成功加载到某个类的时候，会将得到的Class对象缓存起来用于下次加载这个类的时候直接返回。</strong><br>不信可以看看java ClassLoader类的loadClass()实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        // 找缓存</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        // 缓存中没有，则开始双亲委托机制</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    // 从父类加载器加载</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 没有父说明这个已经是Bootstrap</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 没有加载到，则在自己的区域中寻找类</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思考4-为什么静态元素和静态代码块在虚拟机种只会执行一次？"><a href="#思考4-为什么静态元素和静态代码块在虚拟机种只会执行一次？" class="headerlink" title="思考4:为什么静态元素和静态代码块在虚拟机种只会执行一次？"></a>思考4:为什么静态元素和静态代码块在虚拟机种只会执行一次？</h4><p>因为默认情况下赋值静态域的过程（初始化）或者是执行静态代码块是在类加载流程中执行的，而同一个类根据双亲委托机制只会被加载一次，如果第二次加载它会直接从缓存中取。当然如果你自己定义了一个类加载器再去手动加载它的话就另当别论了（假设加载类A，正常代码中类在AppClassLoader中被加载成功，此时你自定义一个类加载器并且它的加载区域中也有类A一样的class，并且把它的父类加载器设置成ExtClassLoader，那么肯定这时候通过自定义类加载器去加载那也能加载出一个类A，此时类A中的静态代码也会执行，<strong>但是，但是，但是这个但是很重要，但是此时加载出来的这俩类A不是同一个类</strong>）。</p>
<h4 id="届定2个类是不是同一个类对象"><a href="#届定2个类是不是同一个类对象" class="headerlink" title="届定2个类是不是同一个类对象"></a>届定2个类是不是同一个类对象</h4><p><strong>这也就是思考4中的但是，2个类对象是否是同一个取决于：类的全类名、加载它的类加载器以及类加载器的实例这三个条件，这三个条件中只要有一个不相同，加载后生成的Class对象就不是同一个，最终生成的类的实例的类型也不相同。</strong></p>
<p>所以即使是同一个类，用不同的类加载器去加载的话产生的对象也是不同的，不能进行互相赋值否则会出现类转换异常。</p>
<h4 id="Class-forName-clzName-的原理"><a href="#Class-forName-clzName-的原理" class="headerlink" title="Class.forName(clzName)的原理"></a>Class.forName(clzName)的原理</h4><p>直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Class&lt;?&gt; forName(String className)</span><br><span class="line">            throws ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    // 内部也是使用ClassLoader进行类加载，只是加载完成之后会自动执行初始化，同时forName0()的initialize参数决定</span><br><span class="line">    return forName0(className, true, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static native Class&lt;?&gt; forName0(String name, boolean initialize,</span><br><span class="line">                                    ClassLoader loader,</span><br><span class="line">                                    Class&lt;?&gt; caller)</span><br><span class="line">throws ClassNotFoundException;</span><br></pre></td></tr></table></figure>
<p>所以Class.forName(clzName)本质上也是通过ClassLoader.loadClass(clzName)进行类加载，只是它会执行初始化，而直接通过ClassLoader.loadClass(clzName) 加载的类只有达到上面说的几个条件才会执行初始化流程。</p>
<p>下一章我们讲一下Android中的类加载器：<a href="http://lianwenhong.top/2022/04/14/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-App%E7%9A%84ClassLoader/#more">Android源码解析-App的ClassLoader</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-装饰者模式</title>
    <url>/2022/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>装饰者模式（Decorator Pattern）也称为包装模式（Wrapper Pattern），以透明动态的方式来动态扩展对象的功能，也是继承关系的一种代替方案。</p>
<img src="/2022/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" class="" title="装饰者设计模式">

<span id="more"></span>

<ul>
<li>Component：抽象组件（可以是抽象类或者接口），被装饰的原始对象</li>
<li>ConcreteComponent：具体实现类，被装饰的具体对象</li>
<li>Decorator：抽象装饰者，职责就是为了装饰我们的组件对象，内部一定要有一个指向组件对象的引用</li>
<li>ConcreteDecoratorA：装饰者具体实现类，只对抽象装饰者做出具体实现</li>
<li>ConcreteDecoratorB：同上</li>
</ul>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>人定义为抽象类，有一个抽象方法eat()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Person &#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着创建一个NormalPerson类继承Person，对eat()方法有了具体实现；NormalPerson类就是我们需要装饰的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NormalPerson extends Person &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义一个PersonFood类来表示装饰者的抽象类，保持了一个对Person的引用，可以方便调用具体被装饰的对象方法，这样就可以方便的对其进行扩展功能，并且不改变原类的层次结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PersonFood extends Person &#123;</span><br><span class="line">    private Person person;</span><br><span class="line"></span><br><span class="line">    public PersonFood(Person person)&#123;</span><br><span class="line">        this.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        person.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着就是具体的装饰类了，这两个类没有本质上的区别，都是为了扩展NormalPerson类，不修改原有类的方法和结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ExpensiveFood extends PersonFood &#123;</span><br><span class="line">    public ExpensiveFood(Person person) &#123;</span><br><span class="line">        super(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        super.eat();</span><br><span class="line">        eatSteak();</span><br><span class="line">        drinkRedWine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eatSteak()&#123;</span><br><span class="line">        System.out.println(&quot;吃牛排&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void drinkRedWine()&#123;</span><br><span class="line">        System.out.println(&quot;喝拉菲&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CheapFood extends PersonFood &#123;</span><br><span class="line">    public CheapFood(Person person) &#123;</span><br><span class="line">        super(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        super.eat();</span><br><span class="line">        eatNoodles();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eatNoodles()&#123;</span><br><span class="line">        System.out.println(&quot;吃面条&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用装饰者代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Person person = new NormalPerson();</span><br><span class="line"></span><br><span class="line">        PersonFood cheapFood = new CheapFood(person);</span><br><span class="line">        cheapFood.eat();</span><br><span class="line"></span><br><span class="line">        PersonFood expensiveFood = new ExpensiveFood(person);</span><br><span class="line">        expensiveFood.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="android中的装饰者模式"><a href="#android中的装饰者模式" class="headerlink" title="android中的装饰者模式"></a>android中的装饰者模式</h3><p>在android中，Context就是典型的装饰者模式，Context是抽象类，真实的功能实现实在ComtextImpl中完成，ComtextImpl就是Context的实现类；然后看源码会发现Activity是继承于ContextThemeWrapper而不是直接继承于Context。其中ContextThemeWrapper继承于ContextWrapper，而ContextWrapper继承于Context。这里就可以看出来一点装饰者模式了，其中装饰者所调用的方法就是startActivity方法，在ContextWrapper中会发现startActivity方法调用了ComtextImpl中对应的方法，实质上ContextWrapper中所有方法都仅仅是调用了ComtextImpl中的方法，这就和装饰者模式基本就对应上了。<br>想具体了解Context机制可以看我另一篇文章：<a href="https://lianwenhong.top/2022/03/29/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-Context%E8%A7%A3%E6%9E%90/#more">Android源码小记-Context解析</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>装饰者模式与继承关系的目的都是要扩展对象的功能，但是装饰者模式可以提供比继承更多的灵活性。</li>
<li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</li>
<li>装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</li>
<li>装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</li>
</ul>
<h3 id="装饰者模式与代理模式对比"><a href="#装饰者模式与代理模式对比" class="headerlink" title="装饰者模式与代理模式对比"></a>装饰者模式与代理模式对比</h3><p>其实装饰者模式和代理模式很像，但是两者的目的不尽相同。装饰者模式是以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；而代理模式则是一个给对象提供一个代理对象，并由代理对象来控制对原有对象的引用。<br>装饰者模式为本装饰的对象进行功能扩展；代理模式对代理对象进行控制，但不做功能扩展</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>linux名词解释</title>
    <url>/2022/04/18/linux%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p>对linux操作系统中的一些名词或者方法做简单记录，旨在为后续Android学习提供前提铺垫。例如学习binder时，学习多线程时。</p>
<blockquote>
<p>在Linux中，一切皆对象。也就是说皆可以通过一套统一的接口来控制。</p>
</blockquote>
<span id="more"></span>

<h3 id="什么是设备节点："><a href="#什么是设备节点：" class="headerlink" title="什么是设备节点："></a>什么是设备节点：</h3><p>Linux系统，除了网络接口卡(网卡)之外，其他的所有设备都被视为文件，<strong>并统一在&#x2F;dev下有对应的所谓节点文件</strong>。</p>
<p>拓展：</p>
<p>&#x2F;dev目录下的文件节点被称为<strong>特殊设备节点</strong>，要么是<strong>字符设备</strong>节点，要么是<strong>块设备</strong>节点。</p>
<ul>
<li>字符设备：如键盘。提供连续数据流（字节或字符），应用可顺序读取，但不支持随机存取。</li>
<li>块设备：如硬盘等存储设备。应用可随机存取设备上的任意位置的数据。</li>
</ul>
<p>所以2者的最大区别在于是否能随机存取设备上任意位置的数据。</p>
<p><strong>而所谓的节点指的是一个操作入口，我们可以通过这样的入口来达到对设备的读写等操作。</strong>之所以要在&#x2F;dev下搞那么多所谓“入口”是因为Linux系统提供<strong>虚拟文件系统</strong>，它可以帮助我们使用一套一致的函数接口(如open()、read()、write()、close()…)来操作各种不同的设备，这样大大降低了应用程序访问Linux设备的复杂度。</p>
<h3 id="虚拟设备"><a href="#虚拟设备" class="headerlink" title="虚拟设备"></a>虚拟设备</h3><p>个人理解虚拟设备是系统为用户提供了某一块内存将需要虚拟的设备程序放在这个位置，然后创建出针对此虚拟设备的节点。当用户操作这个虚拟设备节点时就是对虚拟设备程序进行操作，最终的操作位置也就是系统提供的那一块内存。</p>
<h3 id="什么是驱动"><a href="#什么是驱动" class="headerlink" title="什么是驱动"></a>什么是驱动</h3><p>驱动程序一般指的是<strong>设备驱动程序，是一种可以使计算机和设备进行相互通信的特殊程序</strong>。相当于硬件的接口，操作系统只有通过这个接口才能控制硬件设备的工作。假设某设备的驱动程序未能正确安装则设备便不能正常工作。因此，驱动程序是硬件和系统之间的桥梁。</p>
<h3 id="Android中的Binder"><a href="#Android中的Binder" class="headerlink" title="Android中的Binder"></a>Android中的Binder</h3><ul>
<li>机制：Binder是一种IPC（进程间通信）机制</li>
<li>驱动：Binder是一个虚拟物理设备的驱动</li>
<li>应用层：Binder是一个能发起进程间通信的java类</li>
</ul>
<p><strong>并不存在真实的Binder物理设备，Binder所驱动的是&#x2F;dev&#x2F;binder这个虚拟设备。</strong></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-代理模式</title>
    <url>/2022/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>java的代理模式是很常见的一种设计模式，记录一下我的理解。<a href="https://github.com/HomerLian/DesignMode/tree/master/ProxyMode">源码</a></p>
<p>代理模式主要的思想是将委托类（被代理类）和真正使用委托类逻辑的类做一个解耦。<br>主要有2个好处：<br>    1.保护目标对象：被代理类无需对外公开，外部通信仅通过代理类进行沟通<br>    2.增强目标对象：可以在不改动被代理类的情况下对所需功能做增强，外部调用方对此也无感知<br>不考虑很多根据业务场景的分类（比如远程代理、虚拟代理、保护代理等等等…），我们只考虑编码实现方案那就分为2种：</p>
<ol>
<li>静态代理</li>
<li>动态代理</li>
</ol>
<p>对于真正使用代理的场景有很多，例如Android中Resource与ResourceImpl、Retrofit中获取api接口、Collections.synchronizedList实现线程安全数组等场景。这里暂时不展开说明，如有兴趣再行记录。</p>
<p>举个生活中的例子：</p>
<p>假设你爸让你帮他买张机票此时你想在你爸不知情的情况下赚点零花钱。你上网查携程上的票价是1000元，你跟你爸说这张票1500，这样你就从中赚取了500零花钱。</p>
<span id="more"></span>

<p>这就是一个典型的代理模式。其中的角色分别是：</p>
<p>携程         –&gt; 被代理类<br>你         –&gt; 代理类<br>你爸         –&gt; 用户，享受服务的一方<br>先试写一下对于这件事我们如何编码，我们使用代理模式是为了让结构更灵活更清晰，所以此时我们的实现思路是这样：</p>
<ol>
<li>将买票这个行为抽象出来，不管是哪个角色，最终想要的结果都是买票</li>
<li>找一个真正买票的地方实现买票服务，也就是创建一个被代理类</li>
<li>你去把票买了然后把票给你爸，也就是对外提供一个代理类，用户通过这个代理类获得服务。此时这个代理类就是你。</li>
</ol>
<p>不管是动态代理还是静态代理，都得实现这几个步骤。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>1.我们要做的是买票，那就把它抽象出一个接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抽象出来的买票服务接口，大家想做的事都是买票这么个事</span><br><span class="line"> */</span><br><span class="line">public interface TicketServer &#123;</span><br><span class="line">    float buyTicket(String dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.我从携程去买，那就创建一个携程类，然后去实现买票服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 被代理类</span><br><span class="line"> * 真正提供服务的地方，干实事的</span><br><span class="line"> */</span><br><span class="line">public class XC implements TicketServer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public float buyTicket(String dest) &#123;</span><br><span class="line">        System.out.println(&quot;出票成功 机票 To &quot; + dest + &quot; No:&quot; + (int) (Math.random() * 1000));</span><br><span class="line">        return 1000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.创建一个实体对你爸提供服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Son implements TicketServer &#123;</span><br><span class="line"></span><br><span class="line">    TicketServer server = new XC();</span><br><span class="line"></span><br><span class="line">    public Son() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public float buyTicket(String dest) &#123;</span><br><span class="line">        float fares = server.buyTicket(dest);</span><br><span class="line">        fares += 500;</span><br><span class="line">        return fares;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里你老爸可以通过Son也就是你买到票了，你就是携程的代理，被代理类（目标类）就是携程。</p>
<p>老爸这个类可以这样子指使你：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Father &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      </span><br><span class="line">        TicketServer son = new XC(); // java多态的体现，你爸是想要买个票，所以让你买也行，让你姐去买也可以</span><br><span class="line">        System.out.println(&quot;票价为：&quot; + son.buyTicket(&quot;北京&quot;) + &quot;元&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此静态代理结束，此时你如果发现携程买的票比较贵你可以自己换成去哪儿，换成12306都是OK的，你爸并不知道。</p>
<p>但是有个问题，如果你爸知道你赚他钱就让你姐去买，那你姐是不是也要和Son这个代理类一样去创建一个Daughter类，然后实现和你一样的功能？这样的话如果你爸再想找别人别人还得创建这个类。明显静态代理的方式虽然能达到我们所要的保护目标和增强目标的2个目的，但是略显冗余了。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>用动态代理实现也是一样的步骤，只不过Son类不需要我们再手动创建，而是调用Proxy的API让系统通过反射替我们动态生成。</p>
<p>你老爸这样调用你去买票：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Father &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">      </span><br><span class="line">        TicketServer son = (TicketServer) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;TicketServer.class&#125;, new InvocationHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                TicketServer xc = new XC();</span><br><span class="line">                float fares = (float) method.invoke(xc, args);</span><br><span class="line">                return fares + 500;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;票价为：&quot; + son.buyTicket(&quot;北京&quot;) + &quot;元&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里静态代理和动态代理的写法都写完了。但是为了结构更清晰，我们把对老爸提供的东西做一个抽取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TicketUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态代理方式</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static TicketServer staticTicket() &#123;</span><br><span class="line">        return new Son();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 动态代理方式</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static TicketServer dynamicTicket() &#123;</span><br><span class="line">        TicketServer server = new XC();</span><br><span class="line"></span><br><span class="line">        return (TicketServer) Proxy.newProxyInstance(server.getClass().getClassLoader(), server.getClass().getInterfaces(), new InvocationHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                float fares = (float) method.invoke(server, args);</span><br><span class="line">                fares += 500;</span><br><span class="line">                return fares;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你爸最后调用你就很简单了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Father &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 这段代码可以在ide中输出用户为我们生成的临时类</span><br><span class="line">        System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 静态代理方式</span><br><span class="line">         */</span><br><span class="line">//        TicketServer son = TicketUtils.staticTicket();</span><br><span class="line">//        System.out.println(&quot;票价为：&quot; + son.buyTicket(&quot;北京&quot;) + &quot;元&quot;);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 动态代理方式</span><br><span class="line">         */</span><br><span class="line">        TicketServer son = TicketUtils.dynamicTicket();</span><br><span class="line">        System.out.println(&quot;票价为：&quot; + son.buyTicket(&quot;北京&quot;) + &quot;元&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是最最最基础的讲解了。</p>
<p>接下来我们来看看Proxy这个类如何帮我们完成代理类的创建工作。</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// loader：类加载器，用于在动态生成类之后将类加载进来</span><br><span class="line">// interfaces：所需要实现的接口，也就是我们抽象出来的公共接口，上例中的TicketServer</span><br><span class="line">// h：执行handler</span><br><span class="line">public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure>
<p>首先我们看一下系统为我们生成的类长什么样子这样才能更好的理解它生成的类是如何为我们工作的。<br>通过<code> System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</code><br>这段代码会将动态生成的类保留下来，我们可以在ide中看到类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 它实现了TicketServer接口，和我们自己创建代理类时一样</span><br><span class="line">// 它继承了Proxy</span><br><span class="line">public final class $Proxy0 extends Proxy implements TicketServer &#123;</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public final float buyTicket(String var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Float)super.h.invoke(this, m3, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m3 = Class.forName(&quot;com.lianwenhong.proxydemo.TicketServer&quot;).getMethod(&quot;buyTicket&quot;, Class.forName(&quot;java.lang.String&quot;));</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在newProxyInstance（）方法中其实会通过反射调用构造方法，然后将我们传入的h传进来，所以这时候调用到$Proxy0的构造进而调用到父类的构造：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Proxy(InvocationHandler h) &#123;</span><br><span class="line">  	Objects.requireNonNull(h);</span><br><span class="line">  	this.h = h; // 先记住将h赋值给本地对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们拿到代理类调用buyTicket()时其内部是<code>return (Float)super.h.invoke(this, m3, new Object[]&#123;var1&#125;);</code>是调用h的invoke()方法，所以这时候也就是调用我们<code>Proxy.newProxyInstance()</code>时传入的InvocationHandler对象。而m3是在静态代码块中赋值的也就是buyTicket()方法。所以到这里就可以理解了为什么最终我们要在InvocationHandler-&gt;invoke()方法中做买票的逻辑了。</p>
<p>Proxy.newProxyInstance() -&gt; InvocationHandler.invoke()的回调过程已然形成闭环。</p>
<p>接下来我们看下Proxy.newProxyInstance()是如何返回代理类实例的（也就是$Proxy0）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException&#123;</span><br><span class="line">		... 做一些前期判空和Access权限校验工作</span><br><span class="line">	</span><br><span class="line">	 // 返回代理类$Proxy0的Class对象（内部逻辑是缓存中有直接返回，否则通过ProxyClassFactory创建一个）</span><br><span class="line">     Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">		...</span><br><span class="line">     try &#123;</span><br><span class="line">		...</span><br><span class="line">		 // 通过反射找到构造方法</span><br><span class="line">         final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">         final InvocationHandler ih = h;</span><br><span class="line">         if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                 public Void run() &#123;</span><br><span class="line">                     // 设置构造方法可访问</span><br><span class="line">                     cons.setAccessible(true);</span><br><span class="line">                     return null;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">         // 通过反射new出$Proxy0对象并返回</span><br><span class="line">         return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">     &#125; catch (...)&#123;</span><br><span class="line">     	...</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>所以具体创建代理Class类的方法是在getProxyClass0()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    if (interfaces.length &gt; 65535) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   // proxyClassCache是一个缓存结构WeakCache，其使用方式类似map以所要代理的接口interface为key，以ProxyClassFactory为value，如果不存在该key则会通过ProxyClassFactory创建出一个代理类。</span><br><span class="line">    return proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首次进入代理类为空，是通过ProxyClassFactory.apply()方法生成的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">     // 遍历interface，找出代理类所应该继承的所有接口</span><br><span class="line">     for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">         Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">         try &#123;</span><br><span class="line">             // 通过反射将接口Class对象加载进来，内部是使用了classloader类加载机制</span><br><span class="line">             interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">         &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">         &#125;</span><br><span class="line">         if (interfaceClass != intf) &#123;</span><br><span class="line">             throw new IllegalArgumentException(</span><br><span class="line">                 intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      </span><br><span class="line">         if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">         	 // 如果传入的不是接口类型，则会在此处抛出IllegalArgumentException异常提示传入的不是一个接口类型</span><br><span class="line">             throw new IllegalArgumentException(</span><br><span class="line">                 interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      </span><br><span class="line">         if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class="line">             throw new IllegalArgumentException(</span><br><span class="line">                 &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     String proxyPkg = null;     // package to define proxy class in</span><br><span class="line">     int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">  </span><br><span class="line">     for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">         int flags = intf.getModifiers();</span><br><span class="line">         if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">             accessFlags = Modifier.FINAL;</span><br><span class="line">             String name = intf.getName();</span><br><span class="line">             int n = name.lastIndexOf(&#x27;.&#x27;);</span><br><span class="line">             String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">             if (proxyPkg == null) &#123;</span><br><span class="line">                 proxyPkg = pkg;</span><br><span class="line">             &#125; else if (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                 throw new IllegalArgumentException(</span><br><span class="line">                     &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (proxyPkg == null) &#123;</span><br><span class="line">         // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">         // 合成全类名，PROXY_PACKAGE其实是com.sun.proxy</span><br><span class="line">         proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     /*</span><br><span class="line">      * Choose a name for the proxy class to generate.</span><br><span class="line">      */</span><br><span class="line">     long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">      //  生成文件名，例如$Proxy0，根据不同的需求创建出多个的话根据后面的数字区分</span><br><span class="line">     String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">    // 通过ProxyGenerator工具类根据一定规则编写内部逻辑代码并生成类字节数组，其实是一套通用写法</span><br><span class="line">     byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">         proxyName, interfaces, accessFlags);</span><br><span class="line">     try &#123;</span><br><span class="line">         // 调用defineClass0生成真正的class文件并加载进内存（其内部就是调用类加载器生成class文件并加载）</span><br><span class="line">         return defineClass0(loader, proxyName,</span><br><span class="line">                             proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">     &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">         throw new IllegalArgumentException(e.toString());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们只要了解一下就行。</p>
<p><strong>newProxyInstance()大致原理就是：</strong></p>
<ol>
<li><p>根据传入的接口信息去缓存中获取或创建代理类Class对象。<br><strong>a. 缓存中存在代理类class对象则直接返回</strong></p>
<p><strong>b. 不存在则根据传入的interface接口通过一系列拼接类名、定义修饰符等操作然后调用ProxyGenerator.generateProxyClass()方法生成字节数组，然后将该字节数组交给ClassLoader底层的defineClass0（native方法）生成一个新的class文件并返回。</strong></p>
</li>
<li><p>利用反射机制获取到代理类对象的构造方法并执行生成代理类对象并返回</p>
</li>
</ol>
<p><strong>总结：</strong> 就是根据传入的接口通过反射动态创建一个代理类对象，该对象继承于Proxy并实现代理模式中的接口，然后将创建代理类过程中传入的InvocationHandler对象保存起来，当调用目标方法时是调用保存起来的InvocationHandler对象的invoke()方法回调给使用者。</p>
<p><strong>By the way:</strong><br>源码中的ProxyClassFactory中是使用<code>sun.misc.ProxyGenerator</code> 类来生class的。生成Class文件的方法不止这一个，我们也可以用 Javassist 技术动态生成class。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>动态代理也可以用于实现AOP切面编程。例如方法的埋点，耗时统计等等。只需在invoke内部实现AOP的业务逻辑即可。这样JVM动态生成代理类时就包含了所需的AOP逻辑。</p>
<p>参考文章：<br><a href="https://www.jianshu.com/p/5c8a9a334034">JVM的Proxy.newProxyInstance原理分析</a><br><a href="https://zhuanlan.zhihu.com/p/349659128">自己实现Java 动态代理 Proxy</a><br><a href="https://blog.csdn.net/time_poster/article/details/116140160">Proxy.newProxyInstance源码探究</a><br><a href="https://www.bilibili.com/video/BV1nr4y1y7eZ?p=3&spm_id_from=pageDriver">JDK动态代理底层原理&amp;为什么需要接口?</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Android中多线程通信：Handler的理解</title>
    <url>/2022/03/25/Android%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9AHandler%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>Android中Handler在我理解主要是为了解决线程间通信。</p>
<h2 id="Handler机制组成"><a href="#Handler机制组成" class="headerlink" title="Handler机制组成"></a>Handler机制组成</h2><pre><code>使用Android的Handler机制主要要了解几个类：
</code></pre>
<ul>
<li><strong>Looper</strong>：<br>  一个线程对应一个或者0个Looper，主线程在ActivityThread的时候会默认创建一个Looper，非主线程中需要先通过Looper.prepare()创建，并且通过Looper.loop()开启。</li>
<li><strong>Message</strong>：<br>  线程间通信的消息载体，Handler利用Message来携带信息给另一个线程，内部包含一个叫sPool的单向链表结构消息缓存池，使用享元模式实现消息的复用防止内存抖动。</li>
<li><strong>MessageQueue</strong>：<br>  消息队列，与Looper一一对应，每个Looper中维护一个消息队列，此消息队列是一个时间优先级队列，内部是一个单向链表</li>
<li><strong>Handler</strong>：<br>  有点像是一个工厂里的机器人，不断从这个线程中发送Message或者是Runnable给另一个线程，并放入MessageQueue中</li>
</ul>
<p>所以以上是Handler机制的主要4个要素，每个要素之间的关系很清晰明了：<strong>Handler为生产者，Looper为消费者，MessageQueue为容器，而Message为具体的消息载体。</strong></p>
<span id="more"></span>

<h2 id="Handler使用"><a href="#Handler使用" class="headerlink" title="Handler使用"></a>Handler使用</h2><p>如果对Handler还不够熟悉可以看下这2篇文章先熟悉Handler使用：<br><a href="https://blog.csdn.net/androidsj/article/details/79816866">Handler实现子线程与子线程、主线程之间通信</a><br><a href="https://blog.csdn.net/qq_21556263/article/details/82759061">Handler完全解读——Handler的使用</a></p>
<h2 id="Handler运行原理"><a href="#Handler运行原理" class="headerlink" title="Handler运行原理"></a>Handler运行原理</h2><p>要深入理解Handler机制我们首先从几个着力点出发<br><strong>1.Handler怎么创建的<br>2.Handler调用sendMessage的时候发生了什么<br>3.Looper与线程是什么关系<br>4.Looper.prepare(),Looper.loop()做了些什么事情，为什么如果不执行prepare会报错等。<br>5.Handler是如何保证多个线程跟同一个线程进行通信时的准确性</strong></p>
<p>首先从创建一个Handler的的时候构造方法来看，所有构造方法总共有3种参数：<br>Callback：是一个只有handleMessage的接口，是事件处理的回调，可有可无，后面说<br>async：是同步消息还是异步消息，这与同步屏障有关，后面说，一般我们都是发的同步消息<br>Looper：该handler对象所要处理的线程对应的Looper对象，也就是说该Handler的执行都是在looper对应的线程中的</p>
<p>线程分为有消息队列和没有消息队列两种，没有消息队列则线程启动完成执行完操作就结束了 ，而有消息循环队列的时候，线程可以通过循环调度消息队列的方式来执行消息队列中的每一个任务，Android中使用Handler进行线程间通信时，Handler必须指定要通信线程所持有的Looper。<br>准确的说，其实是Handler需要做的事情是向要通信的线程所持有的消息队列中加入任务。   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Handler</span>&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//这里就是在子线程使用Handler的时候常遇到的异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你在Handler构造函数中没有指定Looper，那么调用Looper.myLooper()句柄来获取当前线程所对应的Looper，如果这时该线程还未初始化Looper对象，这时就会抛出一个异常， 这就是为什么在子线程时我们创建Handler前需要先调用Looper.prepare()方法的原因。<br>跟进Looper.myLooper()看一下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用Looper.myLooper我们看到其实是从sThreadLocal变量中get一个Looper对象，这样就确保了每个线程都对应了一个Looper，而每个Looper中拥有一个MessageQueue，这样就实现了线程-Looper-MessageQueue这3个部分一一对应的关系。如果对ThreadLocal不熟悉的话可以百度一下，或者等我有空我会更新一篇文章。</p>
<p>既然已经知道了线程-Looper-MessageQueue是一一对应的关系，想与某一线程进行通信只需将消息加入到该线程对应的MessageQueue中就能实现，那么我们看下Looper与MessageQueue做了些什么东西。</p>
<p>Looper.prepare():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">	prepare(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//quitAllowed表示该Looper所对应的消息队列是否可退出，具体的退出在Looper.quit()方法里</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">//表示该线程对应的Looper对象已存在，不能重复调用prepare()，否则就抛异常</span></span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以调用prepare()时是创建Looper实例，看下构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">	<span class="comment">//创建消息队列</span></span><br><span class="line">	mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">	mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以到这里，线程持有了一个Looper对象，Looper对象中持有了一个MessageQueue队列，一对一。<br>紧接着消息队列有了，需要让队列开始运作起来，就好比流水线一样，需要轮训这个队列取出消息来执行。而消息的添加是在Handler的sendMessage中我们一会儿再说<br>Looper.loop():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">	<span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">//在这里又判断了一下Looper.prepare()是否调用。</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">	<span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">	Binder.clearCallingIdentity();</span><br><span class="line">	<span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//此处开启一个无限循环，只有当msg == null时才会退出，</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">//调用MessageQueue内部的next()方法，此方法在消息队列为空的时候会执行线程阻塞，阻塞原理是使用Linux的epoll实现的</span></span><br><span class="line">		<span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">		<span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">		    <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">		    <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		...	</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//调用handler的dispatchMessage方法来处理消息，最后真正执行到handler的handleMessage()</span></span><br><span class="line">			msg.target.dispatchMessage(msg);</span><br><span class="line">		    ...</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">		    <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">		        observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">throw</span> exception;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		    ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">		    <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">		        Trace.traceEnd(traceTag);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">//使用享元模式来将该Message对象还原并放回消息池中以便将来复用减少内存抖动，具体实现在Message中</span></span><br><span class="line">		msg.recycleUnchecked();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>省略部分与主流程关系不大的代码，我们看下注释中的各个方法</p>
<p>首先在loop()时也会做一遍prepare()的调用校验，因为在开启消息队列之前必然是要确保Looper和消息队列已存在，否则一切都是空谈。</p>
<p>紧接这开启了一个无限循环，只有在消息为空的时候才把该循环退出表示该线程的MessageQueue已经不再需要。</p>
<p>在queue.next();方法中，如果取不到消息的话，会执行Linux的epoll方法来阻塞住当前线程，以便有消息被加入到消息队列时能获取到并执行的同时，在没消息的时候又不会让线程一直在做无用的轮训消耗性能。<br>可能我们会不理解的是，上面明明说没有消息的时候会退出for循环这里又说会阻塞，这是怎么回事？<br>其实是这样的，首先我们要确保一个线程的MQ一直在等着消息进来从而执行消息，而如果直接在取不到的时候直接结束消息队列的循环显然是不符合的。那么底层的实现就是首先先把线程阻塞住等待消息加入，而什么时候会唤醒线程呢，1个是当消息被加入到MQ的时候，一个是当调用了quit()来表示此轮训机制已不再需要的时候。所以for循环里的msg &#x3D;&#x3D; null这个判断其实针对的就是第2种情况。</p>
<p>如果成功取到了一个消息，那么就去执行它，就调用dispatchMessage()方法最终会调用到Handler的handleMessage()方法。<br>这里思考一下，通过handler调用sendMessage()，而从MQ中取出消息的时候，怎么能定位到发送消息的handler中去执行处理呢？其实这里就是通过Message这个载体把发送消息的Handler保存起来，也就是这个target！！！</p>
<p>MessageQueue.next()是如何取消息的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">		<span class="comment">//Linux的epoll实现阻塞的入口</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">		<span class="comment">//通过加锁保证多线程出队的正确性，因为一个Handler可以处理多个线程中的消息</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="comment">//表示这是个同步屏障，同步屏障与普通消息的区别是同步屏障的target是null</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                    <span class="comment">//寻找异步消息来返回</span></span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    <span class="comment">//如果这个消息的执行时间还没到，那就不做其他操作，因为这里是无限循环，所以会一直轮训直到时间到</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="comment">//取出符合条件的第一个消息返回</span></span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上在MQ中实现了消息的获取。</p>
<p>看完Looper以及取消息的实现，我们再来看下我们sendMessage()的时候内部做了些什么处理，怎么与Looper中的逻辑关联上的</p>
<p>当调用sendMessage之后，其实最终是调用到以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//upTimeMillis是参数是延迟执行的时间，例如当postDelayed的时候可以指定一个延迟时间一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">	<span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">	 <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">	     <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">	             <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">	     Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">	     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">//此时的uptimeMillis=SystemClock.uptimeMillis() + delayMillis</span></span><br><span class="line">	 <span class="comment">//意思是当前系统时间加上开发者传入的所需要延迟的时间</span></span><br><span class="line">	 <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着调用到MQ中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">    <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line">	<span class="comment">//此处指定该消息为异步消息，异步消息一会儿讲同步屏障的时候再说</span></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入MQ中的入队操作</span></span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MessageQueue中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">	<span class="comment">//如果没有指定target则不入队抛出异常，其实这里一个是为了后续能定位出需要处理消息的Handler，也为了与同步屏障消息区分开了（这个后说）</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果这个消息已经在入队等待处理往后的流程，那这个消息不能被重复使用直到该消息执行完毕</span></span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//因为同一个线程可以与无数个线程进行通信，所以在入队和出队都必须保证同步</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    	<span class="comment">//如果正在执行退出操作（也就是Looper.quit()），则不再入队新消息</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//1.如果队列中还没有消息，则添加队列头并唤醒线程去执行轮训那一套流程取出消息并执行</span></span><br><span class="line">        <span class="comment">//2.消息需要立刻执行，则也是唤醒线程执行消息</span></span><br><span class="line">        <span class="comment">//3.消息需要执行的时间点比队头消息时间小，那么表示这个消息需要先执行，也执行唤醒执行消息</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            <span class="comment">// 除非队头消息是同步屏障，并且消息是队列中最早的异步消息。否则都不唤醒线程</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                	<span class="comment">//这一段的操作在此处退出，目的是将添加进来的消息按时间先后顺序插入到合适的位置。</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里屏蔽掉同步屏障消息，也就是说加入一个同步屏障时，不需要唤醒线程</span></span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将消息入队到链表中合适位置</span></span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">        	<span class="comment">//唤醒线程</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Handler小结"><a href="#Handler小结" class="headerlink" title="Handler小结"></a>Handler小结</h2><p>看到这里我们的整个流程已经清晰了。<br><strong>1.Looper.prepare()创建消息队列并将线程–Looper–MessageQueue进行一一对应</strong></p>
<p><strong>2.Looper.loop()开始消息队列循环并通过一套阻塞机制来实现队列的等待以及取消息。最终调用调用MQ.next()，并在无消息时阻塞线程</strong></p>
<p><strong>3.通过Handler.sendMessageAtTime()方法发送一个消息，最终调用到MQ.enqueueMessage()方法来将消息入队，并在入队成功唤醒线程</strong></p>
<p><strong>4.Looper.quit()方法实现退出Handler机制，通过唤醒线程并且往下执行让msg &#x3D;&#x3D; null来实现让Looper.loop()中的无限循环退出。</strong></p>
<p>看完整个流程，开头的5个疑问已全部解决。</p>
<h2 id="深入思考："><a href="#深入思考：" class="headerlink" title="深入思考："></a>深入思考：</h2><p><strong>1.在主线程中我们没有手动调用过Looper.prepare()方法，却也没见有什么问题?<br>2.什么是同步消息什么是异步消息？<br>3.什么是同步屏障，同步屏障的使用场景是什么？<br>4.我们postDelayed()指定延迟时间时，一定会在指定的延迟时间之后执行吗？</strong><br>问题1:<br>    原因在于那是因为在主线程中Google已经帮我们做了这些操作，不信看看整个Android应用程序的主入口：ActivityThread的main()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install selective syscall interception</span></span><br><span class="line">    AndroidOs.install();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">configDir</span> <span class="operator">=</span> Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line">	<span class="comment">//执行Looper初始化</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line">    <span class="comment">// It will be in the format &quot;seq=114&quot;</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startSeq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] != <span class="literal">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                startSeq = Long.parseLong(</span><br><span class="line">                        args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">LogPrinter</span>(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="comment">//开启Looper循环</span></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题2:<br>    在Handler机制中区分同步消息或者异步消息其实主要是根据Message.setAsynchronous()方法来设置的，设置true为异步消息，false为同步消息，默认我们创建的都是同步消息。<br>    如何使用Handler发送同步消息或者异步消息，通过Handler的构造函数可以指定async为true来实现，默认是false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    <span class="comment">//指定向该handler中发送的消息类型</span></span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题3:<br>    同步屏障是一个target &#x3D; null的Message，Handler机制通过这个方式来区分出同步屏障消息，同步屏障消息并没有真正的执行逻辑，只是为了让异步消息得到更优先的执行。当轮训消息队列的时候碰上同步屏障，则一直往后寻找最早的异步消息来执行。如果没有异步消息就阻塞指导有异步消息被加入队列或者同步屏障被移除为止。同步屏障发送的代码已被hint，如果需要调用则需要反射实现。</p>
<pre><code>MQ中发送同步屏障的方法：
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">(<span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>MQ中移除同步屏障的方法：
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeSyncBarrier</span><span class="params">(<span class="type">int</span> token)</span> &#123;</span><br><span class="line">    <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">    <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; (p.target != <span class="literal">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The specified message queue synchronization &quot;</span></span><br><span class="line">                    + <span class="string">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            needWake = mMessages == <span class="literal">null</span> || mMessages.target != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步屏障具体开发过程中使用较少，大都是在系统层渲染时使用，如需了解以下是几个链接我觉得说的不错：<br><a href="https://blog.csdn.net/start_mao/article/details/98963744">Handler机制——同步屏障</a><br><a href="https://blog.csdn.net/cpcpcp123/article/details/115374057">handler的同步屏障使用场景</a></p>
<p>问题4:<br>    不一定，因为我们消息入队的时间是系统加上当前时间来入队，只是一个相对顺序，消息的执行是串行的，所以必须等上一个消息执行结束才能取出下一个，所以真正的执行时间其实受多个因素影响，1个是前面消息执行的时长，2是如果遇到同步屏障把同步消息阻塞住了，那同步消息执行时间就必须还得依赖同步屏障移除时间。所以，postDelayed只是个相对性的时间并不能达到准确。</p>
<p>最后还有一个小细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Handler的处理消息方法可以看出，处理消息时优先判断是否有callback。所以如果创建Handler的时候指定了Callback，那处理消息的时候执行的是Callback的handleMessage</p>
<p>以上是我对Handler的全部理解，最后附上一篇Handler的面试问题供日后翻阅：<br><a href="https://www.jianshu.com/p/3063c4ab40bd">Handler面试题汇总</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android源码小记-Context解析</title>
    <url>/2022/03/29/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-Context%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Context的使用"><a href="#Context的使用" class="headerlink" title="Context的使用"></a>Context的使用</h2><p>对于Context的使用大家并不陌生，因为在Android开发的方方面面都需要使用到Context，比如说是：</p>
<p>startActivity()：启动Activity、getResource():获取资源、getColor():获取色值、startService():启动服务</p>
<p>正是由于Context是如此的重要，所以我们在很多情况下比如自定义View，都需要传入一个Context对象才能满足编码需求，所以又牵扯出了内存泄漏等问题（比如传入了Activity当成Context，在页面生命周期已经结束时由于某些耗时等操作导致引用仍被持有导致无法及时被回收）。</p>
<p>既然Context是如此重要，那我们就有必要对它做个深入了解。</p>
<span id="more"></span>

<h2 id="Context的设计思想"><a href="#Context的设计思想" class="headerlink" title="Context的设计思想"></a>Context的设计思想</h2><p>Context主要有2层含义</p>
<ol>
<li>从字面上来理解他就是一个上下文对象，也就是说是一个运行的环境。可以理解成你游戏运行到一半要临时保存的进度。当你之后要接着来玩儿这个游戏的时候，可以从记录中恢复之前运行的所有元素。Context其实也有点这个意思，例如当你startActivity()跳转到某一页面时，你可以回溯到你是从哪个页面中跳转过来的。</li>
<li>从具体的源码内容来看，其实Context只是一个抽象类，里面定义了诸多访问应用程序运行所需的接口，例如启动Activity，发送广播等等。其实Android在有意淡化进程的概念，在开发者的开发过程中，通常不需要关心我当前属于哪个进程，只需要表明意图即可，例如打电话，打开网页连接等，当调用系统服务的时候也不需要关心对应接口是属于系统哪个进程，只需要通过Context发起调用，其内部就自动帮你做好了进程之间的调度。所以Context就像是一个运行环境一样，无处不在。有了Context，你的Linux进程就摇身一变成了Android世界的公民，享有Android提供的各种服务。我们来看下Context中提供了一些什么服务：</li>
</ol>
<ul>
<li>获取应用资源，譬如：drawable、string、asset</li>
<li>操作四大组件，譬如：启动页面，发送广播，开启服务，打开数据库</li>
<li>操作文件目录，譬如：获取&#x2F;data&#x2F;分区的缓存目录getExternalCacheDir()</li>
<li>检查授予权限，譬如：checkPermission()</li>
<li>获取其他服务，譬如：包管理服务，Activity管理服务，窗口管理服务等</li>
</ul>
<p>在应用程序中随处都可以访问这些服务，这些服务的访问入口就是Context。所以开发者不用再关系进程，而只需要关心Context提供了哪些接口即可。</p>
<blockquote>
<p>Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc.</p>
</blockquote>
<h3 id="装饰者模式是什么"><a href="#装饰者模式是什么" class="headerlink" title="装饰者模式是什么"></a>装饰者模式是什么</h3><p>在面向对象语言(OOP)中，要为一个类拓展功能最直接的方式就是<strong>继承</strong>，子类可以基于父类进行扩展。但是这种方式的弊端是当要拓展的功能维度足够多，并且功能要相互叠加的时候需要拓展的子类就会越来越多。举个例子：</p>
<blockquote>
<p>基类是衣服，需求是生产防水、透气、速干三种类型的衣服，此时需要拓展出三个子类：防水衣服、透气衣服和速干衣服。此时如果需要生产一种既防水又速干的衣服，那么得拓展出一个新类：防水速干衣服。如果需求再增加：需要生产一件保暖又速干的衣服，那么得扩展出两个新类：保暖衣服和保暖速干衣服。随着需求不断的增加，所需要拓展的子类也会随之增加。</p>
</blockquote>
<p>在GOF设计模式中，把继承看成<strong>静态</strong>类拓展，其弊端就是随着拓展的功能的增加有可能导致子类膨胀(也就是上面例子中的问题)。所以便产生了一种<strong>动态</strong>类拓展的模式：<strong>装饰者模式</strong>。</p>
<p><strong>装饰者模式虽然在实现上和代理模式很相似，但是两者要解决的问题却是截然不同的。</strong></p>
<p><strong>代理模式</strong>：1.为了隐藏代理类以保证对调用方透明做到增加安全性，2.为了实现对代理类某些功能进行用户无感知的功能增强。</p>
<p><strong>装饰者模式</strong>：这种设计模式更多的是强调拓展性，可对任意的功能进行随机组合，有效缓解了拓展维度过多时的子类膨胀。</p>
<p>所以当使用装饰者模式的时候，上例中的需求我们就可以这么做：</p>
<blockquote>
<p>基类还是衣服，需求一样是生产防水、透气、速干三种功能衣服。此时需要拓展出三个子类：防水衣服、透气衣服、速干衣服。此时要新增防水速干衣服时，只需要将防水衣服和速干衣服两者进行组合即可这样就不需要再生成新的子类，同理当需要生产保暖又速干衣服时只需要拓展一个保暖衣服即可，然后将保暖衣服和速干衣服进行组合便能满足需求。</p>
</blockquote>
<p>通过上面说明我们明白了装饰者设计模式的妙处了，具体装饰者设计模式的编码实现我会再出一篇文章详细阐述。当然通过这个例子我们回归正题其实Context的实现也是使用了装饰者模式。</p>
<h3 id="Context类关系图以及装饰者模式的应用"><a href="#Context类关系图以及装饰者模式的应用" class="headerlink" title="Context类关系图以及装饰者模式的应用"></a>Context类关系图以及装饰者模式的应用</h3><img src="/2022/03/29/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-Context%E8%A7%A3%E6%9E%90/Context%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" class="" title="Context类关系图">

<p>从Context的类关系我们可以看出，这是一个典型的装饰者模式。</p>
<p>基类Context定义了各种基础功能接口，ContextImpl则负责实现接口的具体功能。</p>
<p>对外提供Context实现时，需要对它进行一步包装，这就有了ContextWrapper这个类。装饰类一般只是一个传递者，其内部所有的方法实现都是调用ContextImpl，所以ContextWrapper中需要持有一个ContextImpl的引用。</p>
<p>装饰者存在的价值就是为了拓展某个类的功能，Context已经提供了丰富的系统功能但是仍不能满足应用程序的编程需要，所以Android又拓展了一些装饰器，其中包括Application、Activity、Service。此时才能发现原来Context真的是无处不在，在Activity中调用startActivity()其实最终还是通过Context来发起的调用。那么拓展这几个装饰者的意义何在？</p>
<ul>
<li>Application：拓展了应用的生命周期流程控制</li>
<li>Activity：拓展了单一页面的生命周期流程控制</li>
<li>Service：拓展了后台服务的生命周期流程控制</li>
</ul>
<p>它们分别对Context进行了不同维度的拓展，同时也可以将它们当成Context来使用。这就可以解释为什么你在Application中也可以启动页面，在Service中也可以启动页面。</p>
<p>那么既然四大组件中2大都使用的装饰者设计模式都设计成Context的装饰类，为什么<strong>BroadcastReceiver</strong>和<strong>ContentProvider</strong>不是Context的子类呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ContentProvider的构造方法:</span><br><span class="line">public ContentProvider(</span><br><span class="line">        Context context,</span><br><span class="line">        String readPermission,</span><br><span class="line">        String writePermission,</span><br><span class="line">        PathPermission[] pathPermissions) &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mReadPermission = readPermission;</span><br><span class="line">    mWritePermission = writePermission;</span><br><span class="line">    mPathPermissions = pathPermissions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BroadCastReceiver的onReceiver()方法：</span><br><span class="line">public abstract void onReceive(Context var1, Intent var2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看代码可以看出，它们内部都需要传入一个Context，其实换个角度看它们也是装饰类，内部也包装了Context。只是因为这两大组件的使用上和Activity和Service有较大的差别，并且它们内部并不没有很复杂的生命周期控制流程等，所以它们就用了最简单的实现方式。</p>
<blockquote>
<p><strong>题外话：</strong>装饰者模式存在于Android源码中很多地方，比如除了Context，Window的设计也是用的装饰者模式。</p>
</blockquote>
<p>至此我们做个小结：Context在Android中无处不在，它是Android系统为了弱化进程概念而设计出来的一个上下文对象（也可以理解为代表了当前的运行环境）。Context是个抽象类其提供了各种各样的功能接口供开发者使用，例如想获取资源，想跳转页面等等，都可以通过调用Context来获取。Application、Activity、Service均是Context的装饰类，它们分别拓展了不同的功能用于针对不同的应用场景。Context的真正实现其实是在ContextImpl中。</p>
<h2 id="Context源码分析"><a href="#Context源码分析" class="headerlink" title="Context源码分析"></a>Context源码分析</h2><blockquote>
<p>源码基于API25进行讲解,代码只节选部分重要内容，具体需要自行阅读源码</p>
</blockquote>
<p>Context主要有3种：</p>
<ul>
<li><strong>SystemContext：系统进程SystemServer的Context</strong></li>
<li><strong>AppContext：应用进程的Context</strong></li>
<li><strong>ActivityContext：Activity的Context，只有ActivityContext跟界面显示相关，需要传入activityToken和有效的DisplayId</strong></li>
</ul>
<p>对于Context的源码分析我们通过2条主线来进行：</p>
<ol>
<li><strong>Application的Context是如何构建的</strong></li>
<li><strong>Activity的Context是如何构建的</strong></li>
</ol>
<p>开始前先说明一个概念：Android系统进程与应用进程之间的通信建立在Binder通信之上，而以下两个接口是Android为应用进程与系统进程之间通信而设计的：</p>
<ul>
<li><strong>IApplicationThread</strong>: 作为系统进程请求应用进程的接口</li>
<li><strong>IActivityManager</strong>: 作为应用进程请求系统进程的接口</li>
</ul>
<h3 id="Application的Context构建流程"><a href="#Application的Context构建流程" class="headerlink" title="Application的Context构建流程"></a>Application的Context构建流程</h3><img src="/2022/03/29/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-Context%E8%A7%A3%E6%9E%90/Application%E7%9A%84ContextImpl%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.jpg" class="" title="Application的ContextImpl创建流程">

<p>整个流程分为几大块来讲解：</p>
<ol>
<li>Android开启一个进程时最终是从java层的<code>ActivityThread.main()</code> 方法开始的，然后调用<code>ActivityThread.attach()</code> 方法。该方法内部会调用<code>ActivityManagerService.attachApplication(IApplicationThread)</code>，了解过Binder的就能明白<strong>ActivityManagerService(AMS)</strong> 其实就是Binder通信的实现，此时调用<code>attachApplication()</code> 之后就进入系统进程对应用做了一系列的初始化，然后通过传入的<code>ApplicationThread.bindApplication()</code> 将初始化的信息回调给用户进程</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 主线程Lopper  </span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    // 进入attach()方法中，传入false表示非系统应用</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler == null) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (false) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(new</span><br><span class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    Looper.loop();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在attach()方法中，通过以下代码进入AMS进程对应用进行初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">try &#123;</span><br><span class="line">    mgr.attachApplication(mAppThread);</span><br><span class="line">&#125; catch (RemoteException ex) &#123;</span><br><span class="line">    throw ex.rethrowFromSystemServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时会回调到<strong>ActivityManagerService</strong>类中，循着方法进入最终调用到<code>ActivityManagerService.attachApplicationLocked()</code>方法，对应用做了一系列的初始化赋值并回调给<strong>IApplicationThread</strong> 对象从而进入应用进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">        profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">        app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">        new Configuration(mConfiguration), app.compat,</span><br><span class="line">        getCommonServicesLocked(app.isolated),</span><br><span class="line">        mCoreSettingsObserver.getCoreSettingsLocked());</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>应用进程收到<strong>AMS</strong>的初始化结果之后生成一个临时的存储对象<strong>AppBindData</strong>并最终通过H这个Handler调用到<code>handleBindApplication()</code>方法。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">        List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">        IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">        IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">        boolean enableBinderTracking, boolean trackAllocation,</span><br><span class="line">        boolean isRestrictedBackupMode, boolean persistent, Configuration config,</span><br><span class="line">        CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    AppBindData data = new AppBindData();</span><br><span class="line">    data.processName = processName;</span><br><span class="line">    data.appInfo = appInfo;</span><br><span class="line">    data.providers = providers;</span><br><span class="line">    data.instrumentationName = instrumentationName;</span><br><span class="line">    data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">    data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">    data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">    data.debugMode = debugMode;</span><br><span class="line">    data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">    data.trackAllocation = trackAllocation;</span><br><span class="line">    data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">    data.persistent = persistent;</span><br><span class="line">    data.config = config;</span><br><span class="line">    data.compatInfo = compatInfo;</span><br><span class="line">    data.initProfilerInfo = profilerInfo;</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>handleBindApplication()</code>中首先调用<code>getPackageInfoNoCheck()</code>创建出一个<strong>LoadedApk</strong>并将其缓存起来。该对象表示一个已经加载解析过的APK文件。紧接着通过PMS构造出一个<strong>InstrumentationInfo</strong>对象紧接着通过它使用类加载器构建出一个<strong>Instrumentation</strong>对象，该对象其实是对Activity或者Application方法调用的一个统一收口(简单说就是将ActivityThread对Activity和Application的通信都统一规范到这一个类中进行)，期间的通信介质就是<strong>LoadedApk</strong>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 构建一个LoadedApk对象，该对象其实是应用在内存中的表现形式。</span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    final InstrumentationInfo ii;</span><br><span class="line">    if (data.instrumentationName != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 内部是通过PackageManagerService(PMS)来创建一个InstrumentationInfo对象，用于后续生成Instrumentation</span><br><span class="line">            ii = new ApplicationPackageManager(null, getPackageManager())</span><br><span class="line">                    .getInstrumentationInfo(data.instrumentationName, 0);</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to find instrumentation info for: &quot; + data.instrumentationName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mInstrumentationPackageName = ii.packageName;</span><br><span class="line">        mInstrumentationAppDir = ii.sourceDir;</span><br><span class="line">        mInstrumentationSplitAppDirs = ii.splitSourceDirs;</span><br><span class="line">        mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii);</span><br><span class="line">        mInstrumentedAppDir = data.info.getAppDir();</span><br><span class="line">        mInstrumentedSplitAppDirs = data.info.getSplitAppDirs();</span><br><span class="line">        mInstrumentedLibDir = data.info.getLibDir();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ii = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (ii != null) &#123;</span><br><span class="line">        // 这个Context不是Application的Context，本次关注Application的context的创建所以这边咱不关心</span><br><span class="line">        final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            final ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">            // 创建出Instrumentation对象</span><br><span class="line">            mInstrumentation = (Instrumentation)</span><br><span class="line">                cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate instrumentation &quot;</span><br><span class="line">                + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        final ComponentName component = new ComponentName(ii.packageName, ii.name);</span><br><span class="line">        mInstrumentation.init(this, instrContext, appContext, component,</span><br><span class="line">                data.instrumentationWatcher, data.instrumentationUiAutomationConnection);</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mInstrumentation = new Instrumentation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        // 调用LoadedApk的makeApplication()开始了Application的创建流程以及将其与ContextImpl绑定</span><br><span class="line">        Application app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Exception thrown in onCreate() of &quot;</span><br><span class="line">                + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 执行Application.onCreate()</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面代码可以看到我们有了<strong>LoadedApk(代表整个APK)、Instrumentation(ActivityThread与Application和Activity的通信收口)</strong> 这俩对象，主要创建流程都是在这俩类中进行的。<br>LoadedApk中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">        Instrumentation instrumentation) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Application app = null;</span><br><span class="line"></span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">        // 没有自定义Application或者规定了使用默认Application，则初始化的是android.app.Application</span><br><span class="line">        appClass = &quot;android.app.Application&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取类加载器</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        ...</span><br><span class="line">        // 创建出应用Context</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">        // 执行Instrumentation的newApplication()创建一个Application</span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必要的类都创建完毕之后就该开始使用它们了，调用<code>LoadedApk.makeApplication()</code>方法来创建出一个<strong>Application</strong>对象(该对象之后再传递给Instrumentation来执行onCreate()等方法从而走到Application的生命周期)，创建Application的过程概括来讲就是调用类加载器将我们AndroidManifest中生命的Application加载进内存，如果我们没有指定自己的Application的话就默认会加载”<strong>android.app.Application</strong>“。<br>具体的Application创建流程是首先生成一个ClassLoader，然后通过<code>ContextImpl.createAppContext()</code>构造了一个appContext(<strong>应用级别的Context</strong>)，构造时保存了LoadedApk，进程的ActivityThread以及初始化了Resource资源，ApplicationContentResolver对数据库的操作类等等。</p>
<p>4.然后将这两个对象传入应用的<code>Instrumentation.newApplication()</code>，其内部使用类加载器+反射生成一个Application，紧接着调用<code>Application.attach()</code>将appContext设置给Application这个装饰类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static public Application newApplication(Class&lt;?&gt; clazz, Context context)</span><br><span class="line">        throws InstantiationException, IllegalAccessException, </span><br><span class="line">        ClassNotFoundException &#123;</span><br><span class="line">    // 反射生成Application对象</span><br><span class="line">    Application app = (Application)clazz.newInstance();</span><br><span class="line">    // 将应用Context设置给Application，此时其实就是设置给了ContextWrapper的mBase属性，而Application是ContextWrapper子类所以自然它也就和Context关联起来了。</span><br><span class="line">    app.attach(context);</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这整个流程下来就完成了Application中Context的构建，也就是Application这个装饰类对ContextImpl的装饰。</p>
<h3 id="Activity的Context构建流程"><a href="#Activity的Context构建流程" class="headerlink" title="Activity的Context构建流程"></a>Activity的Context构建流程</h3><p>如果从Activity的启动流程来讲解那将是一篇遥遥无期的文章，这里省去了Activity启动流程中前半部分复杂的逻辑，具体可以参考另外一个文章我会贴链接。</p>
<img src="/2022/03/29/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-Context%E8%A7%A3%E6%9E%90/Activity%E7%9A%84ContextImpl%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg" class="" title="Activity的ContextImpl创建过程">

<p>我们通过Activity启动流程中可以知道最终会调用到<code>ActivityThread.handleLaunchActivity()</code>方法中来，紧接着在其内部会执行<code>Activity a = performLaunchActivity(r, customIntent);</code> 用于创建Activity，然后调用<code>handleResumeActivity(...);</code>开始页面的测绘流程等。本篇只为探究Activity的Context创建过程，所以只关心performLaunchActivity()流程。</p>
<p>Activity的Context创建过程比Application中Context流程简单很多。主要分为几步(<strong>以下代码均摘抄自performLaunchActivity()方法</strong>)：</p>
<ol>
<li>通过ActivityThread中的mInstrumentation对象调用newActivity()生成对应的Activity对象，其内部生成原理就是通过反射创建。而这个mInstrumentation其实在应用启动过程中已经创建完毕，也就是在Application的Context创建流程中。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过LoadedApk获取ClassLoader</span><br><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">// 创建出所需启动的Activity对象，内部是使用反射</span><br><span class="line">activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br></pre></td></tr></table></figure></li>
<li>调用createBaseContextForActivity()方法去创建一个Activity对应的ContextImpl，其内部也是调用的ContextImpl的构造方法创建。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line"></span><br><span class="line">private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 创建Activity对应的ContextImpl</span><br><span class="line">    ContextImpl appContext = ContextImpl.createActivityContext(</span><br><span class="line">            this, r.packageInfo, r.token, displayId, r.overrideConfig);</span><br><span class="line">    appContext.setOuterContext(activity);</span><br><span class="line">    Context baseContext = appContext;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    return baseContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>调用activity.attach(…)方法将创建出来的ContextImpl与Activity绑定起来，当然传递的参数有很多，比如也会将Application传递进去，当然这时候这个对象也已经存在了。紧接着内部还是老配方：执行attachBaseContext(context);将ContextImpl设置给父类ContextWrapper的mBase属性。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将创建出来的ContextImpl关联给Activity，其内部是调用了attachBaseContext(context);将其设置给ContextWrapper.mBase</span><br><span class="line">// 当然这个方法做了很多很多事，这里不研究别的我们只关心Context的创建流程</span><br><span class="line">activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">        r.referrer, r.voiceInteractor, window);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>至此流程结束</p>
<h2 id="Context注意事项"><a href="#Context注意事项" class="headerlink" title="Context注意事项"></a>Context注意事项</h2><h4 id="内存泄漏问题："><a href="#内存泄漏问题：" class="headerlink" title="内存泄漏问题："></a>内存泄漏问题：</h4><p><strong>内存泄漏的本质是长生命周期的对象持有了短生命周期对象的引用导致短生命周期对象在无用的情况下不能及时被GC</strong></p>
<p>而使用Context导致内存泄漏的情况往往是将Activity这种相对短生命周期的对象传给其他对象使用，可能其他对象中有耗时操作导致Activity无法被及时回收。还有一个典型的场景就是在Android开发中往往在设计很多单例的时候需要传入一个Context，如果此时传入的是Activity那就会造成内存泄漏。因为我们知道通常单例方法是static，其涉及的生命周期是整个进程，所以为了解决这个问题可以考虑传入Application的Context来解决这个问题。</p>
<h4 id="Context的使用："><a href="#Context的使用：" class="headerlink" title="Context的使用："></a>Context的使用：</h4><p>在Android开发中在一个Activity中获取Context的方法有很多种：</p>
<ul>
<li><p>getApplication()：返回Application对象</p>
</li>
<li><p>getApplicationContext()：与getApplication()返回同一个对象，只不过其返回的是Context类型，java中向上转型必然会被阉割掉一些子类独有的方法</p>
</li>
<li><p>getBaseContext()：返回Activity的ContextImpl对象（Application.getBaseContext()：返回Application的ContextImpl对象）</p>
</li>
<li><p>Activity.this：返回Activity本身</p>
<p>  正是ContextImpl被外层装饰器包装了一下才形成了Context不同功能的拓展。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Context淡化了Android进程的概念，其提供了一个应用的运行环境。Android中它无处不在，开发者可以通过它调用一系列的系统方法比如获取资源，打开页面，打开服务等等。</p>
<p>其实现上采用了装饰者模式，Activity、Application、Service等都是装饰类，当开发者使用这些装饰者作为Context来使用的时候，其实真正的实现逻辑是在ContextImpl类中。</p>
<p>在Context的使用中要十分注意避免出现内存泄漏问题。_</p>
<hr>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
</search>
