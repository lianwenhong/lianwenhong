<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android-Resource解析</title>
    <url>/2022/04/02/Android-Resource%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>System.load()与System.loadLibrary()实现及so热修复</title>
    <url>/2022/04/13/Android%E4%B8%A4%E7%A7%8Dso%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8F%8Aso%E7%83%AD%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<p>文章基于API25分析，源码地址：<a href="http://androidxref.com/7.1.1_r6/">http://androidxref.com/7.1.1_r6/</a></p>
<h3 id="ClassLoader简单复习（必要前提）"><a href="#ClassLoader简单复习（必要前提）" class="headerlink" title="ClassLoader简单复习（必要前提）"></a>ClassLoader简单复习（必要前提）</h3><p>在分析System类之前，先简单复习一下ClassLoader的类加载机制。</p>
<img src="/2022/04/13/Android%E4%B8%A4%E7%A7%8Dso%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8F%8Aso%E7%83%AD%E4%BF%AE%E5%A4%8D/ClassLoader%E7%B1%BB%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E5%9B%BE%E4%BB%A5%E5%8F%8A%E6%9B%BF%E6%8D%A2dexElements%E5%AE%9E%E7%8E%B0%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86.jpg" class="" title="ClassLoader类结构关系图以及替换dexElements实现热修复原理">

<span id="more"></span>

<p>Android应用中模式使用的类加载器是<strong>PathClassLoader</strong>。想要了解可简单看下<strong>Application.getClassLoader()</strong> 的调用栈。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Application.getClassLoader() -&gt; ContextImpl.getClassLoader -&gt;</span><br><span class="line">LoadedApk.getClassLoader() -&gt; ... -&gt; ClassLoader.createSystemClassLoader() -&gt; new PathClassLoader(...)</span><br></pre></td></tr></table></figure>
<p>而<strong>PathClassLoader</strong>只是重载了几个构造方法，真正的代码实现都在父类<strong>BaseDexClassLoader</strong>中。</p>
<p>BaseDexClassLoader中pathList:DexPathList类说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final class DexPathList &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // List of dex/resource (class path) elements.意思是class文件转化结果:dex文件集合</span><br><span class="line">    private Element[] dexElements;</span><br><span class="line"></span><br><span class="line">    // List of native library path elements. 意思是native层so文件集合  </span><br><span class="line">    // 在热修复技术中so修复可以将新的so库路径追加到此数组之前达到热修效果，其实它是将例如xxx/xxx/abc.so分别以dir:xxx/xxx/、zip:abc.so这样区分存储而已，为了使用方便</span><br><span class="line">    private final Element[] nativeLibraryPathElements;</span><br><span class="line"></span><br><span class="line">    // List of application native library directories. 意思是native层so文件的路径集合，只表示路径。</span><br><span class="line">    private final List&lt;File&gt; nativeLibraryDirectories;</span><br><span class="line"></span><br><span class="line">    // List of system native library directories.意思是系统so文件路径集合</span><br><span class="line">    private final List&lt;File&gt; systemNativeLibraryDirectories;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Element &#123;</span><br><span class="line">    private final File dir; // 路径</span><br><span class="line">    private final boolean isDirectory; // 该Element是否是文件夹</span><br><span class="line">    private final File zip; // 路径下对应的文件</span><br><span class="line">    private final DexFile dexFile; // 路径下对应的dex文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类加载机制了解简单了解完开始分析<strong>System</strong>类。</p>
<h3 id="System-load"><a href="#System-load" class="headerlink" title="System.load():"></a>System.load():</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void load(String filename) &#123;</span><br><span class="line">    Runtime.getRuntime().load0(VMStack.getStackClass1(), filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用Runtime类中的load0()方法将文件名传入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized void load0(Class fromClass, String filename) &#123;</span><br><span class="line">    if (!(new File(filename).isAbsolute())) &#123;</span><br><span class="line">        throw new UnsatisfiedLinkError(</span><br><span class="line">            &quot;Expecting an absolute path of the library: &quot; + filename);</span><br><span class="line">    &#125;</span><br><span class="line">    if (filename == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;filename == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 最终调用此方法去load so文件，其内部是去调用native方法</span><br><span class="line">    String error = doLoad(filename, fromClass.getClassLoader());</span><br><span class="line">    if (error != null) &#123;</span><br><span class="line">        throw new UnsatisfiedLinkError(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 注释大概意思是我们日常应用进程是从Zygote进程fork出来的所以都是公用的同一个LD_LIBRARY_PATH路径。</span><br><span class="line"> * 开放这个方法是为了用户能动态的加载不同路径下的so库而不是只有启动的时候从单一的目录加载一次。</span><br><span class="line"> * 理由是因为一个进程可能会运行多个apk并且用户可能会手动实现自己的BaseDexClassLoader，</span><br><span class="line"> * 所以有必要为用户提供一个差异化so加载的能力</span><br><span class="line"> */</span><br><span class="line">private String doLoad(String name, ClassLoader loader) &#123;</span><br><span class="line">    // Android apps are forked from the zygote, so they can&#x27;t have a custom LD_LIBRARY_PATH,</span><br><span class="line">    // which means that by default an app&#x27;s shared library directory isn&#x27;t on LD_LIBRARY_PATH.</span><br><span class="line"></span><br><span class="line">    // The PathClassLoader set up by frameworks/base knows the appropriate path, so we can load</span><br><span class="line">    // libraries with no dependencies just fine, but an app that has multiple libraries that</span><br><span class="line">    // depend on each other needed to load them in most-dependent-first order.</span><br><span class="line"></span><br><span class="line">    // We added API to Android&#x27;s dynamic linker so we can update the library path used for</span><br><span class="line">    // the currently-running process. We pull the desired path out of the ClassLoader here</span><br><span class="line">    // and pass it to nativeLoad so that it can call the private dynamic linker API.</span><br><span class="line"></span><br><span class="line">    // We didn&#x27;t just change frameworks/base to update the LD_LIBRARY_PATH once at the</span><br><span class="line">    // beginning because multiple apks can run in the same process and third party code can</span><br><span class="line">    // use its own BaseDexClassLoader.</span><br><span class="line"></span><br><span class="line">    // We didn&#x27;t just add a dlopen_with_custom_LD_LIBRARY_PATH call because we wanted any</span><br><span class="line">    // dlopen(3) calls made from a .so&#x27;s JNI_OnLoad to work too.</span><br><span class="line"></span><br><span class="line">    // So, find out what the native library search path is for the ClassLoader in question...</span><br><span class="line">    String librarySearchPath = null;</span><br><span class="line">    if (loader != null &amp;&amp; loader instanceof BaseDexClassLoader) &#123;</span><br><span class="line">        BaseDexClassLoader dexClassLoader = (BaseDexClassLoader) loader;</span><br><span class="line">        // 调用BaseDexClassLoader中的方法用于将所有native的lib路径以：拼接在一起然后给native层去load so文件</span><br><span class="line">        librarySearchPath = dexClassLoader.getLdLibraryPath();</span><br><span class="line">    &#125;</span><br><span class="line">    // nativeLoad should be synchronized so there&#x27;s only one LD_LIBRARY_PATH in use regardless</span><br><span class="line">    // of how many ClassLoaders are in the system, but dalvik doesn&#x27;t support synchronized</span><br><span class="line">    // internal natives.</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        // 最终调用native方法去load so库。Android所有的so库都是通过这个方法加载进内存的</span><br><span class="line">        return nativeLoad(name, loader, librarySearchPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TODO: should be synchronized, but dalvik doesn&#x27;t support synchronized internal natives.</span><br><span class="line">    private static native String nativeLoad(String filename, ClassLoader loader,</span><br><span class="line">                                            String librarySearchPath);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上是<strong>System.load()</strong> 的全部流程。</p>
<h3 id="System-loadLibrary"><a href="#System-loadLibrary" class="headerlink" title="System.loadLibrary()"></a>System.loadLibrary()</h3><p>System.loadLibrary()相比System.load()会复杂一些。因为它不再是从你随便指定的路径中去加载so，而是从系统给你的路径中加载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void loadLibrary(String libname) &#123;</span><br><span class="line">    Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一样是走到Runtime类中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized void loadLibrary0(ClassLoader loader, String libname) &#123;</span><br><span class="line">    if (libname.indexOf((int)File.separatorChar) != -1) &#123;</span><br><span class="line">        // 如果传入的是带/的文件路径则抛异常，这个类型的异常如果进行ndk相关开发肯定见过</span><br><span class="line">        throw new UnsatisfiedLinkError(</span><br><span class="line">&quot;Directory separator should not appear in library name: &quot; + libname);</span><br><span class="line">    &#125;</span><br><span class="line">    String libraryName = libname;</span><br><span class="line">    if (loader != null) &#123;</span><br><span class="line"></span><br><span class="line">        // 从类加载器中查找so文件名并以全路径返回，类加载器中查找so时的路径是在其构造的时候指定的。</span><br><span class="line">        String filename = loader.findLibrary(libraryName);</span><br><span class="line">        if (filename == null) &#123;</span><br><span class="line">            // It&#x27;s not necessarily true that the ClassLoader used</span><br><span class="line">            // System.mapLibraryName, but the default setup does, and it&#x27;s</span><br><span class="line">            // misleading to say we didn&#x27;t find &quot;libMyLibrary.so&quot; when we</span><br><span class="line">            // actually searched for &quot;liblibMyLibrary.so.so&quot;.</span><br><span class="line">            throw new UnsatisfiedLinkError(loader + &quot; couldn&#x27;t find \&quot;&quot; +</span><br><span class="line">                                           System.mapLibraryName(libraryName) + &quot;\&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到就加载</span><br><span class="line">        String error = doLoad(filename, loader);</span><br><span class="line">        if (error != null) &#123;</span><br><span class="line">            throw new UnsatisfiedLinkError(error);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果类加载器为空，则获取到比如xxx.so，然后从系统提供的目录中查找(例如：/vendor/lib:/system/lib)，一样判断是否只读如果是则调用doLoad()加载</span><br><span class="line">    String filename = System.mapLibraryName(libraryName);</span><br><span class="line">    List&lt;String&gt; candidates = new ArrayList&lt;String&gt;();</span><br><span class="line">    String lastError = null;</span><br><span class="line">    for (String directory : getLibPaths()) &#123;</span><br><span class="line">        String candidate = directory + filename;</span><br><span class="line">        candidates.add(candidate);</span><br><span class="line"></span><br><span class="line">        if (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">            String error = doLoad(candidate, loader);</span><br><span class="line">            if (error == null) &#123;</span><br><span class="line">                return; // We successfully loaded the library. Job done.</span><br><span class="line">            &#125;</span><br><span class="line">            lastError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (lastError != null) &#123;</span><br><span class="line">        throw new UnsatisfiedLinkError(lastError);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new UnsatisfiedLinkError(&quot;Library &quot; + libraryName + &quot; not found; tried &quot; + candidates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当类加载器不是空的时候，调用<code> load.findLibrary(libraryName)</code>最终会调用到DexPathList中去:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String findLibrary(String libraryName) &#123;</span><br><span class="line">    String fileName = System.mapLibraryName(libraryName);</span><br><span class="line"></span><br><span class="line">    for (Element element : nativeLibraryPathElements) &#123;</span><br><span class="line">        String path = element.findNativeLibrary(fileName);</span><br><span class="line"></span><br><span class="line">        if (path != null) &#123;</span><br><span class="line">            return path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里我们就可以跟做Dex补丁一样的方式在这个Element数组前面插入补丁SO文件, 这样在findLibrary的时候就会优先返回插入的SO文件, 并执行doLoad加载插入的SO文件. 那插入的时机是什么时候? findLibrary的动作是在调用了System.loadLibrary后才执行的,所以插入补丁的动作应该是要放在System.loadLibrary之前才能确保加载的时候更新SO文件.</p>
<p>所以到最后其实System.loadLibrary()只是从特定的路径中去加载so库最终还是回调给Runtime.doLoad()，然后再调用Runtime.nativeLoad()这个native方法来执行的so加载。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>System.load()和System.loadLibrary()方法其实最终原理都一样，是通过调用Runtime.doLoad()最终Runtime.nativeLoad()调用到native层实现的so库加载，两者的区别在于查找so库的路径上。</p>
<p>关于热更新so库有两种实现</p>
<ol>
<li>和dex热更新一样，将补丁包的路径插入到DexPathList.nativeLibraryPathElements属性的最前面达到抢先加载的目的。这样的好处是开发者在加载so库的时候和往常一样直接System.loadLibrary(xxx)即可，缺点是需要考虑到Android系统不断在更新可能导致的api变动，毕竟这种方案是通过反射来修改的值。并且还需要考虑不同cpu架构插入不同so的问题，比如arm&#x2F;intel</li>
<li>使用System.load(xxx)去直接加载补丁包路径下的so，这种方式的好处在于你不需要去关心系统版本兼容和cpu架构等问题，缺点是开发者使用的时候需要改成System.load(xxx)这种加载方式，对于开发者不够透明。</li>
</ol>
<p>附上so热修复实现图：</p>
<img src="/2022/04/13/Android%E4%B8%A4%E7%A7%8Dso%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8F%8Aso%E7%83%AD%E4%BF%AE%E5%A4%8D/Tinker%E7%83%AD%E4%BF%AE%E5%A4%8Dso%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86%E5%9B%BE.png" class="" title="Tinker热修复so修复原理图">


<p>参考文章：<a href="https://blog.csdn.net/l2show/article/details/53573945">https://blog.csdn.net/l2show/article/details/53573945</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android小知识- LayoutInflater</title>
    <url>/2022/08/19/Android%E5%B0%8F%E7%9F%A5%E8%AF%86-LayoutInflater/</url>
    <content><![CDATA[<h3 id="报错引发的LayoutInflater使用上的思考"><a href="#报错引发的LayoutInflater使用上的思考" class="headerlink" title="报错引发的LayoutInflater使用上的思考"></a>报错引发的LayoutInflater使用上的思考</h3><p>今天在开发过程中无意间收获了这么一个崩溃：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child&#x27;s parent first.</span><br><span class="line">        at android.view.ViewGroup.addViewInner(ViewGroup.java:4937)</span><br><span class="line">        at android.view.ViewGroup.addView(ViewGroup.java:4768)</span><br><span class="line">        at android.view.ViewGroup.addView(ViewGroup.java:4708)</span><br><span class="line">        at androidx.fragment.app.FragmentStateManager.addViewToContainer(FragmentStateManager.java:840)</span><br><span class="line">        at androidx.fragment.app.FragmentStateManager.createView(FragmentStateManager.java:529)</span><br><span class="line">        at androidx.fragment.app.FragmentStateManager.moveToExpectedState(FragmentStateManager.java:261)</span><br><span class="line">        at androidx.fragment.app.FragmentManager.executeOpsTogether(FragmentManager.java:1890)</span><br><span class="line">        at androidx.fragment.app.FragmentManager.removeRedundantOperationsAndExecute(FragmentManager.java:1808)</span><br><span class="line">        at androidx.fragment.app.FragmentManager.execPendingActions(FragmentManager.java:1751)</span><br><span class="line">        at androidx.fragment.app.FragmentManager$5.run(FragmentManager.java:538)</span><br><span class="line">        at android.os.Handler.handleCallback(Handler.java:790)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:99)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:164)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:6494)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)</span><br></pre></td></tr></table></figure>
<p>崩溃的意思是某个View已经存在父View，如果要重复添加的话就得先执行<code>removeView()把</code>它从父View中移除，这是一个很常见的错误，一个View只能存在一个父View。同理：同一个鸡蛋不可能同时被放在两个篮子中。</p>
<p>报错代码在一个<code>Fragment-&gt;onCreateView()</code>声明周期回调中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override fun onCreateView(</span><br><span class="line">    inflater: LayoutInflater,</span><br><span class="line">    container: ViewGroup?,</span><br><span class="line">    savedInstanceState: Bundle?</span><br><span class="line">): View? &#123;</span><br><span class="line">    return inflater.inflate(R.layout.fragment_me, container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要将<code> inflater.inflate(R.layout.fragment_me, container)</code>这行改成<code> inflater.inflate(R.layout.fragment_me, container, false)</code>即可正常运行。</p>
<h3 id="LayoutInflater原理解析"><a href="#LayoutInflater原理解析" class="headerlink" title="LayoutInflater原理解析"></a>LayoutInflater原理解析</h3><p><strong>这个inflate方法旨在获取某个指定的View</strong></p>
<p><strong>进去翻了翻这段代码的源码，简单记录一下，如果不感兴趣可直接翻到末尾总结中查看使用时的注意事项：</strong></p>
<p>首先不管它如何创建，直接从报错代码切入，inflate方法总共有4个重载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 方法1</span><br><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;</span><br><span class="line">    return inflate(resource, root, root != null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法2</span><br><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root) &#123;</span><br><span class="line">    return inflate(parser, root, root != null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法3</span><br><span class="line">// attachToRoot表示是否将resource解析出来的View添加到root容器中</span><br><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return inflate(parser, root, attachToRoot);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法4</span><br><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在日常业务开发中比较常用的是方法1和方法3这两个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;</span><br><span class="line">    // 如果root容器是null，那肯定不能将获得的view添加到一个空容器中</span><br><span class="line">    // 如果root容器不是空，那直接将获取到的view添加到该容器中</span><br><span class="line">    return inflate(resource, root, root != null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法3</span><br><span class="line">// attachToRoot表示是否将resource解析出来的View添加到root容器中</span><br><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    final Resources res = getContext().getResources();</span><br><span class="line">    // 这个方法是Android10新增的一个编译优化，可将xml预编译成dex，然后通过反射生成对应的View，从而减少XmlPullParser解析Xml的时间。无需关心，因为目前开关都关着，即使开起来目前来看也是一段有bug的代码！！！</span><br><span class="line">    View view = tryInflatePrecompiled(resource, res, root, attachToRoot);</span><br><span class="line">    if (view != null) &#123;</span><br><span class="line">        // 如果开启了预编译并且解析成功了，直接返回对应的view</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line">    // 通过Resources获取xml解析器，可见方法2区别其实就是在外部获取完这个xml解析器传进来而已</span><br><span class="line">    XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 执行解析并生成view</span><br><span class="line">        return inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) </code>表示解析并生成resource这个id对应的view，如果传入的父容器不是空的就顺带将这个view添加到父容器中。</p>
<p><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</code>这就让开发者可以更灵活的控制view是否被添加到父容器，当然前提是root不是空的才能被添加进去。毕竟鸡蛋放在一个没有底的篮子里最终的结果就是蛋碎。</p>
<p>所以最终的重担还是落到方法4中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    synchronized (mConstructorArgs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 把root赋值给result，这里涉及到后续应该给调用方返回什么结果，后面说</span><br><span class="line">        View result = root;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            advanceToRootNode(parser);</span><br><span class="line">            // 取到制定resource id对应的最根view的名称</span><br><span class="line">            final String name = parser.getName();</span><br><span class="line">            </span><br><span class="line">            // merge标签处理逻辑</span><br><span class="line">            if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                // merge标签的意义在于减少层级，而减少层级的实现是将merge标签下的子view直接加到父容器中以此减少一个层级，否则的话每个xml是不是还得写个容器来承载xml中的所有view，所以如果此时指定的xml根布局是个merge标签那就必然需要指定root并且指定其将其加入root容器，否则它将无所依附，所以此处抛出异常警告开发者</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</span><br><span class="line">                            + &quot;ViewGroup root and attachToRoot=true&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果是merge标签，解析其所有一级标签并将其添加到root中，然后对所有一级标签再递归解析出所有子view最终行程一个正确的view树</span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 非merge标签处理逻辑</span><br><span class="line">                // 获取到xml布局中的根视图，内部是通过反射来生成对应的view对象</span><br><span class="line">                final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                ViewGroup.LayoutParams params = null;</span><br><span class="line">                </span><br><span class="line">                //如果root不为空则解析布局参数，这个布局参数将作用给temp(也就是xml布局中的根视图)，如果root为空则调用方获取到的是一个干净的不带layoutparam的view。</span><br><span class="line">                if (root != null) &#123;</span><br><span class="line">                    // Create layout params that match root, if supplied</span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    if (!attachToRoot) &#123;</span><br><span class="line">                        // 设置布局参数</span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // xml的根布局生成出来之后就该逐个解析并生成它内部的所有子view以构成一个正确的view树，内部其实是一个递归的过程</span><br><span class="line">                rInflateChildren(parser, temp, attrs, true);</span><br><span class="line"></span><br><span class="line">                // 如果root不为空并且调用时attachToRoot指定为true，则意思是需要将view加入root中，do it</span><br><span class="line">                if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 从这里可以看出，当调用方并没有指定父容器或者指定了父容器但是不将xml布局加入父容器中，则将xml解析出来的view返回给调用房，否则的话xml解析出来的view其实已经被加入父容器了，所以直接将父容器返回。有时候我们调用inflate时会指定root是非空，attachToRoot是false其实就是为了给xml解析出来的view设置布局参数而已。</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从方法4实现来看，其主要逻辑是解析xml布局文件并生成对应的view。如果xml是个merge标签的布局则进行merge对应的处理（将一级视图添加到root中以减少一个层级）。<strong>需要注意的是调用inflate时所传入参数不同而获取到的结果就有可能是不同含义：最终如果xml解析出来的布局被成功添加到root中的话则直接返回root容器，否则返回xml解析出来的view。我不知道为什么要这么设计，总感觉这种设计会给开发过程徒增不必要的麻烦</strong></p>
<p>在我们日常使用中除了<code>Fragment-&gt;onCreateView()</code>回调中会给我们提供已经创建好的<code>LayoutInflater</code>对象之外，我们往往需要自己创建，来看下它的创建过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mLayoutInflater = LayoutInflater.from(context);</span><br><span class="line"></span><br><span class="line">public static LayoutInflater from(@UiContext Context context) &#123;</span><br><span class="line">    LayoutInflater LayoutInflater =</span><br><span class="line">            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">    if (LayoutInflater == null) &#123;</span><br><span class="line">        throw new AssertionError(&quot;LayoutInflater not found.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return LayoutInflater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LayoutInflater是通过context获取系统服务得到的。</p>
<p>在Activity中往往不需要自己手动创建，因为Activity中已经提供了LayoutInflater对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Activity.java</span><br><span class="line"></span><br><span class="line">@NonNull</span><br><span class="line">public LayoutInflater getLayoutInflater() &#123;</span><br><span class="line">    // 调用PhoneWindow.getLayoutInflater()</span><br><span class="line">    return getWindow().getLayoutInflater();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PhoneWindow.java</span><br><span class="line"></span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">public PhoneWindow(Context context) &#123;</span><br><span class="line">    super(context);</span><br><span class="line">    // 此时传入的就是Activity</span><br><span class="line">    mLayoutInflater = LayoutInflater.from(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public LayoutInflater getLayoutInflater() &#123;</span><br><span class="line">    return mLayoutInflater;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在使用<code>RecyclerView</code>时经常需要使用到LayoutInflater，设置Adapter时有这么个回调：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里LayoutInflater基本上介绍完了，但是在方法3时有个<code>tryInflatePrecompiled()</code>方法顺带提一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private @Nullable</span><br><span class="line">View tryInflatePrecompiled(@LayoutRes int resource, Resources res, @Nullable ViewGroup root,</span><br><span class="line">    boolean attachToRoot) &#123;</span><br><span class="line">    if (!mUseCompiledView) &#123;</span><br><span class="line">        // 未开启预编译则直接返回空，后续会去走xml解析</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // Try to inflate using a precompiled layout.</span><br><span class="line">    String pkg = res.getResourcePackageName(resource);</span><br><span class="line">    String layout = res.getResourceEntryName(resource);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Class clazz = Class.forName(&quot;&quot; + pkg + &quot;.CompiledView&quot;, false, mPrecompiledClassLoader);</span><br><span class="line">        Method inflater = clazz.getMethod(layout, Context.class, int.class);</span><br><span class="line">        // 反射获取到view</span><br><span class="line">        View view = (View) inflater.invoke(null, mContext, resource);</span><br><span class="line"></span><br><span class="line">        // 如果root存在，则解析布局参数并且判断是否应该将view添加到root，只有root存在时这个布局参数才有意义，否则直接就是返回一个单纯不带布局参数的view给调用方</span><br><span class="line">        if (view != null &amp;&amp; root != null) &#123;</span><br><span class="line">            XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">            try &#123;</span><br><span class="line">                AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">                advanceToRootNode(parser);</span><br><span class="line">                ViewGroup.LayoutParams params = root.generateLayoutParams(attrs);</span><br><span class="line">                if (attachToRoot) &#123;</span><br><span class="line">                    // 将view添加到root容器</span><br><span class="line">                    root.addView(view, params);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 给view设置布局参数，此时view还未有任何父容器</span><br><span class="line">                    view.setLayoutParams(params);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                parser.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return view;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Failed to use precompiled view&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是Android10开始的一个编译优化，可将可将xml预编译成dex，然后通过反射生成对应的View，从而减少XmlPullParser解析Xml的时间。截止到目前Android版本33为止预编译这段都是废话，因为追溯<code>mUseCompiledView</code>这个开关发现一直都是关着的。即使是打开了也将是个坑，本来inflater的返回值因为root和attachToRoot参数就已经可能产生返回父view和返回xml对应的布局view这两种情况了，而如果加入了预编译选项就不关心root和attachToRoot直接返回xml对应的布局view，更是增加的开发者使用时的不确定性。所以等后续功能放开时再来关注。</p>
<h3 id="Fragment中使用InflaterLayout报错复盘"><a href="#Fragment中使用InflaterLayout报错复盘" class="headerlink" title="Fragment中使用InflaterLayout报错复盘"></a>Fragment中使用InflaterLayout报错复盘</h3><p>知识点介绍完了来看看刚才在<code>Fragment-&gt;onCreateView</code>中使用<code>inflater.inflate(R.layout.fragment_me, container)</code>为什么会报错吧。<br>首先我们知道了<code>inflater.inflate(R.layout.fragment_me, container)</code>的话container不为空，则默认fragment_me对应的布局是需要加入到container中的，此时返回的是父view。此时这个父view正是我们在Activity中指定的Fragment的容器，比如我这边指的是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transaction.add(R.id.f_me, meFragment)//动态添加</span><br></pre></td></tr></table></figure>
<p>此时这个f_me已经存在父view了，所以我们看下<code>Fragment-&gt;onCreateView</code>返回的这个父view在哪里被使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fragment.java</span><br><span class="line"></span><br><span class="line">void performCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,</span><br><span class="line">        @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mView = onCreateView(inflater, container, savedInstanceState);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Fragment源码中，<code>performCreateView</code>时会将<code>onCreateView</code>的返回值赋值给<code>mView</code>对象。</p>
<p>再回到报错的堆栈中<code>at androidx.fragment.app.FragmentStateManager.addViewToContainer(FragmentStateManager.java:840)</code>,查看源码可以看出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void addViewToContainer() &#123;</span><br><span class="line">    int index = mFragmentStore.findFragmentIndexInContainer(mFragment);</span><br><span class="line">    mFragment.mContainer.addView(mFragment.mView, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时mFragment.mView就是我们在Activity中指定的Fragment容器f_me,它已经存在父容器了所以再被添加的话就报错了！</p>
<h3 id="LayoutInflater总结"><a href="#LayoutInflater总结" class="headerlink" title="LayoutInflater总结"></a>LayoutInflater总结</h3><ol>
<li>infalte()中root为空则返回的是xml布局对应的view，此时view没有任何布局参数，也并未被添加到容器中</li>
<li>infalte()中root不为空，则判断attachToRoot&#x3D;&#x3D;true返回的是root，attachToRoot&#x3D;&#x3D;false返回的是xml布局对应的view，和第1点一样</li>
<li>如果inflate传递的资源id是个merge标签，则root不能为空，attachToParent必须是true，对应的merge下的view会被添加到root容器中</li>
<li>Activity、Fragment、Service中系统已经为你提供了一个LayoutInflater对象，不需自己创建。并且Activity-&gt;setContentView()方法最终也是通过InflaterLayout来实现的布局加载</li>
<li>牢记方法2的实现：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;</span><br><span class="line">    return inflate(resource, root, root != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android小知识-HandlerThread</title>
    <url>/2022/07/27/Android%E5%B0%8F%E7%9F%A5%E8%AF%86-HandlerThread/</url>
    <content><![CDATA[<h3 id="线程间通信常规操作"><a href="#线程间通信常规操作" class="headerlink" title="线程间通信常规操作"></a>线程间通信常规操作</h3><p>Android线程间通信主要方式是使用Handler相信没有一个做Android的人不知道。<br>如果对Handler还不了解可以回顾一下我以前的文章：<a href="http://lianwenhong.top/2022/03/25/Android%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9AHandler%E7%9A%84%E7%90%86%E8%A7%A3/">Android中多线程通信：Handler的理解</a></p>
<p>注： 后续称HandlerThread创建的线程为<strong>HandlerThread线程</strong>，调用HandlerThread.getLooper()的线程成为<strong>调用线程</strong></p>
<h3 id="HandlerThread用法"><a href="#HandlerThread用法" class="headerlink" title="HandlerThread用法"></a>HandlerThread用法</h3><p>如果你在开发android项目时想实现一个带消息队列的子线程，那我建议你不要重复造轮子，你可以看看HandlerThread这个类，它就是系统封装好的一个很好用的带消息队列的子线程。<br>HandlerThread能解决以下几件事情：</p>
<ol>
<li>实现带消息队列的子线程，可用它来做耗时操作。</li>
<li>可实现线程间通信。</li>
<li>可实现线程的线程的复用避免了线程频繁创建销毁带来的开销。</li>
</ol>
<p><strong>简单概括就是HandlerThread继承自Thread，在HandlerThread这个线程启动的时候其内部run()方法中创建并初始化了该线程的Looper，并且在初始化Looper和使用Looper的阶段通过synchronized同步锁的方式保证了Looper的准确性。该类通过系统的消息轮训器Looper来实现消息队列以及实现线程的复用，其内部也提供了关闭子线程的方法以便开发者可以在自己想要的场景下开启子线程或者关闭子线程。</strong></p>
<p>其实HandlerThread只是系统对子线程开发需求的一个小封装而已，但是我个人觉得挺实用的。先来看它的使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    private HandlerThread handlerThread;</span><br><span class="line">    Handler handler;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button start = findViewById(R.id.id_btn_begin);</span><br><span class="line">        start.setOnClickListener(this);</span><br><span class="line">        Button send = findViewById(R.id.id_btn_send);</span><br><span class="line">        send.setOnClickListener(this);</span><br><span class="line">        Button finish = findViewById(R.id.id_btn_finish);</span><br><span class="line">        finish.setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建HandlerThread子线程和Handler消息处理器</span><br><span class="line">    public void startThread() &#123;</span><br><span class="line">        count = 0;</span><br><span class="line">        handlerThread = new HandlerThread(&quot;my-thread&quot;) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void onLooperPrepared() &#123;</span><br><span class="line">                super.onLooperPrepared();</span><br><span class="line">                Log.e(&quot;lianwenhong&quot;, &quot; &gt;&gt;&gt; onLooperPrepared &lt;&lt;&lt; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        handlerThread.start();// 必须先执行start()之后再来执行handlerThread.getLooper();，否则得到的Looper对象永远是null</span><br><span class="line">        // 创建handler时传入HandlerThread的Looper对象，后续通过这个handler对象发送的消息都会被放在handlerThread线程中执行</span><br><span class="line">        handler = new Handler(handlerThread.getLooper()) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleMessage(@NonNull Message msg) &#123;</span><br><span class="line">                super.handleMessage(msg);</span><br><span class="line">                switch (msg.what) &#123;</span><br><span class="line">                    case 1:</span><br><span class="line">                        Log.e(&quot;lianwenhong&quot;, &quot; &gt;&gt;&gt; handle 1&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    case 2:</span><br><span class="line">                        Log.e(&quot;lianwenhong&quot;, &quot; &gt;&gt;&gt; handle 2&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        Log.e(&quot;lianwenhong&quot;, &quot; &gt;&gt;&gt; handle default&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当有需要在子线程中处理的逻辑就通过消息发送给子线程，此时消息会进入HanderThread线程中的消息队列</span><br><span class="line">    public void sendMessage() &#123;</span><br><span class="line">        Message msg1 = handler.obtainMessage(++count);</span><br><span class="line">        handler.sendMessage(msg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void finishThread() &#123;</span><br><span class="line">        handlerThread.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        switch (v.getId()) &#123;</span><br><span class="line">            case R.id.id_btn_begin:</span><br><span class="line">                startThread();</span><br><span class="line">                break;</span><br><span class="line">            case R.id.id_btn_send:</span><br><span class="line">                sendMessage();</span><br><span class="line">                break;</span><br><span class="line">            case R.id.id_btn_finish:</span><br><span class="line">                finishThread();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是HanderThread的使用方式：</p>
<ol>
<li>创建一个HandlerThread对象，并且开启它。</li>
<li>创建一个Handler，给Handler传入HandlerThread的Looper对象，复写handleMessage方法</li>
<li>向2中的Handler对象发送Message时，该消息对应的事件会在HandlerThread线程中执行。</li>
</ol>
<h3 id="HandlerThread原理"><a href="#HandlerThread原理" class="headerlink" title="HandlerThread原理"></a>HandlerThread原理</h3><p>handlerThread原理不难，总的代码也才100多行，咱们来撸一遍：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HandlerThread extends Thread &#123;</span><br><span class="line">    int mPriority;</span><br><span class="line">    int mTid = -1;</span><br><span class="line">    Looper mLooper;</span><br><span class="line">    private @Nullable</span><br><span class="line">    Handler mHandler;</span><br><span class="line"></span><br><span class="line">    public HandlerThread(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 没什么特别，只是设置了一下线程的优先级为默认优先级</span><br><span class="line">     */</span><br><span class="line">    public HandlerThread(String name, int priority) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是一个回调表示该线程的Looper已经准备就绪，此时开发者可以在收到这个回调时做一些初始化工作</span><br><span class="line">     */</span><br><span class="line">    protected void onLooperPrepared() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        // 此处使用synchronized加锁是确保调用线程执行handlerThread.getLooper()获取mLooper对象时mLooper已经被正确赋值了</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回handlerThread所关联的Looper，如果handlerThread线程已经死亡则返回null</span><br><span class="line">     * 如果handlerThread线程未执行过start()方法的话就会阻塞调用线程</span><br><span class="line">     *</span><br><span class="line">     * @return The looper.</span><br><span class="line">     */</span><br><span class="line">    public Looper getLooper() &#123;</span><br><span class="line">        // 如果handlerThread线程未启动或已经死亡，则返回null</span><br><span class="line">        if (!isAlive()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean wasInterrupted = false;</span><br><span class="line"></span><br><span class="line">        // If the thread has been started, wait until the looper has been created.</span><br><span class="line">        // 获取Looper时首先要确保线程已经启动并且mLooper已经赋值成功，否则将会返回null导致传递给Handler时会抛出java.lang.NullPointerException:</span><br><span class="line">        // Attempt to read from field &#x27;android.os.MessageQueue android.os.Looper.mQueue&#x27; on a null object reference异常</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            while (isAlive() &amp;&amp; mLooper == null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 调用线程与handlerThread并不处于同一个线程，所以并不能保证当执行handlerThread.getLooper时handlerThread线程中mLooper已经赋值完毕。</span><br><span class="line">                    // 所以如果mLooper还未赋值成功时就执行wait()阻塞调用线程并释放锁对象，直到handlerThread线程获取到执行权并且对mLooper赋值完成之后handlerThread线程</span><br><span class="line">                    // 会通过notifyAll()来通知正在wait()的调用线程，此时调用线程就可以得到正确的mLooper对象而不是空</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    wasInterrupted = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 如果线程还未来得及被notify就收到了中断请求则直接中断调用线程</span><br><span class="line">         */</span><br><span class="line">        if (wasInterrupted) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    public Handler getThreadHandler() &#123;</span><br><span class="line">        if (mHandler == null) &#123;</span><br><span class="line">            mHandler = new Handler(getLooper());</span><br><span class="line">        &#125;</span><br><span class="line">        return mHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 退出Looper消息循环</span><br><span class="line">     * 如果队列中还有未执行的消息，那么不管是延时还是非延时的消息统一抛弃并停止Looper消息循环</span><br><span class="line">     */</span><br><span class="line">    public boolean quit() &#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        if (looper != null) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 退出Looper消息循环</span><br><span class="line">     * 如果队列中还有延时任务未执行则将延时任务全部清除，也就是说延时任务直接被抛弃得不到执行</span><br><span class="line">     * 如果队列中还有非延时任务未执行则会一直等到所有非延时任务都得到执行之后才真正停止Looper消息循环</span><br><span class="line">     *</span><br><span class="line">     * @return True if the looper looper has been asked to quit or false if the</span><br><span class="line">     * thread had not yet started running.</span><br><span class="line">     */</span><br><span class="line">    public boolean quitSafely() &#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        if (looper != null) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回线程id</span><br><span class="line">     */</span><br><span class="line">    public int getThreadId() &#123;</span><br><span class="line">        return mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的注释已经很详细的说明了HandlerThread的原理，结合它的使用方式看源码应该是一目了然了。</p>
<h4 id="有几个点需要强调的："><a href="#有几个点需要强调的：" class="headerlink" title="有几个点需要强调的："></a>有几个点需要强调的：</h4><ol>
<li>必须先调用HandlerThread.start()再去获取HandlerThread线程所关联的Looper对象(getLooper())，否则在未调用HandlerThread.start()之前调用HandlerThread.getLooper()得到的永远是null</li>
<li>从run()和getLooper()方法中的synchronized逻辑可以看出来，调用线程在执行HandlerThread.getLooper()时有可能会发生阻塞，不过这个阻塞时长应该很短，只需了解这一点就行。阻塞是因为如果是HandlerThread线程run()方法还没执行到synchronized代码块时HandlerThread线程就失去cpu执行权那么假设此时cpu执行权被调用线程拿到并且执行到HandlerThread.getLooper()中的同步代码块，那么调用线程将被阻塞知道run()中同步代码块执行完毕。</li>
<li>因为Looper消息队列是串行一条一条执行的，所以太过耗时的消息势必会影响后续的消息处理（假设加入队列的消息有A、B两个，A消息历时10s才完成那么B消息得到执行必然是在10s之后）。这点在业务开发中要自行斟酌，例如网络请求是一种不可预测的大耗时操作，不建议放在HandlerThread中来执行，而简单的文件读写一般是毫秒级的，可以放在HandlerThraed中。其实不光是HandlerThread有这个问题，任何消息单任务执行的队列都有这个问题。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android中多线程通信：Handler的理解</title>
    <url>/2022/03/25/Android%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9AHandler%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>Android中Handler在我理解主要是为了解决线程间通信。</p>
<h2 id="Handler机制组成"><a href="#Handler机制组成" class="headerlink" title="Handler机制组成"></a>Handler机制组成</h2><pre><code>使用Android的Handler机制主要要了解几个类：
</code></pre>
<ul>
<li><strong>Looper</strong>：<br>  一个线程对应一个或者0个Looper，主线程在ActivityThread的时候会默认创建一个Looper，非主线程中需要先通过Looper.prepare()创建，并且通过Looper.loop()开启。</li>
<li><strong>Message</strong>：<br>  线程间通信的消息载体，Handler利用Message来携带信息给另一个线程，内部包含一个叫sPool的单向链表结构消息缓存池，使用享元模式实现消息的复用防止内存抖动。</li>
<li><strong>MessageQueue</strong>：<br>  消息队列，与Looper一一对应，每个Looper中维护一个消息队列，此消息队列是一个时间优先级队列，内部是一个单向链表</li>
<li><strong>Handler</strong>：<br>  有点像是一个工厂里的机器人，不断从这个线程中发送Message或者是Runnable给另一个线程，并放入MessageQueue中</li>
</ul>
<p>所以以上是Handler机制的主要4个要素，每个要素之间的关系很清晰明了：<strong>Handler为生产者，Looper为消费者，MessageQueue为容器，而Message为具体的消息载体。</strong></p>
<span id="more"></span>

<h2 id="Handler使用"><a href="#Handler使用" class="headerlink" title="Handler使用"></a>Handler使用</h2><p>如果对Handler还不够熟悉可以看下这2篇文章先熟悉Handler使用：<br><a href="https://blog.csdn.net/androidsj/article/details/79816866">Handler实现子线程与子线程、主线程之间通信</a><br><a href="https://blog.csdn.net/qq_21556263/article/details/82759061">Handler完全解读——Handler的使用</a></p>
<h2 id="Handler运行原理"><a href="#Handler运行原理" class="headerlink" title="Handler运行原理"></a>Handler运行原理</h2><p>要深入理解Handler机制我们首先从几个着力点出发<br><strong>1.Handler怎么创建的<br>2.Handler调用sendMessage的时候发生了什么<br>3.Looper与线程是什么关系<br>4.Looper.prepare(),Looper.loop()做了些什么事情，为什么如果不执行prepare会报错等。<br>5.Handler是如何保证多个线程跟同一个线程进行通信时的准确性</strong></p>
<p>首先从创建一个Handler的的时候构造方法来看，所有构造方法总共有3种参数：<br>Callback：是一个只有handleMessage的接口，是事件处理的回调，可有可无，后面说<br>async：是同步消息还是异步消息，这与同步屏障有关，后面说，一般我们都是发的同步消息<br>Looper：该handler对象所要处理的线程对应的Looper对象，也就是说该Handler的执行都是在looper对应的线程中的</p>
<p>线程分为有消息队列和没有消息队列两种，没有消息队列则线程启动完成执行完操作就结束了 ，而有消息循环队列的时候，线程可以通过循环调度消息队列的方式来执行消息队列中的每一个任务，Android中使用Handler进行线程间通信时，Handler必须指定要通信线程所持有的Looper。<br>准确的说，其实是Handler需要做的事情是向要通信的线程所持有的消息队列中加入任务。   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Handler</span>&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//这里就是在子线程使用Handler的时候常遇到的异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你在Handler构造函数中没有指定Looper，那么调用Looper.myLooper()句柄来获取当前线程所对应的Looper，如果这时该线程还未初始化Looper对象，这时就会抛出一个异常， 这就是为什么在子线程时我们创建Handler前需要先调用Looper.prepare()方法的原因。<br>跟进Looper.myLooper()看一下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用Looper.myLooper我们看到其实是从sThreadLocal变量中get一个Looper对象，这样就确保了每个线程都对应了一个Looper，而每个Looper中拥有一个MessageQueue，这样就实现了线程-Looper-MessageQueue这3个部分一一对应的关系。如果对ThreadLocal不熟悉的话可以百度一下，或者等我有空我会更新一篇文章。</p>
<p>既然已经知道了线程-Looper-MessageQueue是一一对应的关系，想与某一线程进行通信只需将消息加入到该线程对应的MessageQueue中就能实现，那么我们看下Looper与MessageQueue做了些什么东西。</p>
<p>Looper.prepare():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">	prepare(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//quitAllowed表示该Looper所对应的消息队列是否可退出，具体的退出在Looper.quit()方法里</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">//表示该线程对应的Looper对象已存在，不能重复调用prepare()，否则就抛异常</span></span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以调用prepare()时是创建Looper实例，看下构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">	<span class="comment">//创建消息队列</span></span><br><span class="line">	mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">	mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以到这里，线程持有了一个Looper对象，Looper对象中持有了一个MessageQueue队列，一对一。<br>紧接着消息队列有了，需要让队列开始运作起来，就好比流水线一样，需要轮训这个队列取出消息来执行。而消息的添加是在Handler的sendMessage中我们一会儿再说<br>Looper.loop():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">	<span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">//在这里又判断了一下Looper.prepare()是否调用。</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">	<span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">	Binder.clearCallingIdentity();</span><br><span class="line">	<span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//此处开启一个无限循环，只有当msg == null时才会退出，</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">//调用MessageQueue内部的next()方法，此方法在消息队列为空的时候会执行线程阻塞，阻塞原理是使用Linux的epoll实现的</span></span><br><span class="line">		<span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">		<span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">		    <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">		    <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		...	</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//调用handler的dispatchMessage方法来处理消息，最后真正执行到handler的handleMessage()</span></span><br><span class="line">			msg.target.dispatchMessage(msg);</span><br><span class="line">		    ...</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">		    <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">		        observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">throw</span> exception;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		    ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">		    <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">		        Trace.traceEnd(traceTag);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">//使用享元模式来将该Message对象还原并放回消息池中以便将来复用减少内存抖动，具体实现在Message中</span></span><br><span class="line">		msg.recycleUnchecked();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>省略部分与主流程关系不大的代码，我们看下注释中的各个方法</p>
<p>首先在loop()时也会做一遍prepare()的调用校验，因为在开启消息队列之前必然是要确保Looper和消息队列已存在，否则一切都是空谈。</p>
<p>紧接这开启了一个无限循环，只有在消息为空的时候才把该循环退出表示该线程的MessageQueue已经不再需要。</p>
<p>在queue.next();方法中，如果取不到消息的话，会执行Linux的epoll方法来阻塞住当前线程，以便有消息被加入到消息队列时能获取到并执行的同时，在没消息的时候又不会让线程一直在做无用的轮训消耗性能。<br>可能我们会不理解的是，上面明明说没有消息的时候会退出for循环这里又说会阻塞，这是怎么回事？<br>其实是这样的，首先我们要确保一个线程的MQ一直在等着消息进来从而执行消息，而如果直接在取不到的时候直接结束消息队列的循环显然是不符合的。那么底层的实现就是首先先把线程阻塞住等待消息加入，而什么时候会唤醒线程呢，1个是当消息被加入到MQ的时候，一个是当调用了quit()来表示此轮训机制已不再需要的时候。所以for循环里的msg &#x3D;&#x3D; null这个判断其实针对的就是第2种情况。</p>
<p>如果成功取到了一个消息，那么就去执行它，就调用dispatchMessage()方法最终会调用到Handler的handleMessage()方法。<br>这里思考一下，通过handler调用sendMessage()，而从MQ中取出消息的时候，怎么能定位到发送消息的handler中去执行处理呢？其实这里就是通过Message这个载体把发送消息的Handler保存起来，也就是这个target！！！</p>
<p>MessageQueue.next()是如何取消息的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">		<span class="comment">//Linux的epoll实现阻塞的入口</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">		<span class="comment">//通过加锁保证多线程出队的正确性，因为一个Handler可以处理多个线程中的消息</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="comment">//表示这是个同步屏障，同步屏障与普通消息的区别是同步屏障的target是null</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                    <span class="comment">//寻找异步消息来返回</span></span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    <span class="comment">//如果这个消息的执行时间还没到，那就不做其他操作，因为这里是无限循环，所以会一直轮训直到时间到</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="comment">//取出符合条件的第一个消息返回</span></span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上在MQ中实现了消息的获取。</p>
<p>看完Looper以及取消息的实现，我们再来看下我们sendMessage()的时候内部做了些什么处理，怎么与Looper中的逻辑关联上的</p>
<p>当调用sendMessage之后，其实最终是调用到以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//upTimeMillis是参数是延迟执行的时间，例如当postDelayed的时候可以指定一个延迟时间一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">	<span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">	 <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">	     <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">	             <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">	     Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">	     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">//此时的uptimeMillis=SystemClock.uptimeMillis() + delayMillis</span></span><br><span class="line">	 <span class="comment">//意思是当前系统时间加上开发者传入的所需要延迟的时间</span></span><br><span class="line">	 <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着调用到MQ中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">    <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line">	<span class="comment">//此处指定该消息为异步消息，异步消息一会儿讲同步屏障的时候再说</span></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入MQ中的入队操作</span></span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MessageQueue中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">	<span class="comment">//如果没有指定target则不入队抛出异常，其实这里一个是为了后续能定位出需要处理消息的Handler，也为了与同步屏障消息区分开了（这个后说）</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果这个消息已经在入队等待处理往后的流程，那这个消息不能被重复使用直到该消息执行完毕</span></span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//因为同一个线程可以与无数个线程进行通信，所以在入队和出队都必须保证同步</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    	<span class="comment">//如果正在执行退出操作（也就是Looper.quit()），则不再入队新消息</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="comment">//1.如果队列中还没有消息，则添加队列头并唤醒线程去执行轮训那一套流程取出消息并执行</span></span><br><span class="line">        <span class="comment">//2.消息需要立刻执行，则也是唤醒线程执行消息</span></span><br><span class="line">        <span class="comment">//3.消息需要执行的时间点比队头消息时间小，那么表示这个消息需要先执行，也执行唤醒执行消息</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            <span class="comment">// 除非队头消息是同步屏障，并且消息是队列中最早的异步消息。否则都不唤醒线程</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                	<span class="comment">//这一段的操作在此处退出，目的是将添加进来的消息按时间先后顺序插入到合适的位置。</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里屏蔽掉同步屏障消息，也就是说加入一个同步屏障时，不需要唤醒线程</span></span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将消息入队到链表中合适位置</span></span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">        	<span class="comment">//唤醒线程</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Handler小结"><a href="#Handler小结" class="headerlink" title="Handler小结"></a>Handler小结</h2><p>看到这里我们的整个流程已经清晰了。<br><strong>1.Looper.prepare()创建消息队列并将线程–Looper–MessageQueue进行一一对应</strong></p>
<p><strong>2.Looper.loop()开始消息队列循环并通过一套阻塞机制来实现队列的等待以及取消息。最终调用调用MQ.next()，并在无消息时阻塞线程</strong></p>
<p><strong>3.通过Handler.sendMessageAtTime()方法发送一个消息，最终调用到MQ.enqueueMessage()方法来将消息入队，并在入队成功唤醒线程</strong></p>
<p><strong>4.Looper.quit()方法实现退出Handler机制，通过唤醒线程并且往下执行让msg &#x3D;&#x3D; null来实现让Looper.loop()中的无限循环退出。</strong></p>
<p>看完整个流程，开头的5个疑问已全部解决。</p>
<h2 id="深入思考："><a href="#深入思考：" class="headerlink" title="深入思考："></a>深入思考：</h2><p><strong>1.在主线程中我们没有手动调用过Looper.prepare()方法，却也没见有什么问题?<br>2.什么是同步消息什么是异步消息？<br>3.什么是同步屏障，同步屏障的使用场景是什么？<br>4.我们postDelayed()指定延迟时间时，一定会在指定的延迟时间之后执行吗？</strong><br>问题1:<br>    原因在于那是因为在主线程中Google已经帮我们做了这些操作，不信看看整个Android应用程序的主入口：ActivityThread的main()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install selective syscall interception</span></span><br><span class="line">    AndroidOs.install();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">configDir</span> <span class="operator">=</span> Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line">	<span class="comment">//执行Looper初始化</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line">    <span class="comment">// It will be in the format &quot;seq=114&quot;</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startSeq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] != <span class="literal">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                startSeq = Long.parseLong(</span><br><span class="line">                        args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">LogPrinter</span>(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="comment">//开启Looper循环</span></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题2:<br>    在Handler机制中区分同步消息或者异步消息其实主要是根据Message.setAsynchronous()方法来设置的，设置true为异步消息，false为同步消息，默认我们创建的都是同步消息。<br>    如何使用Handler发送同步消息或者异步消息，通过Handler的构造函数可以指定async为true来实现，默认是false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    <span class="comment">//指定向该handler中发送的消息类型</span></span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题3:<br>    同步屏障是一个target &#x3D; null的Message，Handler机制通过这个方式来区分出同步屏障消息，同步屏障消息并没有真正的执行逻辑，只是为了让异步消息得到更优先的执行。当轮训消息队列的时候碰上同步屏障，则一直往后寻找最早的异步消息来执行。如果没有异步消息就阻塞指导有异步消息被加入队列或者同步屏障被移除为止。同步屏障发送的代码已被hint，如果需要调用则需要反射实现。</p>
<pre><code>MQ中发送同步屏障的方法：
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">(<span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>MQ中移除同步屏障的方法：
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeSyncBarrier</span><span class="params">(<span class="type">int</span> token)</span> &#123;</span><br><span class="line">    <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">    <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; (p.target != <span class="literal">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The specified message queue synchronization &quot;</span></span><br><span class="line">                    + <span class="string">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            needWake = mMessages == <span class="literal">null</span> || mMessages.target != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步屏障具体开发过程中使用较少，大都是在系统层渲染时使用，如需了解以下是几个链接我觉得说的不错：<br><a href="https://blog.csdn.net/start_mao/article/details/98963744">Handler机制——同步屏障</a><br><a href="https://blog.csdn.net/cpcpcp123/article/details/115374057">handler的同步屏障使用场景</a></p>
<p>问题4:<br>    不一定，因为我们消息入队的时间是系统加上当前时间来入队，只是一个相对顺序，消息的执行是串行的，所以必须等上一个消息执行结束才能取出下一个，所以真正的执行时间其实受多个因素影响，1个是前面消息执行的时长，2是如果遇到同步屏障把同步消息阻塞住了，那同步消息执行时间就必须还得依赖同步屏障移除时间。所以，postDelayed只是个相对性的时间并不能达到准确。</p>
<p>最后还有一个小细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Handler的处理消息方法可以看出，处理消息时优先判断是否有callback。所以如果创建Handler的时候指定了Callback，那处理消息的时候执行的是Callback的handleMessage</p>
<p>以上是我对Handler的全部理解，最后附上一篇Handler的面试问题供日后翻阅：<br><a href="https://www.jianshu.com/p/3063c4ab40bd">Handler面试题汇总</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android序列化之Parcel</title>
    <url>/2022/06/08/Android%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BParcel/</url>
    <content><![CDATA[<p>Android操作系统的底层数据传输形式是简单的字节序列形式进行传递。用通俗的话说就是系统不认识对象，只认识字节序列。而我们为了达到通信或者存储的目的，需要先将数据序列化传递，要使用时再进行反序列化还原。</p>
<h3 id="Android中有2种方式可以实现序列化和反序列化："><a href="#Android中有2种方式可以实现序列化和反序列化：" class="headerlink" title="Android中有2种方式可以实现序列化和反序列化："></a>Android中有2种方式可以实现序列化和反序列化：</h3><ol>
<li>Serializable：Java自带的接口，实现该接口就可以将对象序列化。</li>
<li>Parcelable：Android独有的接口，性能优于Serializable。原理是将一个完整的对象进行分解(拍扁)，分解后的每一部分都是Intent所支持的数据类型。</li>
</ol>
<h4 id="二者区别是什么呢？"><a href="#二者区别是什么呢？" class="headerlink" title="二者区别是什么呢？"></a>二者区别是什么呢？</h4><ul>
<li>Serializable使用IO读写将序列化对象存储在硬盘上，读写速度慢；序列化过程中使用了反射技术所以会产生很多临时对象，占用空间大。但是它的优点是编码方便，开发者只需要实现Serializeable，对象就拥有了序列化和反序列化能力。</li>
<li>Parcelable是直接再内存中进行读写，内存读写速度优于硬盘读写，所以这种方式的性能比Serializable高，缺点是编码比Serializable方式更麻烦。</li>
</ul>
<h4 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h4><ul>
<li>如果仅仅是在内存中使用，比如Activity、Service间传递信息，那强烈建议使用Parcelable，因为Parcelable比Serializable性能高，并且Serializable在序列化时会产生大量临时变量从而引起频繁GC。</li>
<li>如果是持久化操作，推荐使用Serializable，虽然效率比较低但是因为再外界有变化的情况下，Parcelable不能很好的保存数据的持续性。</li>
</ul>
<h4 id="为什么Android中进程之间的复杂数据类型传递需要序列化"><a href="#为什么Android中进程之间的复杂数据类型传递需要序列化" class="headerlink" title="为什么Android中进程之间的复杂数据类型传递需要序列化"></a>为什么Android中进程之间的复杂数据类型传递需要序列化</h4><p>我们知道Android系统是基于Linux系统实现的，而Linux有进程隔离的机制。而进程如果传递复杂数据类型那传递的是对象的引用，本质上就是一个内存地址。但是传递内存地址的方式在跨进程中明显不行，由于Linux采用了虚拟内存机制，两个进程都有自己独立的内存地址空间，所以把A进程中某个对象的内存地址传递给B进程，这个内存地址在两个进程中映射到的物理内存地址并不是同一个，所以就得依靠上述的序列化手段来将对象的字节序列传递才能实现通信。而对于基本数据类型，只需要通过IPC通信不断复制达到目标进程即可。</p>
<h4 id="Parcel用于IPC"><a href="#Parcel用于IPC" class="headerlink" title="Parcel用于IPC"></a>Parcel用于IPC</h4><blockquote>
<p>Container for a message (data and object references) that can be sent through an IBinder. A Parcel can<br>contain both flattened data that will be unflattened on the other side of the IPC (using the various<br>methods here for writing specific types, or the general Parcelable interface), and references to<br>live IBinder objects that will result in the other side receiving a proxy IBinder connected with the<br>original IBinder in the Parcel.<br>Parcel is not a general-purpose serialization mechanism. This class (and the corresponding Parcelable API<br>for placing arbitrary objects into a Parcel) is designed as a high-performance IPC transport. As such,<br>it is not appropriate to place any Parcel data in to persistent storage: changes in the underlying<br>implementation of any of the data in the Parcel can render older data unreadable.</p>
</blockquote>
<p>Parcel是盛放消息的容器，是接住Binder机制来进行数据传输的。它可以携带序列化后的数据通过IPC传输后在目的端进行反序列化。</p>
<p>Parcel也可以传递IBinder对象，在目的端将接受到传输的IBinder对象的代理。</p>
<p>Parcel不适合用于持久性存储，因为Parcel中任何数据的基础实现的更改都可能导致旧值不可用。并且其是在内存中实现，内存中持久化数据不可靠。</p>
<img src="/2022/06/08/Android%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BParcel/Parcel%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE.jpg" class="" title="Parcel进程间传递数据">

<ul>
<li>从Android系统层面来说，Android系统中的Binder机制实现的IPC就使用Parcel类来进行客户端与服务端的数据交互。并且在Java层和cpp层都实现了Parcel（通过JNI关联）。由于它在c&#x2F;cpp中直接使用了内存来读取数据，因此效率更高。</li>
<li>从存储的角度来说，Parcel只是一块连续的内存。会根据需要自动扩展大小。</li>
</ul>
<p>Parcel传输数据类型：</p>
<blockquote>
<p><strong>基本数据类型：</strong> 借助Parcel-&gt;writePrimitives()将基本数据类型从用户空间(源进程)copy到kernel空间(Binder驱动中)再写回用户空间(目标进程，binder驱动负责寻找目标进程)</p>
</blockquote>
<blockquote>
<p><strong>复杂数据类型：</strong> 将经过序列化的数据借助Parcel-&gt;writeParcelable()&#x2F;writeSerializable()从用户空间(源进程)copy到kernel空间(binder驱动中)再写回用户空间(目标进程，binder驱动负责寻找目标进程)，然后再进行反序列化。</p>
</blockquote>
<blockquote>
<p><strong>大数据：</strong> 通过Parcel-&gt;writeFileDescriptor()通过Binder传递匿名共享内存(Ashmem)的FileDescriptor从而达到传递匿名共享内存的方式，即传递的是FileDescriptor而不是真正的大数据。参考<a href="https://zhuanlan.zhihu.com/p/92769131">Android 匿名共享内存的使用</a></p>
</blockquote>
<blockquote>
<p><strong>IBinder对象：</strong> 通过调用Parcel-&gt;writeStrongBinder()，经由kernel binder驱动专门处理来完成IBinder传递。目标进程收到的是IBinder对象的代理。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>binder</tag>
      </tags>
  </entry>
  <entry>
    <title>Android源码解析-App的ClassLoader</title>
    <url>/2022/04/14/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-App%E7%9A%84ClassLoader/</url>
    <content><![CDATA[<h2 id="Android中的默认类加载器："><a href="#Android中的默认类加载器：" class="headerlink" title="Android中的默认类加载器："></a>Android中的默认类加载器：</h2><p>Android虚拟机就是一个特殊的JVM，不管是以前的dalvik还是现在的ART。所以其类加载流程一样遵循jvm的规则（双亲委托机制）</p>
<p>如果对jvm的类加载流程不熟悉可以阅读另一篇文章：<a href="http://lianwenhong.top/2022/04/16/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-ClassLoader%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#more">java类加载原理(ClassLoader工作原理)</a></p>
<p>Android类加载器之相较于Java类加载器的最大区别在于：</p>
<p>java类加载器是从某个目录中去直接加载.class文件或者是从目录下的zip、jar包等归档文件中加载.class文件</p>
<p>而Android类加载器是从某个目录下去直接加载.dex文件或者是从目录下的zip、jar、apk等文件中的.dex文件中去加载.class文件，如果不是.dex文件的话加载不了。</p>
<span id="more"></span>

<img src="/2022/04/14/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-App%E7%9A%84ClassLoader/Android%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" class="" title="Android默认类加载器关系图">

<p>以上类关系图清楚的描述了Android中的默认类加载器以及它们的父子关系。<br>图中有涉及到了DexPathList这个类简单来说是存放该类加载器的加载区域中的所有dex文件，在Android的插件化方案和热修复方案中经常会使用将补丁包或者插件包中的dex插入这个数组的第一个来实现热修复或者加载插件的功能。具体详情可看另一个文章：<a href="http://lianwenhong.top/2022/04/13/android%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%B0%8F%E8%AE%B0/#more">android热修复小记</a></p>
<h2 id="app中的类加载器"><a href="#app中的类加载器" class="headerlink" title="app中的类加载器"></a>app中的类加载器</h2><p>在Android开发中例如在Activity中会调用getClassLoader()来获取类加载器，这时候这个类加载器是怎么来的呢？来分析一下</p>
<p>Activity类中并没有getClassLoader()，从继承关系上可以知道最终调用的是<code>ContextWrapper.getClassLoader()</code>，最终的实现在<strong>ContextImpl</strong>中。如果不知道的话可以看下我另外一篇文章：<a href="http://lianwenhong.top/2022/03/29/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-Context%E8%A7%A3%E6%9E%90/#more">Android源码小记-Context解析</a>，可以清楚了解Context的继承关系以及Activity和Context之间是如何关联以及与ContextImpl之间的联系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ContextImpl.java</span><br><span class="line"></span><br><span class="line">public ClassLoader getClassLoader() &#123;</span><br><span class="line">    return mPackageInfo != null ?</span><br><span class="line">            mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个mPackageInfo对象是一个LoadedApk，持有apk的所有信息，是apk在内存中的表现形态。（<a href="http://lianwenhong.top/2022/04/14/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-LoadedApk/">ANdroid源码小记-LoadedApk</a>）,而它是在构造ContextImpl的时候传进来并赋值的。</p>
<p>在启动Activity时，最终会走ActivityThread中的handleLaunchActivity()方法，这个方法里就会最终调用到先知性Instrumentation.newActivity()通过类加载器创建一个Activity实例，然后调用createBaseContextForActivity()去创建一个处理提供Activity运行环境的ContextImpl，此时就会给mPackageInfo赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123;</span><br><span class="line">    int displayId = Display.DEFAULT_DISPLAY;</span><br><span class="line">    try &#123;</span><br><span class="line">        displayId = ActivityManagerNative.getDefault().getActivityDisplayId(r.token);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建提供Activity运行环境的ContextImpl用于之后attach给Activity，此时传入的LoadedApk是r.packageInfo</span><br><span class="line">    ContextImpl appContext = ContextImpl.createActivityContext(</span><br><span class="line">            this, r.packageInfo, r.token, displayId, r.overrideConfig);</span><br><span class="line">    appContext.setOuterContext(activity);</span><br><span class="line">    Context baseContext = appContext;</span><br><span class="line"></span><br><span class="line">    final DisplayManagerGlobal dm = DisplayManagerGlobal.getInstance();</span><br><span class="line">    // For debugging purposes, if the activity&#x27;s package name contains the value of</span><br><span class="line">    // the &quot;debug.use-second-display&quot; system property as a substring, then show</span><br><span class="line">    // its content on a secondary display if there is one.</span><br><span class="line">    String pkgName = SystemProperties.get(&quot;debug.second-display.pkg&quot;);</span><br><span class="line">    if (pkgName != null &amp;&amp; !pkgName.isEmpty()</span><br><span class="line">            &amp;&amp; r.packageInfo.mPackageName.contains(pkgName)) &#123;</span><br><span class="line">        for (int id : dm.getDisplayIds()) &#123;</span><br><span class="line">            if (id != Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">                Display display =</span><br><span class="line">                        dm.getCompatibleDisplay(id, appContext.getDisplayAdjustments(id));</span><br><span class="line">                baseContext = appContext.createDisplayContext(display);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return baseContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<strong>r.packageInfo</strong>其实就是在应用刚启动时在<strong>ActivityThread.handleBindApplication()<strong>方法中的</strong>data.info &#x3D; getPackageInfoNoCheck(data.appInfo, data.compatInfo);</strong> 这里创建的，这时候创建出一个表示本应用的LoadedApk,正常情况下全局都共用这个LoadedApk对象，创建Activity的ContextImpl时也不例外。</p>
<p>回到ContextImpl.getClassLoader()中，mPackageInfo已经知道怎么来了，那再来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ClassLoader getClassLoader() &#123;</span><br><span class="line">    return mPackageInfo != null ?</span><br><span class="line">            mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时mPackageInfo不为空走<code>mPackageInfo.getClassLoader()</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ClassLoader getClassLoader() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mClassLoader == null) &#123;</span><br><span class="line">            createOrUpdateClassLoaderLocked(null /*addedPaths*/);</span><br><span class="line">        &#125;</span><br><span class="line">        return mClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常走到这里因为我们的应用报名肯定不是”android”，因为packageName.equals(“android”)是系统本身，所以我们最终只能走到<code>createOrUpdateClassLoaderLocked()</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void createOrUpdateClassLoaderLocked(List&lt;String&gt; addedPaths) &#123;</span><br><span class="line">    if (mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">        // 系统的情况不看，我们走不到</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (!mIncludeCode) &#123;</span><br><span class="line">        if (mClassLoader == null) &#123;</span><br><span class="line">            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();</span><br><span class="line">            // 创建ClassLoader</span><br><span class="line">            mClassLoader = ApplicationLoaders.getDefault().getClassLoader(</span><br><span class="line">                &quot;&quot; /* codePath */, mApplicationInfo.targetSdkVersion, isBundledApp,</span><br><span class="line">                librarySearchPath, libraryPermittedPath, mBaseClassLoader);</span><br><span class="line">            StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (mClassLoader == null) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip,</span><br><span class="line">                mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath,</span><br><span class="line">                libraryPermittedPath, mBaseClassLoader);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (addedPaths != null &amp;&amp; addedPaths.size() &gt; 0) &#123;</span><br><span class="line">        final String add = TextUtils.join(File.pathSeparator, addedPaths);</span><br><span class="line">        // 添加主工程的源码路径</span><br><span class="line">        ApplicationLoaders.getDefault().addPath(mClassLoader, add);</span><br><span class="line">        // Setup the new code paths for profiling.</span><br><span class="line">        needToSetupJitProfiles = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的最后还是通过<code>ApplicationLoaders.getClassLoader()</code>来创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ClassLoader getClassLoader(String zip, int targetSdkVersion, boolean isBundled,</span><br><span class="line">                                  String librarySearchPath, String libraryPermittedPath,</span><br><span class="line">                                  ClassLoader parent) &#123;</span><br><span class="line">    // 传入的是系统ClassLoader，阅读源码其实是PathClassLoader，可以看ClassLoader.createSystemClassLoader()，其parent是BootClassLoader，所有此时baseParent = BootClassLoader</span><br><span class="line">    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line"></span><br><span class="line">    synchronized (mLoaders) &#123;</span><br><span class="line">        if (parent == null) &#123;</span><br><span class="line">            parent = baseParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        // 如果是lib库中的类返回的加载区域为lib目录的类加载器</span><br><span class="line">        if (parent == baseParent) &#123;</span><br><span class="line">            ClassLoader loader = mLoaders.get(zip);</span><br><span class="line">            if (loader != null) &#123;</span><br><span class="line">                return loader;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line"></span><br><span class="line">            PathClassLoader pathClassloader = PathClassLoaderFactory.createClassLoader(</span><br><span class="line">                                                  zip,</span><br><span class="line">                                                  librarySearchPath,</span><br><span class="line">                                                  libraryPermittedPath,</span><br><span class="line">                                                  parent,</span><br><span class="line">                                                  targetSdkVersion,</span><br><span class="line">                                                  isBundled);</span><br><span class="line"></span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;setupVulkanLayerPath&quot;);</span><br><span class="line">            setupVulkanLayerPath(pathClassloader, librarySearchPath);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">            mLoaders.put(zip, pathClassloader);</span><br><span class="line">            return pathClassloader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">        // 应用主工程中的类返回的是加载区域为apk的sourceDir所在目录的PathClassLoader</span><br><span class="line">        PathClassLoader pathClassloader = new PathClassLoader(zip, parent);</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        return pathClassloader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后可以得出结论：首先反正返回的肯定是PathClassLoader，调用getClassLoader()的类属于不同的位置（主工程或者lib工程)则创建的PathClassLoader对应的加载区域也是不同的，具体要看住工程的加载区域可以跟踪一下，在创建的时候传入的zip是””，则它是通过addPath()方法传入的，该方法在BaseDexClassLoader中，而创建出来的PathClassLoader调用这个方法的地方是在ApplicationLoader.addPath():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void addPath(ClassLoader classLoader, String dexPath) &#123;</span><br><span class="line">    if (!(classLoader instanceof PathClassLoader)) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;class loader is not a PathClassLoader&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final PathClassLoader baseDexClassLoader = (PathClassLoader) classLoader;</span><br><span class="line">    baseDexClassLoader.addDexPath(dexPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法在刚才的<code>LoadedApk.createOrUpdateClassLoaderLocked()</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (addedPaths != null &amp;&amp; addedPaths.size() &gt; 0) &#123;</span><br><span class="line">    final String add = TextUtils.join(File.pathSeparator, addedPaths);</span><br><span class="line">    ApplicationLoaders.getDefault().addPath(mClassLoader, add);</span><br><span class="line">    // Setup the new code paths for profiling.</span><br><span class="line">    needToSetupJitProfiles = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续追溯add参数的来源是LoadedApk.makePaths(),最后的结论就是这个路径是ApplicationInfo的sourceDir。</p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>在Activity中调用getClassLoader()返回的是PathClassLoader,它的父类加载器是系统的类加载器也是个PathClassLoader，再往上是BootClassLoader。</p>
<p>温馨提示：</p>
<p>要清楚明白的知道ActivityThread、Activity、Application、Context、LoadedApk、Instrumentation这些类的关系对阅读Android源码很有帮助。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android源码小记-Context解析</title>
    <url>/2022/03/29/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-Context%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Context的使用"><a href="#Context的使用" class="headerlink" title="Context的使用"></a>Context的使用</h2><p>对于Context的使用大家并不陌生，因为在Android开发的方方面面都需要使用到Context，比如说是：</p>
<p>startActivity()：启动Activity、getResource():获取资源、getColor():获取色值、startService():启动服务</p>
<p>正是由于Context是如此的重要，所以我们在很多情况下比如自定义View，都需要传入一个Context对象才能满足编码需求，所以又牵扯出了内存泄漏等问题（比如传入了Activity当成Context，在页面生命周期已经结束时由于某些耗时等操作导致引用仍被持有导致无法及时被回收）。</p>
<p>既然Context是如此重要，那我们就有必要对它做个深入了解。</p>
<span id="more"></span>

<h2 id="Context的设计思想"><a href="#Context的设计思想" class="headerlink" title="Context的设计思想"></a>Context的设计思想</h2><p>Context主要有2层含义</p>
<ol>
<li>从字面上来理解他就是一个上下文对象，也就是说是一个运行的环境。可以理解成你游戏运行到一半要临时保存的进度。当你之后要接着来玩儿这个游戏的时候，可以从记录中恢复之前运行的所有元素。Context其实也有点这个意思，例如当你startActivity()跳转到某一页面时，你可以回溯到你是从哪个页面中跳转过来的。</li>
<li>从具体的源码内容来看，其实Context只是一个抽象类，里面定义了诸多访问应用程序运行所需的接口，例如启动Activity，发送广播等等。其实Android在有意淡化进程的概念，在开发者的开发过程中，通常不需要关心我当前属于哪个进程，只需要表明意图即可，例如打电话，打开网页连接等，当调用系统服务的时候也不需要关心对应接口是属于系统哪个进程，只需要通过Context发起调用，其内部就自动帮你做好了进程之间的调度。所以Context就像是一个运行环境一样，无处不在。有了Context，你的Linux进程就摇身一变成了Android世界的公民，享有Android提供的各种服务。我们来看下Context中提供了一些什么服务：</li>
</ol>
<ul>
<li>获取应用资源，譬如：drawable、string、asset</li>
<li>操作四大组件，譬如：启动页面，发送广播，开启服务，打开数据库</li>
<li>操作文件目录，譬如：获取&#x2F;data&#x2F;分区的缓存目录getExternalCacheDir()</li>
<li>检查授予权限，譬如：checkPermission()</li>
<li>获取其他服务，譬如：包管理服务，Activity管理服务，窗口管理服务等</li>
</ul>
<p>在应用程序中随处都可以访问这些服务，这些服务的访问入口就是Context。所以开发者不用再关系进程，而只需要关心Context提供了哪些接口即可。</p>
<blockquote>
<p>Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc.</p>
</blockquote>
<h3 id="装饰者模式是什么"><a href="#装饰者模式是什么" class="headerlink" title="装饰者模式是什么"></a>装饰者模式是什么</h3><p>在面向对象语言(OOP)中，要为一个类拓展功能最直接的方式就是<strong>继承</strong>，子类可以基于父类进行扩展。但是这种方式的弊端是当要拓展的功能维度足够多，并且功能要相互叠加的时候需要拓展的子类就会越来越多。举个例子：</p>
<blockquote>
<p>基类是衣服，需求是生产防水、透气、速干三种类型的衣服，此时需要拓展出三个子类：防水衣服、透气衣服和速干衣服。此时如果需要生产一种既防水又速干的衣服，那么得拓展出一个新类：防水速干衣服。如果需求再增加：需要生产一件保暖又速干的衣服，那么得扩展出两个新类：保暖衣服和保暖速干衣服。随着需求不断的增加，所需要拓展的子类也会随之增加。</p>
</blockquote>
<p>在GOF设计模式中，把继承看成<strong>静态</strong>类拓展，其弊端就是随着拓展的功能的增加有可能导致子类膨胀(也就是上面例子中的问题)。所以便产生了一种<strong>动态</strong>类拓展的模式：<strong>装饰者模式</strong>。</p>
<p><strong>装饰者模式虽然在实现上和代理模式很相似，但是两者要解决的问题却是截然不同的。</strong></p>
<p><strong>代理模式</strong>：1.为了隐藏代理类以保证对调用方透明做到增加安全性，2.为了实现对代理类某些功能进行用户无感知的功能增强。</p>
<p><strong>装饰者模式</strong>：这种设计模式更多的是强调拓展性，可对任意的功能进行随机组合，有效缓解了拓展维度过多时的子类膨胀。</p>
<p>所以当使用装饰者模式的时候，上例中的需求我们就可以这么做：</p>
<blockquote>
<p>基类还是衣服，需求一样是生产防水、透气、速干三种功能衣服。此时需要拓展出三个子类：防水衣服、透气衣服、速干衣服。此时要新增防水速干衣服时，只需要将防水衣服和速干衣服两者进行组合即可这样就不需要再生成新的子类，同理当需要生产保暖又速干衣服时只需要拓展一个保暖衣服即可，然后将保暖衣服和速干衣服进行组合便能满足需求。</p>
</blockquote>
<p>通过上面说明我们明白了装饰者设计模式的妙处了，具体装饰者设计模式的编码实现我会再出一篇文章详细阐述。当然通过这个例子我们回归正题其实Context的实现也是使用了装饰者模式。</p>
<h3 id="Context类关系图以及装饰者模式的应用"><a href="#Context类关系图以及装饰者模式的应用" class="headerlink" title="Context类关系图以及装饰者模式的应用"></a>Context类关系图以及装饰者模式的应用</h3><img src="/2022/03/29/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-Context%E8%A7%A3%E6%9E%90/Context%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" class="" title="Context类关系图">

<p>从Context的类关系我们可以看出，这是一个典型的装饰者模式。</p>
<p>基类Context定义了各种基础功能接口，ContextImpl则负责实现接口的具体功能。</p>
<p>对外提供Context实现时，需要对它进行一步包装，这就有了ContextWrapper这个类。装饰类一般只是一个传递者，其内部所有的方法实现都是调用ContextImpl，所以ContextWrapper中需要持有一个ContextImpl的引用。</p>
<p>装饰者存在的价值就是为了拓展某个类的功能，Context已经提供了丰富的系统功能但是仍不能满足应用程序的编程需要，所以Android又拓展了一些装饰器，其中包括Application、Activity、Service。此时才能发现原来Context真的是无处不在，在Activity中调用startActivity()其实最终还是通过Context来发起的调用。那么拓展这几个装饰者的意义何在？</p>
<ul>
<li>Application：拓展了应用的生命周期流程控制</li>
<li>Activity：拓展了单一页面的生命周期流程控制</li>
<li>Service：拓展了后台服务的生命周期流程控制</li>
</ul>
<p>它们分别对Context进行了不同维度的拓展，同时也可以将它们当成Context来使用。这就可以解释为什么你在Application中也可以启动页面，在Service中也可以启动页面。</p>
<p>那么既然四大组件中2大都使用的装饰者设计模式都设计成Context的装饰类，为什么<strong>BroadcastReceiver</strong>和<strong>ContentProvider</strong>不是Context的子类呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ContentProvider的构造方法:</span><br><span class="line">public ContentProvider(</span><br><span class="line">        Context context,</span><br><span class="line">        String readPermission,</span><br><span class="line">        String writePermission,</span><br><span class="line">        PathPermission[] pathPermissions) &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mReadPermission = readPermission;</span><br><span class="line">    mWritePermission = writePermission;</span><br><span class="line">    mPathPermissions = pathPermissions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BroadCastReceiver的onReceiver()方法：</span><br><span class="line">public abstract void onReceive(Context var1, Intent var2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看代码可以看出，它们内部都需要传入一个Context，其实换个角度看它们也是装饰类，内部也包装了Context。只是因为这两大组件的使用上和Activity和Service有较大的差别，并且它们内部并不没有很复杂的生命周期控制流程等，所以它们就用了最简单的实现方式。</p>
<blockquote>
<p><strong>题外话：</strong>装饰者模式存在于Android源码中很多地方，比如除了Context，Window的设计也是用的装饰者模式。</p>
</blockquote>
<p>至此我们做个小结：Context在Android中无处不在，它是Android系统为了弱化进程概念而设计出来的一个上下文对象（也可以理解为代表了当前的运行环境）。Context是个抽象类其提供了各种各样的功能接口供开发者使用，例如想获取资源，想跳转页面等等，都可以通过调用Context来获取。Application、Activity、Service均是Context的装饰类，它们分别拓展了不同的功能用于针对不同的应用场景。Context的真正实现其实是在ContextImpl中。</p>
<h2 id="Context源码分析"><a href="#Context源码分析" class="headerlink" title="Context源码分析"></a>Context源码分析</h2><blockquote>
<p>源码基于API25进行讲解,代码只节选部分重要内容，具体需要自行阅读源码</p>
</blockquote>
<p>Context主要有3种：</p>
<ul>
<li><strong>SystemContext：系统进程SystemServer的Context</strong></li>
<li><strong>AppContext：应用进程的Context</strong></li>
<li><strong>ActivityContext：Activity的Context，只有ActivityContext跟界面显示相关，需要传入activityToken和有效的DisplayId</strong></li>
</ul>
<p>对于Context的源码分析我们通过2条主线来进行：</p>
<ol>
<li><strong>Application的Context是如何构建的</strong></li>
<li><strong>Activity的Context是如何构建的</strong></li>
</ol>
<p>开始前先说明一个概念：Android系统进程与应用进程之间的通信建立在Binder通信之上，而以下两个接口是Android为应用进程与系统进程之间通信而设计的：</p>
<ul>
<li><strong>IApplicationThread</strong>: 作为系统进程请求应用进程的接口</li>
<li><strong>IActivityManager</strong>: 作为应用进程请求系统进程的接口</li>
</ul>
<h3 id="Application的Context构建流程"><a href="#Application的Context构建流程" class="headerlink" title="Application的Context构建流程"></a>Application的Context构建流程</h3><img src="/2022/03/29/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-Context%E8%A7%A3%E6%9E%90/Application%E7%9A%84ContextImpl%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.jpg" class="" title="Application的ContextImpl创建流程">

<p>整个流程分为几大块来讲解：</p>
<ol>
<li>Android开启一个进程时最终是从java层的<code>ActivityThread.main()</code> 方法开始的，然后调用<code>ActivityThread.attach()</code> 方法。该方法内部会调用<code>ActivityManagerService.attachApplication(IApplicationThread)</code>，了解过Binder的就能明白<strong>ActivityManagerService(AMS)</strong> 其实就是Binder通信的实现，此时调用<code>attachApplication()</code> 之后就进入系统进程对应用做了一系列的初始化，然后通过传入的<code>ApplicationThread.bindApplication()</code> 将初始化的信息回调给用户进程</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 主线程Lopper  </span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    // 进入attach()方法中，传入false表示非系统应用</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler == null) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (false) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(new</span><br><span class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    Looper.loop();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在attach()方法中，通过以下代码进入AMS进程对应用进行初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">try &#123;</span><br><span class="line">    mgr.attachApplication(mAppThread);</span><br><span class="line">&#125; catch (RemoteException ex) &#123;</span><br><span class="line">    throw ex.rethrowFromSystemServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时会回调到<strong>ActivityManagerService</strong>类中，循着方法进入最终调用到<code>ActivityManagerService.attachApplicationLocked()</code>方法，对应用做了一系列的初始化赋值并回调给<strong>IApplicationThread</strong> 对象从而进入应用进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">        profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">        app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">        mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">        isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">        new Configuration(mConfiguration), app.compat,</span><br><span class="line">        getCommonServicesLocked(app.isolated),</span><br><span class="line">        mCoreSettingsObserver.getCoreSettingsLocked());</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>应用进程收到<strong>AMS</strong>的初始化结果之后生成一个临时的存储对象<strong>AppBindData</strong>并最终通过H这个Handler调用到<code>handleBindApplication()</code>方法。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">        List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">        IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">        IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">        boolean enableBinderTracking, boolean trackAllocation,</span><br><span class="line">        boolean isRestrictedBackupMode, boolean persistent, Configuration config,</span><br><span class="line">        CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    AppBindData data = new AppBindData();</span><br><span class="line">    data.processName = processName;</span><br><span class="line">    data.appInfo = appInfo;</span><br><span class="line">    data.providers = providers;</span><br><span class="line">    data.instrumentationName = instrumentationName;</span><br><span class="line">    data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">    data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">    data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">    data.debugMode = debugMode;</span><br><span class="line">    data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">    data.trackAllocation = trackAllocation;</span><br><span class="line">    data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">    data.persistent = persistent;</span><br><span class="line">    data.config = config;</span><br><span class="line">    data.compatInfo = compatInfo;</span><br><span class="line">    data.initProfilerInfo = profilerInfo;</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>handleBindApplication()</code>中首先调用<code>getPackageInfoNoCheck()</code>创建出一个<strong>LoadedApk</strong>并将其缓存起来。该对象表示一个已经加载解析过的APK文件。紧接着通过PMS构造出一个<strong>InstrumentationInfo</strong>对象紧接着通过它使用类加载器构建出一个<strong>Instrumentation</strong>对象，该对象其实是对Activity或者Application方法调用的一个统一收口(简单说就是将ActivityThread对Activity和Application的通信都统一规范到这一个类中进行)，期间的通信介质就是<strong>LoadedApk</strong>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 构建一个LoadedApk对象，该对象其实是应用在内存中的表现形式。</span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    final InstrumentationInfo ii;</span><br><span class="line">    if (data.instrumentationName != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 内部是通过PackageManagerService(PMS)来创建一个InstrumentationInfo对象，用于后续生成Instrumentation</span><br><span class="line">            ii = new ApplicationPackageManager(null, getPackageManager())</span><br><span class="line">                    .getInstrumentationInfo(data.instrumentationName, 0);</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to find instrumentation info for: &quot; + data.instrumentationName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mInstrumentationPackageName = ii.packageName;</span><br><span class="line">        mInstrumentationAppDir = ii.sourceDir;</span><br><span class="line">        mInstrumentationSplitAppDirs = ii.splitSourceDirs;</span><br><span class="line">        mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii);</span><br><span class="line">        mInstrumentedAppDir = data.info.getAppDir();</span><br><span class="line">        mInstrumentedSplitAppDirs = data.info.getSplitAppDirs();</span><br><span class="line">        mInstrumentedLibDir = data.info.getLibDir();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ii = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (ii != null) &#123;</span><br><span class="line">        // 这个Context不是Application的Context，本次关注Application的context的创建所以这边咱不关心</span><br><span class="line">        final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            final ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">            // 创建出Instrumentation对象</span><br><span class="line">            mInstrumentation = (Instrumentation)</span><br><span class="line">                cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate instrumentation &quot;</span><br><span class="line">                + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        final ComponentName component = new ComponentName(ii.packageName, ii.name);</span><br><span class="line">        mInstrumentation.init(this, instrContext, appContext, component,</span><br><span class="line">                data.instrumentationWatcher, data.instrumentationUiAutomationConnection);</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mInstrumentation = new Instrumentation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        // 调用LoadedApk的makeApplication()开始了Application的创建流程以及将其与ContextImpl绑定</span><br><span class="line">        Application app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Exception thrown in onCreate() of &quot;</span><br><span class="line">                + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 执行Application.onCreate()</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面代码可以看到我们有了<strong>LoadedApk(代表整个APK)、Instrumentation(ActivityThread与Application和Activity的通信收口)</strong> 这俩对象，主要创建流程都是在这俩类中进行的。<br>LoadedApk中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">        Instrumentation instrumentation) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Application app = null;</span><br><span class="line"></span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">        // 没有自定义Application或者规定了使用默认Application，则初始化的是android.app.Application</span><br><span class="line">        appClass = &quot;android.app.Application&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取类加载器</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        ...</span><br><span class="line">        // 创建出应用Context</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">        // 执行Instrumentation的newApplication()创建一个Application</span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必要的类都创建完毕之后就该开始使用它们了，调用<code>LoadedApk.makeApplication()</code>方法来创建出一个<strong>Application</strong>对象(该对象之后再传递给Instrumentation来执行onCreate()等方法从而走到Application的生命周期)，创建Application的过程概括来讲就是调用类加载器将我们AndroidManifest中生命的Application加载进内存，如果我们没有指定自己的Application的话就默认会加载”<strong>android.app.Application</strong>“。<br>具体的Application创建流程是首先生成一个ClassLoader，然后通过<code>ContextImpl.createAppContext()</code>构造了一个appContext(<strong>应用级别的Context</strong>)，构造时保存了LoadedApk，进程的ActivityThread以及初始化了Resource资源，ApplicationContentResolver对数据库的操作类等等。</p>
<p>4.然后将这两个对象传入应用的<code>Instrumentation.newApplication()</code>，其内部使用类加载器+反射生成一个Application，紧接着调用<code>Application.attach()</code>将appContext设置给Application这个装饰类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static public Application newApplication(Class&lt;?&gt; clazz, Context context)</span><br><span class="line">        throws InstantiationException, IllegalAccessException, </span><br><span class="line">        ClassNotFoundException &#123;</span><br><span class="line">    // 反射生成Application对象</span><br><span class="line">    Application app = (Application)clazz.newInstance();</span><br><span class="line">    // 将应用Context设置给Application，此时其实就是设置给了ContextWrapper的mBase属性，而Application是ContextWrapper子类所以自然它也就和Context关联起来了。</span><br><span class="line">    app.attach(context);</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这整个流程下来就完成了Application中Context的构建，也就是Application这个装饰类对ContextImpl的装饰。</p>
<h3 id="Activity的Context构建流程"><a href="#Activity的Context构建流程" class="headerlink" title="Activity的Context构建流程"></a>Activity的Context构建流程</h3><p>如果从Activity的启动流程来讲解那将是一篇遥遥无期的文章，这里省去了Activity启动流程中前半部分复杂的逻辑，具体可以参考另外一个文章我会贴链接。</p>
<img src="/2022/03/29/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-Context%E8%A7%A3%E6%9E%90/Activity%E7%9A%84ContextImpl%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg" class="" title="Activity的ContextImpl创建过程">

<p>我们通过Activity启动流程中可以知道最终会调用到<code>ActivityThread.handleLaunchActivity()</code>方法中来，紧接着在其内部会执行<code>Activity a = performLaunchActivity(r, customIntent);</code> 用于创建Activity，然后调用<code>handleResumeActivity(...);</code>开始页面的测绘流程等。本篇只为探究Activity的Context创建过程，所以只关心performLaunchActivity()流程。</p>
<p>Activity的Context创建过程比Application中Context流程简单很多。主要分为几步(<strong>以下代码均摘抄自performLaunchActivity()方法</strong>)：</p>
<ol>
<li>通过ActivityThread中的mInstrumentation对象调用newActivity()生成对应的Activity对象，其内部生成原理就是通过反射创建。而这个mInstrumentation其实在应用启动过程中已经创建完毕，也就是在Application的Context创建流程中。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过LoadedApk获取ClassLoader</span><br><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">// 创建出所需启动的Activity对象，内部是使用反射</span><br><span class="line">activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br></pre></td></tr></table></figure></li>
<li>调用createBaseContextForActivity()方法去创建一个Activity对应的ContextImpl，其内部也是调用的ContextImpl的构造方法创建。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line"></span><br><span class="line">private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 创建Activity对应的ContextImpl</span><br><span class="line">    ContextImpl appContext = ContextImpl.createActivityContext(</span><br><span class="line">            this, r.packageInfo, r.token, displayId, r.overrideConfig);</span><br><span class="line">    appContext.setOuterContext(activity);</span><br><span class="line">    Context baseContext = appContext;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    return baseContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>调用activity.attach(…)方法将创建出来的ContextImpl与Activity绑定起来，当然传递的参数有很多，比如也会将Application传递进去，当然这时候这个对象也已经存在了。紧接着内部还是老配方：执行attachBaseContext(context);将ContextImpl设置给父类ContextWrapper的mBase属性。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将创建出来的ContextImpl关联给Activity，其内部是调用了attachBaseContext(context);将其设置给ContextWrapper.mBase</span><br><span class="line">// 当然这个方法做了很多很多事，这里不研究别的我们只关心Context的创建流程</span><br><span class="line">activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">        r.referrer, r.voiceInteractor, window);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>至此流程结束</p>
<h2 id="Context注意事项"><a href="#Context注意事项" class="headerlink" title="Context注意事项"></a>Context注意事项</h2><h4 id="内存泄漏问题："><a href="#内存泄漏问题：" class="headerlink" title="内存泄漏问题："></a>内存泄漏问题：</h4><p><strong>内存泄漏的本质是长生命周期的对象持有了短生命周期对象的引用导致短生命周期对象在无用的情况下不能及时被GC</strong></p>
<p>而使用Context导致内存泄漏的情况往往是将Activity这种相对短生命周期的对象传给其他对象使用，可能其他对象中有耗时操作导致Activity无法被及时回收。还有一个典型的场景就是在Android开发中往往在设计很多单例的时候需要传入一个Context，如果此时传入的是Activity那就会造成内存泄漏。因为我们知道通常单例方法是static，其涉及的生命周期是整个进程，所以为了解决这个问题可以考虑传入Application的Context来解决这个问题。</p>
<h4 id="Context的使用："><a href="#Context的使用：" class="headerlink" title="Context的使用："></a>Context的使用：</h4><p>在Android开发中在一个Activity中获取Context的方法有很多种：</p>
<ul>
<li><p>getApplication()：返回Application对象</p>
</li>
<li><p>getApplicationContext()：与getApplication()返回同一个对象，只不过其返回的是Context类型，java中向上转型必然会被阉割掉一些子类独有的方法</p>
</li>
<li><p>getBaseContext()：返回Activity的ContextImpl对象（Application.getBaseContext()：返回Application的ContextImpl对象）</p>
</li>
<li><p>Activity.this：返回Activity本身</p>
<p>  正是ContextImpl被外层装饰器包装了一下才形成了Context不同功能的拓展。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Context淡化了Android进程的概念，其提供了一个应用的运行环境。Android中它无处不在，开发者可以通过它调用一系列的系统方法比如获取资源，打开页面，打开服务等等。</p>
<p>其实现上采用了装饰者模式，Activity、Application、Service等都是装饰类，当开发者使用这些装饰者作为Context来使用的时候，其实真正的实现逻辑是在ContextImpl类中。</p>
<p>在Context的使用中要十分注意避免出现内存泄漏问题。_</p>
<hr>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android版本号对应关系</title>
    <url>/2022/03/29/Android%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="Android系统版本对应API"><a href="#Android系统版本对应API" class="headerlink" title="Android系统版本对应API"></a>Android系统版本对应API</h3><table>
<thead>
<tr>
<th>API Version</th>
<th>Android Version</th>
<th>Linux Kernel in AOSP</th>
<th>发布时间</th>
</tr>
</thead>
<tbody><tr>
<td>API 31</td>
<td>android 12.0 Snow Cone</td>
<td>-</td>
<td>2021.10    -</td>
</tr>
<tr>
<td>API 30</td>
<td>android 11.0 R</td>
<td>-</td>
<td>2020.9    -</td>
</tr>
<tr>
<td>API 29</td>
<td>android 10.0 Q</td>
<td>-</td>
<td>2019.8    -</td>
</tr>
<tr>
<td>API 28</td>
<td>android 9.0 Pie&#x2F;馅饼</td>
<td>-</td>
<td>2018.8</td>
</tr>
<tr>
<td>API 27</td>
<td>android 8.1 Oreo&#x2F;奥利奥</td>
<td>-</td>
<td>2017.12</td>
</tr>
<tr>
<td>API 26</td>
<td>android 8.0 Oreo&#x2F;奥利奥</td>
<td>-</td>
<td>2017.8</td>
</tr>
<tr>
<td>API 25</td>
<td>android 7.1 Nougat&#x2F;牛轧糖</td>
<td>4.4.1</td>
<td>2016.10</td>
</tr>
<tr>
<td>API 24</td>
<td>android 7.0 Nougat&#x2F;牛轧糖</td>
<td>4.4.1</td>
<td>2016.8</td>
</tr>
<tr>
<td>API 23</td>
<td>android 6.0 Marshmallow&#x2F;棉花糖</td>
<td>3.18.10</td>
<td>2015.8</td>
</tr>
<tr>
<td>API 22</td>
<td>android 5.1 Lollipop&#x2F;棒棒糖</td>
<td>3.16.1</td>
<td>2014.12</td>
</tr>
<tr>
<td>API 21</td>
<td>android 5.0 Lollipop&#x2F;棒棒糖</td>
<td>3.16.1</td>
<td>2014.10</td>
</tr>
<tr>
<td>API 20</td>
<td>android 4.4W KitKat&#x2F;奇巧巧克力棒</td>
<td>3.10</td>
<td>2013底</td>
</tr>
<tr>
<td>API 19</td>
<td>android 4.4 KitKat&#x2F;奇巧巧克力棒</td>
<td>3.10</td>
<td>2013.11</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android源码小记-LoadedApk</title>
    <url>/2022/04/14/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-LoadedApk/</url>
    <content><![CDATA[<p>文章基于API25分析，源码地址：<a href="http://androidxref.com/7.1.1_r6/">http://androidxref.com/7.1.1_r6/</a></p>
<h2 id="什么是LoadedApk"><a href="#什么是LoadedApk" class="headerlink" title="什么是LoadedApk"></a>什么是LoadedApk</h2><p>看下源码中对LoadedApk的注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Local state maintained about a currently loaded .apk.</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">public final class LoadedApk &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>翻译过来就是维护当前加载的 .apk 的本地状态。大白话讲LoadedApk就是一个.apk文件在内存中的表现形式。</p>
<blockquote>
<p>换句话说LoadedApk是apk安装文件在内存中的数据，可以在LoadedApk中得到apk文件中的代码、资源文件、Activity、Service组件、manifest配置文件等等信息，这些都封装在LoadedApk这个类中。</p>
</blockquote>
<p>我们知道应用启动是通过Zygote进程fork出一个应用进程之后调用ActivityThread.main()方法才走到应用自身。</p>
<p><strong>1个apk应用对应1个ActivityThread</strong></p>
<p><strong>1个apk应用也对应1个LoadedApk</strong></p>
<span id="more"></span>

<p>早前我在阅读源码的时候一直有一个疑惑，既然LoadedApk是apk文件在内存中的表现形态，那我们的应用的ActivityThread里面为什么mPackages、mResourcePackages这俩属性为什么要用map来定义呢？那不是说明会有很多个LoadedApk？而且我之前看一个文章上有一句话：<em>一个进程可以加载多个apk</em>。我一直不理解？</p>
<p>直到后来我了解插件化的时候我想明白了！插件化有一种方式是定义一个插件LoadedApk然后插入ActivityThread的mPackages集合中，这样在宿主工程中就能轻松访跳转插件中的Activity。原理是使用插件LoadedApk获取到插件的ClassLoader并加载出插件中的Activity类（具体原理我会再行撰文）。这就理解了一个进程是可以加载多个apk的。</p>
<p>既然LoadedApk是apk在内存中的表现形式，其内部包含了整个<code>mApplicationInfo</code>，那就可以理解用它能做很多事</p>
<ul>
<li>创建一个Application放在这个类中再合适不过，因为LoadedApk本身就包含了manifest配置文件中的信息。</li>
<li>用它来获取Resources也合情合理，因为资源文件也包含其中。</li>
<li>…<br>也就是说其实在各个地方只要获取到这个LoadedApk对象就能获取应用的所有信息。</li>
</ul>
<h2 id="LoadedApk创建过程源码分析"><a href="#LoadedApk创建过程源码分析" class="headerlink" title="LoadedApk创建过程源码分析"></a>LoadedApk创建过程源码分析</h2><p>我们了解了App启动流程之后（如不了解看我另一文章 xxx）知道，一个App进程启动之后会立马调用到ActivityThread.main()方法中来，在内部会执行attach()然后调用AMS.attachApplication(IApplicationThread)方法让AMS进程去初始化应用最后将结果通过IApplication这个接口返回给应用进程。此时应用进程会通过H这个Handler走到handleBindApplication()这个方法，应用就开始处理并创建Application了，LoadedApk也是在这一步生成的。</p>
<blockquote>
<p>ActivityThread.attach() -&gt; AMS.attachApplication(IApplicationThread thread) -&gt; ApplicationThread.bindApplication() -&gt; H -&gt; ActivityThread.handleBindApplication() -&gt; ActivityThread. getPackageInfoNoCheck(data.appInfo, data.compatInfo) -&gt; LoadedApk.构造()</p>
</blockquote>
<p>直接分析getPackageInfoNoCheck():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityThread.java</span><br><span class="line"></span><br><span class="line">public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,CompatibilityInfo compatInfo) &#123;</span><br><span class="line">    return getPackageInfo(ai, compatInfo, null, false, true, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,</span><br><span class="line">        ClassLoader baseLoader, boolean securityViolation, boolean includeCode,</span><br><span class="line">        boolean registerPackage) &#123;</span><br><span class="line">    // 判断应用uid，一般正常安装的apk differentUser值为false，除非是手动去加载的其他apk</span><br><span class="line">    final boolean differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));</span><br><span class="line">    synchronized (mResourcesManager) &#123;</span><br><span class="line">        WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        if (differentUser) &#123;</span><br><span class="line">            // Caching not supported across users</span><br><span class="line">            ref = null;</span><br><span class="line">        &#125; else if (includeCode) &#123;</span><br><span class="line">            // 传入的includeCode为true，所以从缓存中取出LoadedApk对象</span><br><span class="line">            ref = mPackages.get(aInfo.packageName);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ref = mResourcePackages.get(aInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LoadedApk packageInfo = ref != null ? ref.get() : null;</span><br><span class="line">        // 如果是刚进应用则缓存中就不存在该apk对应的LoadedApk，就会去走创建流程</span><br><span class="line">        if (packageInfo == null || (packageInfo.mResources != null</span><br><span class="line">                &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;</span><br><span class="line">            if (localLOGV) Slog.v(TAG, (includeCode ? &quot;Loading code package &quot;</span><br><span class="line">                    : &quot;Loading resource-only package &quot;) + aInfo.packageName</span><br><span class="line">                    + &quot; (in &quot; + (mBoundApplication != null</span><br><span class="line">                            ? mBoundApplication.processName : null)</span><br><span class="line">                    + &quot;)&quot;);</span><br><span class="line">            // 创建一个新的LoadedApk对象，里面包含了ApplicationInfo，CompatibilityInfo等信息</span><br><span class="line">            packageInfo =</span><br><span class="line">                new LoadedApk(this, aInfo, compatInfo, baseLoader,</span><br><span class="line">                        securityViolation, includeCode &amp;&amp;</span><br><span class="line">                        (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);</span><br><span class="line"></span><br><span class="line">            if (mSystemThread &amp;&amp; &quot;android&quot;.equals(aInfo.packageName)) &#123;</span><br><span class="line">                packageInfo.installSystemApplicationInfo(aInfo,</span><br><span class="line">                        getSystemContext().mPackageInfo.getClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (differentUser) &#123;</span><br><span class="line">                // Caching not supported across users</span><br><span class="line">            &#125; else if (includeCode) &#123;</span><br><span class="line">                // 创建完成之后会将其缓存起来，后面系统流程中需要使用的时候直接根据对应的包名从缓存中获取</span><br><span class="line">                mPackages.put(aInfo.packageName,</span><br><span class="line">                        new WeakReference&lt;LoadedApk&gt;(packageInfo));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mResourcePackages.put(aInfo.packageName,</span><br><span class="line">                        new WeakReference&lt;LoadedApk&gt;(packageInfo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return packageInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是应用的LoadedApk的创建流程，只是简单理解不去深究里面的ApplicationInfo、CompatibilityInfo这些是如何构造的就很简单，要深究的话一篇也讲不完。</p>
<p>在App的启动过程中，LoadedApk做的一个很关键的事情就是创建Application对象，我们简单看看<code>handleBindApplication</code>内通过LoadedApk去创建一个Application的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityThread.java</span><br><span class="line"></span><br><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用到<code>LoadedApk.makeApplication()</code>方法去了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,Instrumentation instrumentation) &#123;</span><br><span class="line">    if (mApplication != null) &#123;</span><br><span class="line">        return mApplication;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;makeApplication&quot;);</span><br><span class="line"></span><br><span class="line">    Application app = null;</span><br><span class="line"></span><br><span class="line">    // 获取manifest配置文件中指定的Application，如果我们自定义了那么appClass就是我们自定义Application的类名，否则系统默认创建类名为&quot;android.app.Application&quot;的默认Application对象</span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">        appClass = &quot;android.app.Application&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //  获取应用类加载器，正常情况下取出来的会是PathClassLoader</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        // 表示非系统应用</span><br><span class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                    &quot;initializeJavaContextClassLoader&quot;);</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">        // 先创建一个ContextImpl对象后续赋值给Application对应的mBase，完成Application对ContextImpl的代理，此处会将本LoadedApk实例传给Application对应的ContextImpl，其实如果了解Activity的构建的话可以去看下，Activity对应的ContextImpl中也传入了这个LoadedApk对象。正常情况如果没有加载多个apk的话，全局都是共用的这一个LoadedApk对象</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">        // 调用ActivityThread的mInstrumentation传入类名和类加载器执行创建实例操作，内部是用的反射来实现的创建。</span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate application &quot; + appClass</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActivityThread.mAllApplications.add(app);</span><br><span class="line">    mApplication = app;</span><br><span class="line"></span><br><span class="line">    if (instrumentation != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            instrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Rewrite the R &#x27;constants&#x27; for all library apks.</span><br><span class="line">    SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread)</span><br><span class="line">            .getAssignedPackageIdentifiers();</span><br><span class="line">    final int N = packageIdentifiers.size();</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        final int id = packageIdentifiers.keyAt(i);</span><br><span class="line">        if (id == 0x01 || id == 0x7f) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码注释中清楚解释了如何使用LoadedApk去构建Application。其中涉及到了Instrumentation对象，其实这个对象只是一个对Application和Activity创建和生命周期流程等操作的统一封装，这样能使代码结构更加清晰。并且其内部还有一些模拟按键的方法。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>LoadedApk是apk安装文件在内存中的数据，可以在LoadedApk中得到apk文件中的代码、资源文件、Activity、Service组件、manifest配置文件等等信息，这些都封装在LoadedApk这个类中。</li>
<li>在正常情况下同一个安装包下的Activity和Application等这些组件都是公用的一个LoadedApk对象。</li>
<li>在任何场景下只要获取了LoadedApk对象就能获取到应用的信息，例如Activity中获取资源其实也是通过ContextImpl获取了应用的LoadedApk对象实例然后去调用的<code>ActivityThread.getTopLevelResources();</code>方法。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Jetpack-Lifecycle</title>
    <url>/2022/08/23/Jetpack-Lifecycle/</url>
    <content><![CDATA[<h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Lifecycle库是Google在2017年IO大会上发布的一个库。本质上是通过观察者模式来帮助开发者实现对Activity、Fragment、Service、Application(应用)声明周期的监测。</p>
<h2 id="Lifecycle的依赖"><a href="#Lifecycle的依赖" class="headerlink" title="Lifecycle的依赖"></a>Lifecycle的依赖</h2><p><strong>gradle :app:dependencies可查看项目模块依赖树</strong></p>
<p>如果你的应用已经完成了Support到Androidx的迁移，那么只需要依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation &#x27;androidx.appcompat:appcompat:$version&#x27; // 具体版本可查看官网</span><br></pre></td></tr></table></figure>
<p>通过查看appcompat的依赖关系可以看出，appcompat内部已经依赖了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">androidx:lifecycle:lifecycle-runtime:$version</span><br></pre></td></tr></table></figure>
<p>该库内部又依赖了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">androidx:lifecycle:lifecycle-common:$version</span><br></pre></td></tr></table></figure>
<p><code>lifecycle-common</code>是lifecycle的基础库，相当于lifecycle的底层服务库。例如<code>Lifecycle</code>、<code>LifecycleRegistry</code>、<code>LifecycleObserver</code>、<code>LifecycleOwner</code>这些基础类都是在<code>lifecycle-common</code>库中。</p>
<p>Google将lifecycle相关功能进行了拆分，开发者可以按需引入以减小应用的包体积，截止目前最新版本已经更新到2.6.0-alpha01</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    def lifecycle_version = &quot;2.6.0-alpha01&quot;</span><br><span class="line">    def arch_version = &quot;2.1.0&quot;</span><br><span class="line"></span><br><span class="line">    // ViewModel</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version&quot;</span><br><span class="line">    // ViewModel utilities for Compose</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycle_version&quot;</span><br><span class="line">    // LiveData</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version&quot;</span><br><span class="line">    // Lifecycles only (without ViewModel or LiveData)</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    // Saved state module for ViewModel</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    // Annotation processor</span><br><span class="line">    kapt &quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot;</span><br><span class="line">    // alternately - if using Java8, use the following instead of lifecycle-compiler</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    // optional - helpers for implementing LifecycleOwner in a Service</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-service:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    // optional - ProcessLifecycleOwner provides a lifecycle for the whole application process</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-process:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    // optional - ReactiveStreams support for LiveData</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-reactivestreams-ktx:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    // optional - Test helpers for LiveData</span><br><span class="line">    testImplementation &quot;androidx.arch.core:core-testing:$arch_version&quot;</span><br><span class="line"></span><br><span class="line">    // optional - Test helpers for Lifecycle runtime</span><br><span class="line">    testImplementation &quot;androidx.lifecycle:lifecycle-runtime-testing:$lifecycle_version&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Lifecycle设计框架"><a href="#Lifecycle设计框架" class="headerlink" title="Lifecycle设计框架"></a>Lifecycle设计框架</h2><p>lifecycle的设计其实非常简单，就是一个典型的观察者模式。假设让我们用自己的思路实现一个最简单的监测Activity生命周期的观察者，动手之前思考一下观察者模式必备的几个角色：<strong>1.被观察者</strong>，<strong>2.观察者</strong>，<strong>3.调度类（管理观察者和被观察者之间关系）</strong>。那我们实现一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 被观察者</span><br><span class="line"> * 也就是说发生变化的那个角色</span><br><span class="line"> * 比如我们现在想实现的是监测Activity生命周期，那Activity就扮演这个角色</span><br><span class="line"> * 而它的变化就是代码走到了哪个生命周期回调，比如启动Activity时走了onCreate是一种变化，页面渲染完成走了onResume又是一种变化</span><br><span class="line"> */</span><br><span class="line">class LifeActivity : Activity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        // 首先给管理类添加一个观察者</span><br><span class="line">        LifeManager.INSTANCE.addObserver(LifeObserver())</span><br><span class="line">        // 被观察者走到了onCreate，此时我们应该通知给观察者</span><br><span class="line">        LifeManager.INSTANCE.notifyOnCreate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onResume() &#123;</span><br><span class="line">        super.onResume()</span><br><span class="line">        LifeManager.INSTANCE.notifyOnResume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 观察者</span><br><span class="line"> * 也就是响应变化的类</span><br><span class="line"> * 主要就是当被观察者的变化发生时，我们想要做什么事就在这个角色中实现</span><br><span class="line"> * 我们现在需求时观察到Activity如果走到onCreate和onResume就打印日志</span><br><span class="line"> */</span><br><span class="line">class LifeObserver &#123;</span><br><span class="line">    fun onCreate() &#123;</span><br><span class="line">        LogUtils.d(&quot; LifeObserver --&gt; onCreate&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun onResume() &#123;</span><br><span class="line">        LogUtils.d(&quot; LifeObserver --&gt; onResume&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 单例</span><br><span class="line"> * 观察者模式的调度类，主要实现的功能有：</span><br><span class="line"> * 1.观察者的注册、解除管理</span><br><span class="line"> * 2.当被观察者发生变化时通知观察者，也就是将观察者和被观察者联系在一起</span><br><span class="line"> */</span><br><span class="line">class LifeManager private constructor() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val INSTANCE: LifeManager by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) &#123;</span><br><span class="line">            LifeManager();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 本地维护一个观察者列表，以便当被观察者发生变化时可以通知到所有观察者</span><br><span class="line">    private val lifeObservers = mutableListOf&lt;LifeObserver&gt;()</span><br><span class="line"></span><br><span class="line">    // 添加一个观察者</span><br><span class="line">    fun addObserver(observer: LifeObserver) &#123;</span><br><span class="line">        if (!lifeObservers.contains(observer)) &#123;</span><br><span class="line">            lifeObservers.add(observer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun removeObserver(observer: LifeObserver) &#123;</span><br><span class="line">        if (lifeObservers.contains(observer)) &#123;</span><br><span class="line">            lifeObservers.remove(observer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 被观察者走到了onCreate，此时需要通知所有观察者让它们知道</span><br><span class="line">    fun notifyOnCreate() &#123;</span><br><span class="line">        for (o in lifeObservers) &#123;</span><br><span class="line">            o.onCreate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 被观察者走到了onResume，此时需要通知所有观察者让它们知道</span><br><span class="line">    fun notifyOnResume() &#123;</span><br><span class="line">        for (o in lifeObservers) &#123;</span><br><span class="line">            o.onResume()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个最基础最简单的观察者模式，不考虑多线程，没有任何封装。但是足以体现观察者模式的思路，而Lifecycle正是使用这种方式来进行生命周期管理的。</p>
<p>将Lifecycle库中的角色与本例中的角色一一对应就是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LifecycleOwner --&gt; LifeActivity //LifecycleOwner只是做了一个抽象封装，我们后面再详细说</span><br><span class="line"></span><br><span class="line">LifecycleObserver --&gt; LifeObserver</span><br><span class="line"></span><br><span class="line">LifecycleRegistry --&gt; LifeManager</span><br></pre></td></tr></table></figure>
<h4 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface LifecycleOwner &#123;</span><br><span class="line">    @NonNull</span><br><span class="line">    Lifecycle getLifecycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类对应的角色是被观察者，Google将它抽象出来并开放了一个getLifecycle()方法为的是让用户在使用时无需再去关心如何获取生命周期管理类，你可以发现我们以Activity为例当我们想要获得一个带有生命周期管理功能的Activity页面那建议是继承<code>AppCompatActivity</code>类，其最终有个父类是<code>androidx.core.app.ComponentActivity</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ComponentActivity extends Activity implements</span><br><span class="line">        LifecycleOwner,</span><br><span class="line">        KeyEventDispatcher.Component &#123;</span><br><span class="line">   </span><br><span class="line">    private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);</span><br><span class="line">    </span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Lifecycle getLifecycle() &#123;</span><br><span class="line">        return mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>而<code>LifecycleRegistry</code>对应的不就是管理类吗，所以设计<code>LifecycleOwner</code>只是为了让开发者在使用Activity时内部可以更轻松正确地去获得管理类，避免每次自己去创建产生不必要的麻烦。<br>我们也可以将自己实现的那个小demo做一个简单的改变，抽象出一个自己的<code>BaseActivity</code>，后续子类继承它就可以实现这种更规范的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface LifeObject &#123;</span><br><span class="line">    var lifeManager: LifeManager</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open class BaseActivity : Activity(), LifeObject &#123;</span><br><span class="line">    override var lifeManager: LifeManager</span><br><span class="line">        get() = LifeManager.INSTANCE</span><br><span class="line">        set(value) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LifeActivity : BaseActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        lifeManager.notifyOnResume()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onResume() &#123;</span><br><span class="line">        super.onResume()</span><br><span class="line">        lifeManager.notifyOnResume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LifecycleOwner</code>很清楚了。</p>
<h4 id="LifecycleObserver"><a href="#LifecycleObserver" class="headerlink" title="LifecycleObserver"></a>LifecycleObserver</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface LifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有任何代码，其实这也是一个小抽象。系统已经为我们实现了几个默认的Activity相关的默认观察者，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface DefaultLifecycleObserver extends FullLifecycleObserver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    default void onCreate(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    default void onStart(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    default void onResume(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    default void onPause(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    default void onStop(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    default void onDestroy(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，就是写了一堆生命周期相应的回调方法。因为它所提供的是一种能力，所以只是把方法封装给开发者，开发者收到监听时想做的事情都是五花八门的，所以直接通过继承就可以实现各自想要的炫酷效果。</p>
<p>还有一个默认实现是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface LifecycleEventObserver extends LifecycleObserver &#123;</span><br><span class="line">    void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个更加简单一点，系统给生命周期对应的方法定义了一一对应的枚举值，每次走到某个生命周期只需调用这个统一的onStateChanged回调并将相应的枚举传递过去开发者即可自行实现想要的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LifecycleRegistry extends Lifecycle &#123;</span><br><span class="line"></span><br><span class="line">    // 观察者集合</span><br><span class="line">    private FastSafeIterableMap&lt;LifecycleObserver, LifecycleRegistry.ObserverWithState&gt; mObserverMap;</span><br><span class="line"></span><br><span class="line">    // 这里将LifecycleOwner传递过来只是为了在通知观察者的时候把被观察者对象也传递过去方便开发者在需要使用到被观察者时能精准地获取到，所以充分体现了设计框架的时候要考虑到各种使用场景以便给使用者更好的使用体验</span><br><span class="line">    private final WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner;</span><br><span class="line">    </span><br><span class="line">    private LifecycleRegistry(@NonNull LifecycleOwner provider, boolean enforceMainThread) &#123;</span><br><span class="line">        mLifecycleOwner = new WeakReference&lt;&gt;(provider);</span><br><span class="line">        mState = INITIALIZED;</span><br><span class="line">        // 这里其实是判断是否线程安全，系统默认是必须在主线程中调用这样就避免了线程安全问题，其实也是有道理的因为生命周期肯定都是在主线程中调用的</span><br><span class="line">        mEnforceMainThread = enforceMainThread;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 事件分发，扮演的角色其实类似于我们demo中的notifyOnCreate、notifyOnResume方法，只是这里它做了一系列的状态比较等更严谨的操作</span><br><span class="line">    public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123;</span><br><span class="line">        enforceMainThreadIfNeeded(&quot;handleLifecycleEvent&quot;);</span><br><span class="line">        moveToState(event.getTargetState());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addObserver(@NonNull LifecycleObserver observer) &#123;</span><br><span class="line">        this.enforceMainThreadIfNeeded(&quot;addObserver&quot;);</span><br><span class="line">        State initialState = this.mState == State.DESTROYED ? State.DESTROYED : State.INITIALIZED;</span><br><span class="line">        LifecycleRegistry.ObserverWithState statefulObserver = new LifecycleRegistry.ObserverWithState(observer, initialState);</span><br><span class="line">        // 将观察者加入观察者集合</span><br><span class="line">        LifecycleRegistry.ObserverWithState previous = (LifecycleRegistry.ObserverWithState)this.mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line">        if (previous == null) &#123;</span><br><span class="line">            LifecycleOwner lifecycleOwner = (LifecycleOwner)this.mLifecycleOwner.get();</span><br><span class="line">            if (lifecycleOwner != null) &#123;</span><br><span class="line">                boolean isReentrance = this.mAddingObserverCounter != 0 || this.mHandlingEvent;</span><br><span class="line">                // 计算出当前Activity处于哪个生命周期</span><br><span class="line">                State targetState = this.calculateTargetState(observer);</span><br><span class="line">                ++this.mAddingObserverCounter;</span><br><span class="line">                </span><br><span class="line">                // while循环是为了将添加观察者之前所经历过的生命周期都按顺序回调一遍</span><br><span class="line">                while(statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; this.mObserverMap.contains(observer)) &#123;</span><br><span class="line">                    this.pushParentState(statefulObserver.mState);</span><br><span class="line">                    Event event = Event.upFrom(statefulObserver.mState);</span><br><span class="line">                    if (event == null) &#123;</span><br><span class="line">                        throw new IllegalStateException(&quot;no event up from &quot; + statefulObserver.mState);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    // 给观察者回调事件</span><br><span class="line">                    statefulObserver.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">                    this.popParentState();</span><br><span class="line">                    targetState = this.calculateTargetState(observer);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!isReentrance) &#123;</span><br><span class="line">                    this.sync();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                --this.mAddingObserverCounter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static class ObserverWithState &#123;</span><br><span class="line">        State mState;</span><br><span class="line">        LifecycleEventObserver mLifecycleObserver;</span><br><span class="line">    </span><br><span class="line">        ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">            // 主要是2类，一类是LifecycleEventObserver另一类是FullLifecycleObserver相关的观察者</span><br><span class="line">            mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</span><br><span class="line">            mState = initialState;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 分发生命周期对应方法</span><br><span class="line">        void dispatchEvent(LifecycleOwner owner, Event event) &#123;</span><br><span class="line">            State newState = event.getTargetState();</span><br><span class="line">            mState = min(mState, newState);</span><br><span class="line">            // 在mLifecycleObserver中做中转</span><br><span class="line">            mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">            mState = newState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而在Activity走到各个生命周期时会回调给<code>LifecycleRegistry-&gt;handleLifecycleEvent</code>方法，而系统为我们做这个逻辑的代码是在FragmentActivity中，我们实现继承的AppCompatActivity是继承FragmentActivity的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FragmentActivity extends ComponentActivity implements</span><br><span class="line">        ActivityCompat.OnRequestPermissionsResultCallback,</span><br><span class="line">        ActivityCompat.RequestPermissionsRequestCodeValidator &#123;</span><br><span class="line">        ...</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">    </span><br><span class="line">        mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class="line">        mFragments.dispatchCreate();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // resume事件监听相对绕一点，可以从ActivityThread中开始走Activity的resume流程最终调用到Activity类中performResume然后会回调到这个onPostResume()方法中</span><br><span class="line">    protected void onResumeFragments() &#123;</span><br><span class="line">        mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);</span><br><span class="line">        mFragments.dispatchResume();</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以至此Activity生命周期监听的大概框架设计原理已经了解完了，归根结底很简单就是一个观察者模式。</p>
<h2 id="Lifecycle常见使用场景及其实现思路解析"><a href="#Lifecycle常见使用场景及其实现思路解析" class="headerlink" title="Lifecycle常见使用场景及其实现思路解析"></a>Lifecycle常见使用场景及其实现思路解析</h2><h3 id="监测应用前后台切换"><a href="#监测应用前后台切换" class="headerlink" title="监测应用前后台切换"></a>监测应用前后台切换</h3><p>我们经常要判断应用是否处于前后台，自从有了Lifecycle之后这个需求就很简单，不再需要去getRunningTask…。<br>之前说过Lifecycle可以按需引入。我们现在引入针对整个应用的Lifecycle</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation &quot;androidx.lifecycle:lifecycle-process:$lifecycle_version&quot; //版本建议使用当前最新的，可看官方文档</span><br></pre></td></tr></table></figure>
<p>引入之后我们的Application可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class JApplication : Application() &#123;</span><br><span class="line">    override fun onCreate() &#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">        // 通过lifecycle监测应用切换前后台操作</span><br><span class="line">        ProcessLifecycleOwner.get().lifecycle.addObserver(AppLifecycleObserver())</span><br><span class="line">        registerLifecycle()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AppLifecycleObserver : LifecycleEventObserver &#123;</span><br><span class="line">    override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) &#123;</span><br><span class="line">        when (event) &#123;</span><br><span class="line">            Lifecycle.Event.ON_RESUME -&gt; &#123;</span><br><span class="line">                LogUtils.d(&quot;当前应用处于前台&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            Lifecycle.Event.ON_STOP -&gt; &#123;</span><br><span class="line">                LogUtils.d(&quot;当前应用处于后台&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            Lifecycle.Event.ON_CREATE,</span><br><span class="line">            Lifecycle.Event.ON_START,</span><br><span class="line">            Lifecycle.Event.ON_PAUSE,</span><br><span class="line">            Lifecycle.Event.ON_DESTROY,</span><br><span class="line">            Lifecycle.Event.ON_ANY</span><br><span class="line">            -&gt; &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们当应用处于前台时一定会走到观察者的onStart、onResume，当应用处于后台时一定会走onPause、onStop。所以我们只需要观察onResume和onStop这2个节点的执行情况即可。</p>
<p>我们在JApplication的onCreate()中通过ProcessLifecycleOwner.get()获取到一个ProcessLifecycleOwner对象。然后调用其内部的Lifecycle的addObserver来实现对应用生命周期的观察，走进源码可以看到熟悉的<code>private final LifecycleRegistry mRegistry = new LifecycleRegistry(this);</code>，在前面讲原理的时候已经知道了LifecycleRegistry中要分发事件给观察者的话都是通过其内部的handleLifecycleEvent()来实现的，所以我们看下应用是在什么场景下调用了handleLifecycleEvent()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ProcessLifecycleOwner implements LifecycleOwner &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    private final LifecycleRegistry mRegistry = new LifecycleRegistry(this);</span><br><span class="line"></span><br><span class="line">    private Runnable mDelayedPauseRunnable = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            dispatchPauseIfNeeded();</span><br><span class="line">            dispatchStopIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ActivityInitializationListener mInitializationListener =</span><br><span class="line">            new ActivityInitializationListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onCreate() &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onStart() &#123;</span><br><span class="line">                    activityStarted();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onResume() &#123;</span><br><span class="line">                    activityResumed();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    private static final ProcessLifecycleOwner sInstance = new ProcessLifecycleOwner();</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    public static LifecycleOwner get() &#123;</span><br><span class="line">        return sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void init(Context context) &#123;</span><br><span class="line">        sInstance.attach(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void activityStarted() &#123;</span><br><span class="line">        mStartedCounter++;</span><br><span class="line">        if (mStartedCounter == 1 &amp;&amp; mStopSent) &#123;</span><br><span class="line">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class="line">            mStopSent = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void activityResumed() &#123;</span><br><span class="line">        mResumedCounter++;</span><br><span class="line">        if (mResumedCounter == 1) &#123;</span><br><span class="line">            if (mPauseSent) &#123;</span><br><span class="line">                mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);</span><br><span class="line">                mPauseSent = false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mHandler.removeCallbacks(mDelayedPauseRunnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void activityPaused() &#123;</span><br><span class="line">        mResumedCounter--;</span><br><span class="line">        if (mResumedCounter == 0) &#123;</span><br><span class="line">            mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void activityStopped() &#123;</span><br><span class="line">        mStartedCounter--;</span><br><span class="line">        dispatchStopIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dispatchPauseIfNeeded() &#123;</span><br><span class="line">        if (mResumedCounter == 0) &#123;</span><br><span class="line">            mPauseSent = true;</span><br><span class="line">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dispatchStopIfNeeded() &#123;</span><br><span class="line">        if (mStartedCounter == 0 &amp;&amp; mPauseSent) &#123;</span><br><span class="line">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);</span><br><span class="line">            mStopSent = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ProcessLifecycleOwner() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">    void attach(Context context) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class="line">        Application app = (Application) context.getApplicationContext();</span><br><span class="line">        app.registerActivityLifecycleCallbacks(new EmptyActivityLifecycleCallbacks() &#123;</span><br><span class="line">            @RequiresApi(29)</span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityPreCreated(@NonNull Activity activity,</span><br><span class="line">                    @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">                </span><br><span class="line">                Api29Impl.registerActivityLifecycleCallbacks(activity,</span><br><span class="line">                        new EmptyActivityLifecycleCallbacks() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void onActivityPostStarted(@NonNull Activity activity) &#123;</span><br><span class="line">                                //  onStart回调</span><br><span class="line">                                activityStarted();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            @Override</span><br><span class="line">                            public void onActivityPostResumed(@NonNull Activity activity) &#123;</span><br><span class="line">                                //  onResume回调</span><br><span class="line">                                activityResumed();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123;</span><br><span class="line">                if (Build.VERSION.SDK_INT &lt; 29) &#123;</span><br><span class="line">                    // 这是一个透明Fragment，后续有机会再详细撸 ReportFragment.get(activity).setProcessListener(mInitializationListener);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityPaused(Activity activity) &#123;</span><br><span class="line">                activityPaused();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onActivityStopped(Activity activity) &#123;</span><br><span class="line">                activityStopped();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Lifecycle getLifecycle() &#123;</span><br><span class="line">        return mRegistry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequiresApi(29)</span><br><span class="line">    static class Api29Impl &#123;</span><br><span class="line">        private Api29Impl() &#123;</span><br><span class="line">            // This class is not instantiable.</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @DoNotInline</span><br><span class="line">        static void registerActivityLifecycleCallbacks(@NonNull Activity activity,</span><br><span class="line">                @NonNull Application.ActivityLifecycleCallbacks callback) &#123;</span><br><span class="line">            activity.registerActivityLifecycleCallbacks(callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很清楚的看到ProcessLifecycleOwner中有好几个activityXXX()这样的生命周期相关的回调方法最终调用了<code>mRegistry.handleLifecycleEvent</code>，以activityStarted为例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void activityStarted() &#123;</span><br><span class="line">    mStartedCounter++;</span><br><span class="line">    if (mStartedCounter == 1 &amp;&amp; mStopSent) &#123;</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class="line">        mStopSent = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以至此，监测应用生命周期共有这几种回调值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ON_CREATE、ON_START、ON_RESUME、ON_PAUSE、ON_STOP</span><br></pre></td></tr></table></figure>
<p>现在我们只需要知道是哪里调用了这几个生命周期回调方法就等于把整个应用的生命周期监控了解清楚了</p>
<p>通过跟踪调用栈我们最终找到<code>ProcessLifecycleOwner.attach()</code>方法中回调了ON_CREATE事件，然后注册了registerActivityLifecycleCallbacks()。再往上追踪就涉及到ProcessLifecycleOwner的构建过程。</p>
<p>我们从这个对象其实早在应用刚启动时进行过初始化了，是在Androidx的startup-runtime中完成的：</p>
<img src="/2022/08/23/Jetpack-Lifecycle/startup-runtime.png" class="" title="startup-runtime">
<p><a href="https://wenku.baidu.com/view/e99e212ddd80d4d8d15abe23482fb4daa58d1dac.html">Jetpack-Startup源码解析</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class ProcessLifecycleInitializer implements Initializer&lt;LifecycleOwner&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public LifecycleOwner create(@NonNull Context context) &#123;</span><br><span class="line">        ...</span><br><span class="line">        LifecycleDispatcher.init(context);</span><br><span class="line">        ProcessLifecycleOwner.init(context);</span><br><span class="line">        return ProcessLifecycleOwner.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies() &#123;</span><br><span class="line">        return Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ProcessLifecycleOwner.init(context)</code>执行了ProcessLifecycleOwner的初始化，最终走到ProcessLifecycleOwner.attach()中<br>在attach()中会向Application对象注册ActivityLifecycleCallbacks对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Application extends ContextWrapper implements ComponentCallbacks2 &#123;</span><br><span class="line">    ...</span><br><span class="line">    public void registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks callback) &#123;</span><br><span class="line">        synchronized (mActivityLifecycleCallbacks) &#123;</span><br><span class="line">            mActivityLifecycleCallbacks.add(callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void unregisterActivityLifecycleCallbacks(ActivityLifecycleCallbacks callback) &#123;</span><br><span class="line">        synchronized (mActivityLifecycleCallbacks) &#123;</span><br><span class="line">            mActivityLifecycleCallbacks.remove(callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Object[] collectActivityLifecycleCallbacks() &#123;</span><br><span class="line">        Object[] callbacks = null;</span><br><span class="line">        synchronized (mActivityLifecycleCallbacks) &#123;</span><br><span class="line">            if (mActivityLifecycleCallbacks.size() &gt; 0) &#123;</span><br><span class="line">                callbacks = mActivityLifecycleCallbacks.toArray();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return callbacks;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPreCreated(@NonNull Activity activity,</span><br><span class="line">            @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPreCreated(activity,</span><br><span class="line">                        savedInstanceState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /* package */ void dispatchActivityCreated(@NonNull Activity activity,</span><br><span class="line">            @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks)callbacks[i]).onActivityCreated(activity,</span><br><span class="line">                        savedInstanceState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPostCreated(@NonNull Activity activity,</span><br><span class="line">            @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostCreated(activity,</span><br><span class="line">                        savedInstanceState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPreStarted(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPreStarted(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /* package */ void dispatchActivityStarted(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks)callbacks[i]).onActivityStarted(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPostStarted(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostStarted(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPreResumed(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPreResumed(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /* package */ void dispatchActivityResumed(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks)callbacks[i]).onActivityResumed(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPostResumed(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostResumed(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPrePaused(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPrePaused(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /* package */ void dispatchActivityPaused(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks)callbacks[i]).onActivityPaused(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPostPaused(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostPaused(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPreStopped(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPreStopped(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /* package */ void dispatchActivityStopped(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks)callbacks[i]).onActivityStopped(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPostStopped(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostStopped(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPreSaveInstanceState(@NonNull Activity activity,</span><br><span class="line">            @NonNull Bundle outState) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPreSaveInstanceState(</span><br><span class="line">                        activity, outState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /* package */ void dispatchActivitySaveInstanceState(@NonNull Activity activity,</span><br><span class="line">            @NonNull Bundle outState) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks)callbacks[i]).onActivitySaveInstanceState(activity,</span><br><span class="line">                        outState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPostSaveInstanceState(@NonNull Activity activity,</span><br><span class="line">            @NonNull Bundle outState) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostSaveInstanceState(</span><br><span class="line">                        activity, outState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPreDestroyed(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPreDestroyed(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /* package */ void dispatchActivityDestroyed(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i=0; i&lt;callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks)callbacks[i]).onActivityDestroyed(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span><br><span class="line">        /* package */ void dispatchActivityPostDestroyed(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPostDestroyed(activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* package */ void dispatchActivityConfigurationChanged(@NonNull Activity activity) &#123;</span><br><span class="line">        Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">        if (callbacks != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">                ((ActivityLifecycleCallbacks) callbacks[i]).onActivityConfigurationChanged(</span><br><span class="line">                        activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Application中又有一系列以dispatchActivityXXX为方法名的方法来通知所有注册进来的观察者，而什么时候调用呢，其实是在每一个Activity中调用的，以ON_CREATE为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Activity extends ContextThemeWrapper</span><br><span class="line">        implements LayoutInflater.Factory2,</span><br><span class="line">        Window.Callback, KeyEvent.Callback,</span><br><span class="line">        OnCreateContextMenuListener, ComponentCallbacks2,</span><br><span class="line">        Window.OnWindowDismissedCallback,</span><br><span class="line">        AutofillManager.AutofillClient, ContentCaptureManager.ContentCaptureClient &#123;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    dispatchActivityPostCreated(icicle);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    private void dispatchActivityPostCreated(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">    if (callbacks != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">            ((Application.ActivityLifecycleCallbacks) callbacks[i]).onActivityPostCreated(this,</span><br><span class="line">                    savedInstanceState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getApplication().dispatchActivityPostCreated(this, savedInstanceState);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>熟悉Activity启动流程的应该对这一块不会陌生吧</p>
<p>可以看出来，每个Activity执行过程中都会回调对应的生命周期给Application，然后Application再通过观察者模式分发给每一个观察者，这样我们就收到了回调。</p>
<h3 id="管理应用页面情况（维护应用Activity栈）"><a href="#管理应用页面情况（维护应用Activity栈）" class="headerlink" title="管理应用页面情况（维护应用Activity栈）"></a>管理应用页面情况（维护应用Activity栈）</h3><p>经常我们一个应用开发时都会写一个管理类来维护一份自己的Activity栈，早前的做法是在BaseActivity中的onCreate和onDestroy做对应的入栈出栈。现在不需要那么做了，直接在Application中通过<code>registerActivityLifecycleCallbacks</code>就可以实现入栈出栈，原理我们在上面已经讲过了：<strong>观察者模式</strong></p>
<p>所以现在完整的JApplication代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class JApplication : Application() &#123;</span><br><span class="line">    override fun onCreate() &#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">        // 通过lifecycle监测应用切换前后台操作</span><br><span class="line">        ProcessLifecycleOwner.get().lifecycle.addObserver(AppLifecycleObserver())</span><br><span class="line">        registerLifecycle()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun getApp(): Application &#123;</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 管理应用的页面（Activity）</span><br><span class="line">     */</span><br><span class="line">    private fun registerLifecycle() &#123;</span><br><span class="line">        registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacks &#123;</span><br><span class="line">            override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) &#123;</span><br><span class="line">                AppManager.addActivity(activity)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onActivityStarted(activity: Activity) &#123;&#125;</span><br><span class="line">            override fun onActivityResumed(activity: Activity) &#123;</span><br><span class="line">//                AppManager.getInstance().setCurrentActivity(activity)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onActivityPaused(activity: Activity) &#123;&#125;</span><br><span class="line">            override fun onActivityStopped(activity: Activity) &#123;&#125;</span><br><span class="line">            override fun onActivitySaveInstanceState(activity: Activity, outState: Bundle) &#123;&#125;</span><br><span class="line">            override fun onActivityDestroyed(activity: Activity) &#123;</span><br><span class="line">                AppManager.killActivity(activity)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="监控Activity生命周期"><a href="#监控Activity生命周期" class="headerlink" title="监控Activity生命周期"></a>监控Activity生命周期</h3><p>监控Activity生命周期也很简单，继承有Lifecycle功能的Activity（如AppCompactActivity）然后获取其内部的Lifecycle，执行<code>addObserver()</code>，一切搞定。为了让代码更加优雅一点我封装了一个BaseActivity，并且未来准备搭配ViewModel使用所以又封装了一个ActivityViewModel</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  抽象针对Activity页面的ViewModel</span><br><span class="line"> *</span><br><span class="line"> *  ViewModel拥有自己独立的生命周期，可保证Activity被重建时数据不会丢失</span><br><span class="line"> *</span><br><span class="line"> *  可在此ViewModel中实现一些基础功能，例如生命周期监测</span><br><span class="line"> */</span><br><span class="line">open class ActivityViewModel : ViewModel(), DefaultLifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(owner: LifecycleOwner) &#123;</span><br><span class="line">        LogUtils.d(&quot;$&#123;owner.javaClass.simpleName&#125; invoke onCreate&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onStart(owner: LifecycleOwner) &#123;</span><br><span class="line">        LogUtils.d(&quot;$&#123;owner.javaClass.simpleName&#125; invoke onStart&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onResume(owner: LifecycleOwner) &#123;</span><br><span class="line">        LogUtils.d(&quot;$&#123;owner.javaClass.simpleName&#125; invoke onResume&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onPause(owner: LifecycleOwner) &#123;</span><br><span class="line">        LogUtils.d(&quot;$&#123;owner.javaClass.simpleName&#125; invoke onPause&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onStop(owner: LifecycleOwner) &#123;</span><br><span class="line">        LogUtils.d(&quot;$&#123;owner.javaClass.simpleName&#125; invoke onStop&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDestroy(owner: LifecycleOwner) &#123;</span><br><span class="line">        LogUtils.d(&quot;$&#123;owner.javaClass.simpleName&#125; invoke onDestroy&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class BaseActivity&lt;T : ActivityViewModel&gt; : ComponentActivity() &#123;</span><br><span class="line">    var viewModel: T? = null</span><br><span class="line">        get() = field</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        viewModel = bindViewModel()</span><br><span class="line">        viewModel?.let &#123; lifecycle.addObserver(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract fun bindViewModel(): T?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此一来每个Activity页面只需要继承BaseActivity并提供页面对应的ActivityViewModel子类即可实现生命周期监测的能力。</p>
<h3 id="监控Fragment生命周期"><a href="#监控Fragment生命周期" class="headerlink" title="监控Fragment生命周期"></a>监控Fragment生命周期</h3><p>Fragment中使用Lifecycle和Activity很相似，内部实现原理也是Fragment中提供一个Lifecycle实现类供开发者插入观察者，然后FragmentStateManager会在Fragment处于不同的生命周期调用对应的生命周期回调，开发者只需要在Fragment中addObserver即可。不详细说了</p>
<h3 id="监控Service生命周期"><a href="#监控Service生命周期" class="headerlink" title="监控Service生命周期"></a>监控Service生命周期</h3><p>Service中使用Lifecycle监控Service的生命周期更加简单，只需继承<code>LifecycleService</code>类然后在Service中写入<code>lifecycle.addObserver(ServiceLifecycleObserver())</code>即可实现，原理特别简单相信大家一看就看得懂。</p>
<p>本质上是系统提供一个<code>ServiceLifecycleDispatcher</code>类，该类内部会返回一个Lifecycle供开发者插入观察者等功能。然后又提供一系列生命周期相关的调用方法，<code>LifecycleService</code>做了个简单的封装在onCreate等声明周期方法中调用了<code>mDispatcher.onServicePreSuperOnCreate();</code>这样来通知观察者，我又简单抽象了一个基类来适配Android8.0应用处于后台时无法启动Service的兼容逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 后来发现这个类实际上Android系统已经提供了一个一模一样的类：LifecycleService</span><br><span class="line"> * 所以此处将生命周期相关代码注释并且直接继承LifecycleService</span><br><span class="line"> */</span><br><span class="line">abstract class JService : LifecycleService() /*Service(), LifecycleOwner*/ &#123;</span><br><span class="line"></span><br><span class="line">    fun startForegroundNotification(channelId: String, notificationId: Int) &#123;</span><br><span class="line">        if (SystemUtils.isOverO8()) &#123;</span><br><span class="line">            val channel = NotificationChannel(</span><br><span class="line">                packageName,</span><br><span class="line">                channelId,</span><br><span class="line">                NotificationManager.IMPORTANCE_LOW</span><br><span class="line">            )</span><br><span class="line">            val manager = getSystemService(NOTIFICATION_SERVICE)?.let &#123; it as NotificationManager &#125;</span><br><span class="line">            manager?.createNotificationChannel(channel)</span><br><span class="line">            val notification = Notification.Builder(</span><br><span class="line">                this,</span><br><span class="line">                packageName</span><br><span class="line">            ).build()</span><br><span class="line">            startForeground(notificationId, notification)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    private val mDispatcher: ServiceLifecycleDispatcher = ServiceLifecycleDispatcher(this)</span><br><span class="line">//</span><br><span class="line">//    override fun getLifecycle(): Lifecycle &#123;</span><br><span class="line">//        return mDispatcher.lifecycle</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    fun onServicePreSuperOnCreate() &#123;</span><br><span class="line">//        mDispatcher.onServicePreSuperOnCreate()</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    fun onServicePreSuperOnStart() &#123;</span><br><span class="line">//        mDispatcher.onServicePreSuperOnStart()</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    fun onServicePreSuperOnBind() &#123;</span><br><span class="line">//        mDispatcher.onServicePreSuperOnBind()</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    fun onServicePreSuperOnDestroy() &#123;</span><br><span class="line">//        mDispatcher.onServicePreSuperOnDestroy()</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Jetpack-LiveData</title>
    <url>/2022/09/15/Jetpack-LiveData/</url>
    <content><![CDATA[<h2 id="LiveData简介"><a href="#LiveData简介" class="headerlink" title="LiveData简介"></a>LiveData简介</h2><p><a href="https://developer.android.google.cn/reference/androidx/lifecycle/LiveData">LiveData</a>是一种可观察的数据存储器类。与常规的可观察类不同，LiveData具有生命周期感知能力，意指它遵循其他应用组件（如activity、fragment或service）的生命周期。这种感知能力可确保LiveData仅更新处于活跃生命周期状态的应用组件观察者。</p>
<p>如果观察者（由 Observer类表示）的生命周期<strong>处于STARTED或RESUMED状态</strong>，则LiveData会认为该观察者处于活跃状态。LiveData只会将更新通知给活跃的观察者。为观察LiveData对象而注册的非活跃观察者不会收到更改通知。</p>
<p>您可以注册与实现LifecycleOwner接口的对象配对的观察者。有了这种关系，当相应的Lifecycle对象的状态变为DESTROYED时，便可移除此观察者。这对于activity和fragment特别有用，因为它们可以放心地观察 LiveData 对象，而不必担心内存泄露（当 activity 和 fragment 的生命周期被销毁时，系统会立即退订它们）。</p>
<p>LiveData一般声明在ViewModel中搭配ViewModel一起使用。</p>
<h2 id="使用-LiveData-的优势"><a href="#使用-LiveData-的优势" class="headerlink" title="使用 LiveData 的优势"></a>使用 LiveData 的优势</h2><ol>
<li><strong>确保界面符合数据状态</strong><blockquote>
<p>LiveData 遵循观察者模式。当底层数据发生变化时，LiveData会通知 Observer对象。您可以整合代码以在这些Observer对象中更新界面。这样一来，您无需在每次应用数据发生变化时更新界面，因为观察者会替您完成更新。</p>
</blockquote>
</li>
<li><strong>不会发生内存泄漏</strong><blockquote>
<p>观察者会绑定到Lifecycle对象，并在其关联的生命周期遭到销毁后进行自我清理。</p>
</blockquote>
</li>
<li><strong>不会因 Activity 停止而导致崩溃</strong><blockquote>
<p>如果观察者的生命周期处于非活跃状态（如返回堆栈中的activity），它便不会接收任何LiveData事件。</p>
</blockquote>
</li>
<li><strong>不再需要手动处理生命周期</strong><blockquote>
<p>界面组件只是观察相关数据，不会停止或恢复观察。LiveData会在内部自动管理所有这些操作，因为它在观察时可以通过LifecycleOwner感知相关的生命周期状态变化。</p>
</blockquote>
</li>
<li><strong>数据始终保持最新状态</strong><blockquote>
<p>如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据，并且如果在非活跃状态时数据经过了多次变化也只会收到最新的那次的通知。例如，曾经在后台的Activity会在返回前台后立即接收最新的数据。</p>
</blockquote>
</li>
<li><strong>适当的配置更改</strong><blockquote>
<p>如果由于配置更改（如设备旋转）而重新创建了activity或fragment，它会立即接收最新的可用数据。当然这也归功于其LiveData和ViewModel的搭配使用，这样才能是的LiveData在配置更改后依然保留在内存中。</p>
</blockquote>
</li>
<li><strong>共享资源</strong><blockquote>
<p>您可以使用单例模式扩展LiveData对象以封装系统服务，以便在应用中共享它们。LiveData对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察LiveData对象。如需了解详情，请参阅<a href="https://developer.android.google.cn/topic/libraries/architecture/livedata.html#extend_livedata">扩展LiveData</a>。</p>
</blockquote>
</li>
</ol>
<h2 id="LiveData的简单使用"><a href="#LiveData的简单使用" class="headerlink" title="LiveData的简单使用"></a>LiveData的简单使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MainViewModel : ViewModel() &#123;</span><br><span class="line">    val userName: MutableLiveData&lt;String&gt; by lazy &#123;</span><br><span class="line">        MutableLiveData&lt;String&gt;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    val viewModel: ViewModel by lazy &#123;</span><br><span class="line">        ViewModelProvider(this).get(MainViewModel::class.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        initView()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun initView() &#123;</span><br><span class="line"></span><br><span class="line">        txtName = findViewById(R.id.txt_name)</span><br><span class="line">        btnChangeInMain = findViewById(R.id.btn_change_in_main)</span><br><span class="line">        btnChangeInOther = findViewById(R.id.btn_change_in_other)</span><br><span class="line">        </span><br><span class="line">        demoLiveData()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun demoLiveData() &#123;</span><br><span class="line">        viewModel?.userName?.observe(this) &#123; txtName?.text = &quot;NAME:$it&quot; &#125;</span><br><span class="line">        viewModel?.userName?.observe(this) &#123;</span><br><span class="line">            Toast.makeText(this, &quot;USERNAME改变&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        btnChangeInMain?.setOnClickListener &#123;</span><br><span class="line">            viewModel?.userName?.value = &quot;MAIN&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnChangeInOther?.setOnClickListener &#123;</span><br><span class="line">            val thread = Thread &#123;</span><br><span class="line">                viewModel?.userName?.postValue(&quot;OTHER&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            SystemClock.sleep(2000)</span><br><span class="line">            thread.start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中以最简单的<code>MutableLiveData</code>为例，它继承自抽象类<code>LiveData</code>。</p>
<ul>
<li>我们在MainViewModel中用MutableLiveData容器存储一个String类型的userName</li>
<li>在页面中使用observe()方法传入Observer观察者对象和LifecycleOwner对象使得userName内数据发生变化时或者页面生命周期发生变化时会将userName最新的值回调到Observer的onChanged()方法中。</li>
</ul>
<h2 id="LiveData原理解析"><a href="#LiveData原理解析" class="headerlink" title="LiveData原理解析"></a>LiveData原理解析</h2><p>讲解LiveData之前最好是先对<strong>Lifecycle</strong> 和<strong>ViewModel</strong> 的实现原理有足够的了解否则对本文阅读可能有点不知所云，特别是对了解《页面生命周期变化时如何将最新的LiveData数据通知给数据观察者以达到更新UI的目的》这部分会比较难理解。</p>
<p>如果不了解可以看我前面2篇文章：<a href="https://lianwenhong.top/2022/08/23/Jetpack-Lifecycle/">Jetpack-Lifecycle</a>，<a href="https://lianwenhong.top/2022/09/06/Jetpack-ViewModel/">Jetpack-ViewModel</a></p>
<p>从2个角度来分析LiveData的运行原理：LiveData观察者绑定<strong>LiveData-&gt;observe()</strong> 和LiveData数据发生改变 <strong>LiveData-&gt;setValue()</strong></p>
<p>在讲解过程中我们将实现<code>LifecycleEventObserver</code>的接口称为生命周期观察者，将<code>ObserverWrapper</code>的实现类称为数据观察者，这两者所观察的目标不一样，前者观察页面的生命周期，后者观察LiveData的value变化。</p>
<h3 id="1-LiveData-gt-observe"><a href="#1-LiveData-gt-observe" class="headerlink" title="1. LiveData-&gt;observe()"></a>1. LiveData-&gt;observe()</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    // 1.注册过程必须在主线程执行</span><br><span class="line">    assertMainThread(&quot;observe&quot;);</span><br><span class="line">    // 2.注册过程必须是LifecycleOwner处于活跃状态，也就是页面处于活跃状态</span><br><span class="line">    if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        // ignore</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.封装一个生命周期感知的观察者包装类LifecycleBoundObserver(把注册进来的observer包装成 一个具有生命周边边界的观察者，其能感知LifecycleOwner的生命周期变化)</span><br><span class="line">    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    // 4.判断观察者是否已经存在并且同一个观察者只能感知一个页面的生命周期</span><br><span class="line">    if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot add the same observer&quot;</span><br><span class="line">                + &quot; with different lifecycles&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (existing != null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 5.将wrapper注册进LifecycleOwner对应的生命周期观察者列表中，这样才最终实现LifecycleBoundObserver对LifecycleOwner的生命周期感知</span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个注册过程并不复杂</p>
<ul>
<li>先判断当前是否处于主线程，因为其实LiveData主要的作用就是让页面能及时响应数据的变化，而UI改变需要在主线程中执行，所以这一步也是可以理解的</li>
<li>判断当前页面是否处于活跃状态，如果此时传入的页面对应的LifecycleOwner生命周期处于非活跃状态则不进行观察，例如如果页面已经被关闭或者处于后台中，那你观察该数据来更新UI对于用户也是无感知的，所以没有意义。如果你非要在后台更新数据，那么你可以直接使用observeForever(@NonNull Observer&lt;? super T&gt; observer)这个方法来实现，后果是你得自己去维护这个LiveData与观察者的解除绑定关系。</li>
<li>将LifecycleOwner和Observer封装在一个LifecycleBoundObserver包装类中并保存在LiveData的mObservers中以便后续数据发生变化时能及时响应到各个观察者中，LifecycleBoundObserver可以感知LifecycleOwner的生命周期变化，因为其实现了<code>LifecycleEventObserver</code>接口，下面再详解</li>
<li>在使用过程中需要注意第4点，同一个Observer数据观察者绑定的LifecycleOwner必须是同一个否则会抛异常。也不难理解，假如同一个数据观察者绑定的页面不一样那么2个页面的生命周期不一样时数据观察者应该响应哪个页面的生命周期就是个问题！</li>
<li>最后将该LifecycleBoundObserver包装类注册给LifecycleOwner，这样当页面生命周期发生变化时就会回调到LifecycleBoundObserver-&gt;onStateChanged()方法中，在onStateChanged中就会在合适的时机去通知观察者LiveData的数据发生变化了，需要更新UI的请开始吧</li>
</ul>
<p>LifecycleBoundObserver是LiveData的内部类，LiveData通过这个内部类将观察者（Observer）和页面的生命周期组合在一起使得每一个观察者都对应响应一个页面的生命周期（LifecycleOwner）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver &#123;</span><br><span class="line">    @NonNull</span><br><span class="line">    final LifecycleOwner mOwner; // 用来获取页面最新生命周期以及判断数据观察者重新绑定时LifecycleOwner是否是同一个</span><br><span class="line"></span><br><span class="line">    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">        super(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean shouldBeActive() &#123;</span><br><span class="line">        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当mOwner对应的页面生命周期发生变化时，Lifecycle会回调该方法并传入最新的生命周期状态通知该生命周期观察者</span><br><span class="line">    @Override</span><br><span class="line">    public void onStateChanged(@NonNull LifecycleOwner source,</span><br><span class="line">            @NonNull Lifecycle.Event event) &#123;</span><br><span class="line">        Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">        // 当页面处于非活跃状态时移除数据观察者，这样能避免没必要的通知提升效率。</span><br><span class="line">        // 这就是为什么在Fragment中使用LiveData时observe中应该传入viewLifecycleOwner而不是传入this，后面再详解</span><br><span class="line">        if (currentState == DESTROYED) &#123;</span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Lifecycle.State prevState = null;</span><br><span class="line">        while (prevState != currentState) &#123;</span><br><span class="line">            prevState = currentState;</span><br><span class="line">            // 页面生命周期变化原因通知数据观察者的入口</span><br><span class="line">            activeStateChanged(shouldBeActive());</span><br><span class="line">            currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean isAttachedTo(LifecycleOwner owner) &#123;</span><br><span class="line">        return mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 移除生命周期观察者</span><br><span class="line">    @Override</span><br><span class="line">    void detachObserver() &#123;</span><br><span class="line">        mOwner.getLifecycle().removeObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void activeStateChanged(boolean newActive) &#123;</span><br><span class="line">    // 如果页面的活跃状态并没有发生变化就直接return，这是一个优化避免不必要的重复通知</span><br><span class="line">    if (newActive == mActive) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // immediately set active state, so we&#x27;d never dispatch anything to inactive</span><br><span class="line">    // owner</span><br><span class="line">    mActive = newActive;</span><br><span class="line">    // 更新一下当前LiveData中有多少个活跃的页面中有数据观察者正在观察它的value，活跃页面数量0-1调用：onActive()，1-0调用：onInactive()。</span><br><span class="line">    // 不重要，好像是有时候用于判断LiveData是否开始正常工作</span><br><span class="line">    changeActiveCounter(mActive ? 1 : -1);</span><br><span class="line">    if (mActive) &#123;</span><br><span class="line">        // 如果页面从非活跃变为活跃状态，则开始处理通知数据观察者的逻辑。</span><br><span class="line">        dispatchingValue(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>LifecycleBoundObserver内部主要工作是监听页面的生命周期变化并在收到生命周期变化回调时及时响应给LiveData的数据观察者。</li>
<li>其实LifecycleBoundObserver只关注页面是否存在活跃和非活跃状态之间的切换而不关心具体处于哪个生命周期。这也不难理解，监听页面生命周期无非就是想要在页面从非活跃到活跃状态时能及时的刷新页面上的UI，如果不存在非活跃到活跃状态的切换时并没有必要去刷新页面，例如在页面从STARTED-&gt;RESUMED时页面一直处于活跃状态，这时候activeStateChanged()直接执行了return。因为在这过程中首先STARTED中肯定已经通知过数据观察者一次了，即使STARTED-&gt;RESUMED过程中LiveData.value又发生过改变就会执行setValue()，setValue()中会通知该LiveData的所有数据观察者，所以在这里也没有必要再重复通知。</li>
<li>真正的分发是dispatchingValue(this);注意这里传入的是this，我们放在setValue()流程时再一起解析它</li>
</ul>
<h3 id="2-LiveData-gt-setValue"><a href="#2-LiveData-gt-setValue" class="headerlink" title="2. LiveData-&gt;setValue()"></a>2. LiveData-&gt;setValue()</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">protected void setValue(T value) &#123;</span><br><span class="line">    // 这是主线程更新值的方式，在子线程中调用就会报错</span><br><span class="line">    assertMainThread(&quot;setValue&quot;);</span><br><span class="line">    // LiveData数据的每一次改动都会促使这个版本号+1，后续当需要通知给观察者时会使用这个值和每个数据观察者内部的版本做判断，如果mVersion版本比较高才会回调onChanged()</span><br><span class="line">    mVersion++;</span><br><span class="line">    // 赋值，这就是真正</span><br><span class="line">    mData = value;</span><br><span class="line">    // 通知数据观察者，此处传入的是null</span><br><span class="line">    dispatchingValue(null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;WeakerAccess&quot;) /* synthetic access */</span><br><span class="line">void dispatchingValue(@Nullable ObserverWrapper initiator) &#123;</span><br><span class="line">    if (mDispatchingValue) &#123;</span><br><span class="line">        // 如果当前正处于在通知数据观察者阶段，则将其设置为无效</span><br><span class="line">        mDispatchInvalidated = true;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = true;</span><br><span class="line">    do &#123;</span><br><span class="line">        mDispatchInvalidated = false;</span><br><span class="line">        // 这是页面生命周期变化触发的通知数据观察者更新</span><br><span class="line">        if (initiator != null) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 这是调用setValue()或者postValue()触发的通知数据观察者更新</span><br><span class="line">            for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                if (mDispatchInvalidated) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (mDispatchInvalidated);</span><br><span class="line">    mDispatchingValue = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private void considerNotify(ObserverWrapper observer) &#123;</span><br><span class="line">    // 如果当前数据观察者绑定的页面为非活跃状态，则直接return不通知</span><br><span class="line">    if (!observer.mActive) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span><br><span class="line">    //</span><br><span class="line">    // we still first check observer.active to keep it as the entrance for events. So even if</span><br><span class="line">    // the observer moved to an active state, if we&#x27;ve not received that event, we better not</span><br><span class="line">    // notify for a more predictable notification order.</span><br><span class="line">    // 如果在多线程情况下数据观察者绑定的页面生命周期又发生了变化从活跃变为非活跃，那也不更新并且将这个数据观察者内部的活跃状态更新一下</span><br><span class="line">    if (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(false);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果数据观察者内部的版本号&gt;=当前要更新的数据的版本号那说明数据已经被更新过了，不需要重复更新，return掉</span><br><span class="line">    if (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    // 最终调用了数据观察者的onChanged()方法</span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实LiveData.setValue()过程很简单，主要做的就是<code>mData = value;</code>给LiveData的数据赋值，然后<code>observer.mObserver.onChanged((T) mData);</code>通知给数据观察者说我的值发生了变化。</p>
<p>既然只做了这么点儿事为什么有这么一大堆的代码，还有什么版本判断啊各种？其实这些代码只是为了兼容多线程场景避免数据失效和冗余通知让逻辑更加健壮而已，对于我们普通开发者其实并不会遇到多线程中通知数据观察者的情况。只有当Lifecycle触发生命周期回调时才有可能出现多线程场景，也就是说<code>LifecycleBoundObserver.onStateChanged()</code>存在多线程的可能（原因结尾再说，不是本章重点）。</p>
<p><strong>dispatchingValue(@Nullable ObserverWrapper initiator)的2种取值</strong></p>
<ul>
<li>页面生命周期回调中通知数据观察者时传入的是this，通过内部的代码逻辑可以看出当initiator有值时只通知给initiator这个观察者，这很好理解，当某个页面生命周期发生变化时，肯定我们只想通知在该页面中监听LiveData的数据观察者去刷新页面，没必要把这个LiveData的全部数据观察者都刷新一遍，因为其他页面中注册的数据观察者完全会在它自己所属的页面从非活跃到活跃状态切换时得到通知。</li>
<li>而当setValue(null)时是因为数据源发生了变更而发出的通知，肯定要让所有数据观察者都知道这个数据的变化，即使某些页面处于非活跃状态本次更新并不会立马被渲染到页面上那也得通知以便更新数据观察者内部的数据源以及mVersion版本号。</li>
<li>dispatchingValue()处理过程是先判断当前是否有正在分发的通知，如果有则将mDispatchInvalidated置为true表示将正在分发的通知置为无效，下面的动do-while循环会继续通过判断mDispatchInvalidated的值来确保最新的值能通知给数据观察者。当然，这一过程是一个多线程下可能发生的场景，所以正常使用的情况下其实不需要关心这一套逻辑，只需要知道dispatchingValue()方法最终调用了considerNotify()方法去最终通知数据观察者。</li>
</ul>
<p>considerNotify()处理过程只要熬过了3个if那么就能真正通知到数据观察者(onChanged)。1、先判断当前数据观察者绑定的页面还是否处于活跃状态，2、再重新获取一次数据观察者绑定的页面生命周期状态值避免多线程情况下页面生命周期已经发生变化并且数据观察者内部还没及时更新这个状态，因为毕竟observer.mActive是在别的方法写的。3、判断数据观察者最后一次收到通知时数据的版本号，只有版本号小于数据当前的版本号才说明数据有更新。满足这三个if之后最终onChanged()才能得到执行，流程完毕。</p>
<h3 id="LiveData-gt-postValue-如何保证线程安全"><a href="#LiveData-gt-postValue-如何保证线程安全" class="headerlink" title="LiveData-&gt;postValue()如何保证线程安全?"></a>LiveData-&gt;postValue()如何保证线程安全?</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final Object mDataLock = new Object();</span><br><span class="line"></span><br><span class="line">private final Runnable mPostValueRunnable = new Runnable() &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Object newValue;</span><br><span class="line">        synchronized (mDataLock) &#123;</span><br><span class="line">            newValue = mPendingData;</span><br><span class="line">            mPendingData = NOT_SET;</span><br><span class="line">        &#125;</span><br><span class="line">        setValue((T) newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">protected void postValue(T value) &#123;</span><br><span class="line">    boolean postTask;</span><br><span class="line">    synchronized (mDataLock) &#123;</span><br><span class="line">        postTask = mPendingData == NOT_SET;</span><br><span class="line">        mPendingData = value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!postTask) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先postValue()是通过Handler将LiveData数据源更新的逻辑从子线程发送到主线程中去执行，并且通过同步锁的方式实现线程安全。具体实现是将newValue和mPendingData的赋值过程加锁保证当主线程正在执行newValue数据更新之前如果子线程再次调用postValue()会被直接过滤掉后面这次postValue()然后主线程会使用最新的newValue去执行setValue()。即保证了性能上的优化过滤掉了不必要的setValue()流程又保证了值的准确性。</p>
<h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><ol>
<li>LiveData-&gt;observer(lifecycleOwner,observer)时不要把同一个observer对象和不同的lifecycleOwner绑定否则会抛出异常</li>
<li>在Fragment中使用LiveData时请使用viewLifecycleOwner而不要使用Fragment或者Activity实例</li>
<li>也可以通过observeForever()来设置一个不在乎页面生命周期的数据观察者，此时不管设置监听时处于什么页面也不管页面是否活跃都会收到LiveData数据变化的通知，但是这种监听需要我们手动去解除绑定</li>
</ol>
<p>随便说说LiveData存储结构：</p>
<img src="/2022/09/15/Jetpack-LiveData/LiveData%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg" class="" title="LiveData存储结构">


<p>遗留问题：<br><strong>LiveData粘性事件</strong></p>
<p><strong>Fragment中使用LiveData为什么要传入viewLifecycleOwner?</strong></p>
<p><strong>为什么LiveData-&gt;setValue()-&gt;dispatchingValue()过程中会有多线程的场景兼容？</strong></p>
<p>还有一些关于LiveData的知识点由于篇幅原因放在下一篇文章中：<a href="https://lianwenhong.top/2022/09/17/Jetpack-LiveData%E5%8E%9F%E7%90%86%E8%A1%A5%E5%85%85/">Jetpack-LiveData 原理补充</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Jetpack-LiveData原理补充</title>
    <url>/2022/09/17/Jetpack-LiveData%E5%8E%9F%E7%90%86%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>本篇主要分析LiveData的三个问题，阅读本文需要实现对LiveData的原理有一定的了解，如果不了解可以参考上一篇文章：<a href="https://lianwenhong.top/2022/09/15/Jetpack-LiveData/">Jetpack-LiveData</a></p>
<h3 id="LiveData粘性事件"><a href="#LiveData粘性事件" class="headerlink" title="LiveData粘性事件"></a>LiveData粘性事件</h3><p>可以尝试一下在LiveData数据更新之后再去注册数据观察者监听，你会发现数据观察者依然会收到最新值的通知：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">btnChangeInMain?.setOnClickListener &#123;</span><br><span class="line">    viewModel?.userName?.value = &quot;MAIN&quot;</span><br><span class="line">    viewModel?.userName?.observe(this) &#123; txtName?.text = &quot;NAME:$it&quot; &#125;</span><br><span class="line">    // viewModel?.userName?.observeForever&#123;txtName?.text = &quot;NAME:$it&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那是因为LiveData处理了这种粘性事件</p>
<ul>
<li>在observe()过程中因为<code>owner.getLifecycle().addObserver(wrapper);</code>会给observer和LifecycleOwner做页面生命周期绑定，而Lifecycle本身不管你在哪个生命周期中执行addObserver(wrapper)都会将所有生命周期状态回调通知给生命周期观察者（具体代码在LifecycleRegistry-&gt;sync()），也就是说Lifecycle本身就具备粘性观察的能力，所以不管时机注册数据观察者都会在其内部的onStateChanged()方法收到最新的生命周期回调并执行通知数据观察者的逻辑。</li>
<li>observeForever()是因为其内部直接执行了<code>wrapper.activeStateChanged(true);</code>将最新的值通知给了数据观察者</li>
</ul>
<h3 id="Fragment中使用LiveData为什么要传入viewLifecycleOwner"><a href="#Fragment中使用LiveData为什么要传入viewLifecycleOwner" class="headerlink" title="Fragment中使用LiveData为什么要传入viewLifecycleOwner?"></a>Fragment中使用LiveData为什么要传入viewLifecycleOwner?</h3><p>在Fragment中对LiveData对象调用observe方法时，如果传递的LifecycleOwner参数为this即Fragment时，会收到Android Studio的红色波浪线提示建议我们使用viewLifecycleOwner。其实我们忽略这个报错直接运行也是没问题的因为Fragment和viewLifecycleOwner的类型FragmentViewLifecycleOwner都实现了LifecycleOwner接口。但是这个红色波浪线提示是Google有意为之，原因是因为viewLifecycleOwner的生命周期和Fragment的生命周期并不相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void performCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,</span><br><span class="line">        @Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mPerformedCreateView = true;</span><br><span class="line">    mViewLifecycleOwner = new FragmentViewLifecycleOwner(this, getViewModelStore());</span><br><span class="line">    mView = onCreateView(inflater, container, savedInstanceState);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void performDestroyView() &#123;</span><br><span class="line">    mChildFragmentManager.dispatchDestroyView();</span><br><span class="line">    if (mView != null &amp;&amp; mViewLifecycleOwner.getLifecycle().getCurrentState()</span><br><span class="line">                    .isAtLeast(Lifecycle.State.CREATED)) &#123;</span><br><span class="line">        // 此处回调到LiveData-&gt;LifecycleBoundObserver-&gt;onStateChanged()时状态为DESTROYED所以LiveData会将绑定了mViewLifecycleOwner的数据观察者移除</span><br><span class="line">        mViewLifecycleOwner.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    &#125;</span><br><span class="line">    mState = CREATED;</span><br><span class="line">    mCalled = false;</span><br><span class="line">    onDestroyView();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void performDestroy() &#123;</span><br><span class="line">    mChildFragmentManager.dispatchDestroy();</span><br><span class="line">    // Fragment在此时才会给生命周期观察者发送ON_DESTROY事件</span><br><span class="line">    // 如果此时LiveData使用Fragment执行observe()方法那么也就是到这里才会执行上述的移除数据观察者操作</span><br><span class="line">    mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    mState = ATTACHED;</span><br><span class="line">    mCalled = false;</span><br><span class="line">    mIsCreated = false;</span><br><span class="line">    onDestroy();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，mViewLifecycleOwner的创建时机在Fragment的onCreateView()，并且在Fragment的onDestroyView()生命周期之前就执行了<code>mViewLifecycleOwner.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);</code>通知生命周期观察者页面走到ON_DESTROY状态，对于LiveData来说就是接收到页面处于从活跃到非活跃状态变化的通知此时就会将该页面中绑定的数据观察者执行removeObserver()操作。而Fragment则是在performDestroy()方法中也就是onDestroyView()之后onDestroy()之前才执行<code>mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY)</code>。</p>
<p>在Fragment没有执行addToBackStack()操作的时候其实LiveData.observe(viewLifecycleOwner,observer)和LiveData.observe(this,observer)没有什么区别，只有在Fragment执行了addToBackStack()问题才会暴露出来，先了解一下Fragment的生命周期：</p>
<img src="/2022/09/17/Jetpack-LiveData%E5%8E%9F%E7%90%86%E8%A1%A5%E5%85%85/Fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class="" title="Fragment生命周期">
<p><strong>Fragment入back stack的过程会执行onDestroyView但不执行之后的onDestroy与onDetach，而出back stack是从onCreateView开始执行，而没有之前的onAttach与onCreate。</strong></p>
<p>所以结合Fragment的生命周期就能看出区别了。</p>
<p>假如我们在Fragment1的onCreateView()到onDestroyView()之间的任意生命周期执行如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Fragment1.kt </span><br><span class="line"></span><br><span class="line">liveData.observe(this) &#123;</span><br><span class="line">    LogUtils.d(&quot;数据变化监听:$it&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Fragment1被replace为Fragment2时执行了addToBackStack()将Fragment1加入回退栈back stack。此时执行的是Fragment1的入栈操作所以并不会走到onDestroy()生命周期所以LiveData收不到页面的DESTROY生命周期监听也就不会去执行removeObserver()操作。当Fragment2点击返回回到Fragment1时Fragment1又执行了onCreateView()生命周期，这样在onCreateView()到onDestroyView()之间执行的LiveData数据观察者绑定又被执行了一次，此时又由于每次observe时绑定的Observer对象都不是同一个就会导致同一个LiveData其实是被重复绑定了数据观察者。</p>
<h3 id="为什么LiveData-gt-setValue-gt-dispatchingValue-过程中会有多线程的场景兼容？"><a href="#为什么LiveData-gt-setValue-gt-dispatchingValue-过程中会有多线程的场景兼容？" class="headerlink" title="为什么LiveData-&gt;setValue()-&gt;dispatchingValue()过程中会有多线程的场景兼容？"></a>为什么LiveData-&gt;setValue()-&gt;dispatchingValue()过程中会有多线程的场景兼容？</h3><p>我们来看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">protected void setValue(T value) &#123;</span><br><span class="line">    必须是主线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void postValue(T value) &#123;</span><br><span class="line">    ... 最终也是回调到setValue()所以也是必须主线程</span><br><span class="line">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@MainThread</span><br><span class="line">public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    必须是主线程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@MainThread</span><br><span class="line">public void observeForever(@NonNull Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    必须是主线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>照理说LiveData的所有值更新操作和设置监听都必须在主线程进行操作，那在触发通知的过程中哪里来的多线程呢？答案在于LifecycleBoundObserver这个类。</strong><br>我们知道当页面生命周期发生变化时Lifecycle会将页面的生命周期回调给LifecycleBoundObserver.onStateChanged()这个回调。通过之前<a href="">Jetpack-Lifecycle</a>我们可以知道它是通过LifecycleOwner中的LifecycleRegistry来实现的页面观察者模式，正常情况下LifecycleRegistry的创建过程都是<code>LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);</code>所以其内部有个变量mEnforceMainThread &#x3D; enforceMainThread;会被置为true，所以生命周期变化的通知都会在主线程中执行也就是说LifecycleBoundObserver.onStateChanged()回调也会在主线程中执行。但是LifecycleRegistry中也有个方法可以实现对象创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates a new LifecycleRegistry for the given provider, that doesn&#x27;t check</span><br><span class="line"> * that its methods are called on the threads other than main.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * LifecycleRegistry is not synchronized: if multiple threads access this &#123;@code</span><br><span class="line"> * LifecycleRegistry&#125;, it must be synchronized externally.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Another possible use-case for this method is JVM testing, when main thread is not present.</span><br><span class="line"> */</span><br><span class="line">@VisibleForTesting</span><br><span class="line">@NonNull</span><br><span class="line">public static LifecycleRegistry createUnsafe(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">    return new LifecycleRegistry(owner, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个方法创建的LifecycleRegistry对象不会强制Lifecycle机制必须在主线程中执行，所以就有可能导致LifecycleBoundObserver.onStateChanged()在子线程中被回调。当然这个方法并不建议我们普通开发者使用，通常是JVM用于测试使用。</p>
<hr>
<p>参考文章：<a href="https://juejin.cn/post/6915222252506054663">为什么Fragment中要使用viewLifecycleOwner代替this</a></p>
]]></content>
  </entry>
  <entry>
    <title>Jetpack-ViewModel</title>
    <url>/2022/09/06/Jetpack-ViewModel/</url>
    <content><![CDATA[<h2 id="ViewModel简介"><a href="#ViewModel简介" class="headerlink" title="ViewModel简介"></a>ViewModel简介</h2><p>ViewModel是Android Jetpack库中的一员，旨在以注重生命周期的方式存储和管理界面相关的数据。其与生命周期强相关。</p>
<p>ViewModel主要有几点需要关注的特点：</p>
<ol>
<li>在组件（Activity&#x2F;Fragment）的生命周期中ViewModel的数据会一直保存在内存中，即便在组件发生重建时（例如当Activity屏幕旋转或者设置改变等原因导致的页面重建）也会一直存在。</li>
<li>ViewModel可以实现组件之间的数据共享，主要是通过使用相同的ViewModelStore来进行共享。Fragment可以通过Activity的ViewModelStore。或者⼦Fragment可以使⽤parentFragment的ViewModelStore来共享，或者也可以使⽤Activity的ViewModelStore共享；<strong>需要注意的是Fragment中如果是使用Activity进行数据共享的话ViewModel的释放就会跟随Activity的生命周期。</strong></li>
</ol>
<h2 id="ViewModel使用"><a href="#ViewModel使用" class="headerlink" title="ViewModel使用"></a>ViewModel使用</h2><ul>
<li>正常情况下无需单独引入 ViewModel 相关库，因为androidx.appcompat:appcompat:1.4.1会自带 Lifecycle、LiveData、ViewModel 等依赖库。</li>
<li>如果想单独引入 ViewModel 或者其其它相关扩展库可如下操作：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 模块的 build.gradle</span><br><span class="line">// ViewModel</span><br><span class="line">implementation &#x27;androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.1&#x27;</span><br><span class="line">// 用于 Compose 的 ViewModel 实用程序</span><br><span class="line">implementation &#x27;androidx.lifecycle:lifecycle-viewmodel-compose:2.4.1&#x27;</span><br><span class="line">// ViewModel 的已保存状态模块</span><br><span class="line">implementation &#x27;androidx.lifecycle:lifecycle-viewmodel-savedstate:2.4.1&#x27;</span><br><span class="line"></span><br><span class="line">// 只有 Lifecycles（不带 ViewModel 或 LiveData）</span><br><span class="line">implementation &#x27;androidx.lifecycle:lifecycle-runtime-ktx:2.4.1&#x27;</span><br><span class="line">// 注释处理器</span><br><span class="line">kapt &#x27;androidx.lifecycle:lifecycle-compiler:2.4.1&#x27;</span><br><span class="line">// 替换 - 如果使用 Java8，请使用此注释处理器，而不是 lifecycle-compiler 注释处理器</span><br><span class="line">implementation &#x27;androidx.lifecycle:lifecycle-common-java8:2.4.1&#x27;</span><br><span class="line">// 可选 - 在 Service 中实现 LifecycleOwner 的助手</span><br><span class="line">implementation &#x27;androidx.lifecycle:lifecycle-service:2.4.1&#x27;</span><br><span class="line">// 可选 - ProcessLifecycleOwner 给整个 App 前后台切换提供生命周期监听</span><br><span class="line">implementation &#x27;androidx.lifecycle:lifecycle-process:2.4.1&#x27;</span><br><span class="line"></span><br><span class="line">// LiveData</span><br><span class="line">implementation &#x27;androidx.lifecycle:lifecycle-livedata-ktx:2.4.1&#x27;</span><br><span class="line">// 可选：对 LiveData 的 ReactiveStreams 支持</span><br><span class="line">implementation &#x27;androidx.lifecycle:lifecycle-reactivestreams-ktx:2.4.1&#x27;</span><br><span class="line">// 可选 - LiveData 的测试助手</span><br><span class="line">testImplementation &#x27;androidx.arch.core:core-testing:2.1.0&#x27;</span><br></pre></td></tr></table></figure>
先从一个简单的使用代码来证实一下刚才说的特点1:ViewModel类让数据可在发生屏幕旋转等配置更改后继续留存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MainViewModel : ViewModel() &#123;</span><br><span class="line">    var number: Int = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainActivity : BaseActivity&lt;MainViewModel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    private var btnPlus: Button? = null</span><br><span class="line">    private var btnSub: Button? = null</span><br><span class="line"></span><br><span class="line">    private var number = 0</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        // 获取一个MainViewModel</span><br><span class="line">        ViewModelProvider(this).get(MainViewModel::class.java)</span><br><span class="line">        initView()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun initView() &#123;</span><br><span class="line">        btnPlus = findViewById(R.id.btn_plus)</span><br><span class="line">        btnSub = findViewById(R.id.btn_sub)</span><br><span class="line"></span><br><span class="line">        btnPlus?.setOnClickListener &#123;</span><br><span class="line">            number = 100</span><br><span class="line">            viewModel?.number = 100</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        btnSub?.setOnClickListener &#123;</span><br><span class="line">            LogUtils.d(&quot;MainActivity number : $number&quot;)</span><br><span class="line">            LogUtils.d(&quot;MainViewModel number : $&#123;viewModel?.number&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 只有manifest文件中该Activity设置android:configChanges=&quot;orientation|screenSize&quot;时才会调用此回调，否则都是销毁重建不会走到这个回调</span><br><span class="line">     */</span><br><span class="line">    override fun onConfigurationChanged(newConfig: Configuration) &#123;</span><br><span class="line">        LogUtils.d(&quot; &gt;&gt;&gt; onConfigurationChanged &lt;&lt;&lt;&quot;)</span><br><span class="line">        super.onConfigurationChanged(newConfig)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，因为我们并没有将MainActivity在manifest中设置android:configChanges&#x3D;”orientation|screenSize”属性，所以只要切换横竖屏就会发生Activity页面重建。</p>
<p>上述代码意思是：在MainActivity和MainActivity对应的ViewModel中都声明了一个number属性。点击+号时会将两个number值都设置为100，然后切换横竖屏发生页面重建，此时我们看执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先启动应用然后点击+号</span><br><span class="line"></span><br><span class="line">紧接着点击-号时输出为：</span><br><span class="line">2022-09-01 18:35:33.137 2918-2918/com.lianwenhong.tradition_app D/JectpackFamily:  &gt;&gt;&gt; MainActivity number : 100 &lt;&lt;&lt;</span><br><span class="line">2022-09-01 18:35:33.137 2918-2918/com.lianwenhong.tradition_app D/JectpackFamily:  &gt;&gt;&gt; MainViewModel number : 100 &lt;&lt;&lt;</span><br><span class="line">将应用切换为横屏，再点击-号，此时输出为：</span><br><span class="line">2022-09-01 18:35:42.139 2918-2918/com.lianwenhong.tradition_app D/JectpackFamily:  &gt;&gt;&gt; MainActivity number : 0 &lt;&lt;&lt;</span><br><span class="line">2022-09-01 18:35:42.139 2918-2918/com.lianwenhong.tradition_app D/JectpackFamily:  &gt;&gt;&gt; MainViewModel number : 100 &lt;&lt;&lt;</span><br></pre></td></tr></table></figure>
<p>可见页面发生重建时写在MainActivity中的变量时重新创建的，而在ViewModel中保存的变量则未被重新创建而是被保留了下来。具体为什么我们后面将原理的时候再说。</p>
<p>接下来举个ViewModel共享数据的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private var txtSeekValue: TextView? = null</span><br><span class="line">    private var seekBar: SeekBar? = null</span><br><span class="line">    private var gotoFragment: TextView? = null</span><br><span class="line">    </span><br><span class="line">    private var viewModel:MainViewModel? = null</span><br><span class="line">    </span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        viewModel = ViewModelProvider(this).get(MainViewModel::class.java)</span><br><span class="line">        initView()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun initView() &#123;</span><br><span class="line"></span><br><span class="line">        txtSeekValue = findViewById(R.id.txt_seek_value)</span><br><span class="line">        seekBar = findViewById(R.id.seek)</span><br><span class="line">        gotoFragment = findViewById(R.id.btn_goto_fragment)</span><br><span class="line"></span><br><span class="line">        demoShareData()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Activity中有一个SeekBar，Fragment中也有一个SeekBar，实现两者的SeekBar值同步</span><br><span class="line">     */</span><br><span class="line">    private fun demoShareData() &#123;</span><br><span class="line">        seekBar?.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener &#123;</span><br><span class="line">            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) &#123;</span><br><span class="line">                viewModel?.seekValue = progress</span><br><span class="line">                txtSeekValue?.text = &quot;$&#123;viewModel?.seekValue&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onStartTrackingTouch(seekBar: SeekBar?) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onStopTrackingTouch(seekBar: SeekBar?) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        gotoFragment?.setOnClickListener &#123;</span><br><span class="line">            val mainFragment = MainFragment(true)</span><br><span class="line">            if (!mainFragment.isAdded) &#123;</span><br><span class="line">                val transaction = supportFragmentManager.beginTransaction()</span><br><span class="line">                transaction.add(R.id.f_me11, mainFragment)//动态添加</span><br><span class="line">                transaction.addToBackStack(&quot;main_fragment&quot;)</span><br><span class="line">                transaction.commit()//提交</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainViewModel : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    var seekValue: Int = 0</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainFragment(override val useParentViewModel: Boolean) :Fragment() &#123;</span><br><span class="line">    private var txtSeekValue: TextView? = null</span><br><span class="line">    private var seekBar: SeekBar? = null</span><br><span class="line">    private var fViewModel: ViewModel? = null</span><br><span class="line">    </span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        // 如果传入的ViewModelStoreOwner是Activity则会从对应的Activity中获取MainViewModel名称对应的ViewModel，</span><br><span class="line">        // 可以简单理解为此时fViewModel就是MainActivity中的MainViewModel</span><br><span class="line">        activity?.let &#123; fViewModel = ViewModelProvider(it)[MainViewModel::class.java] &#125;</span><br><span class="line">        // 如果如果传入的ViewModelStoreOwner是Fragment则表示用Fragment中的ViewModel，数据就和Activity中无关了，</span><br><span class="line">        fViewModel = ViewModelProvider(this)[MainFragmentViewModel::class.java]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这里使用的ViewModel是Activity中的，所以就实现了Activity与Fragment的数据共享</span><br><span class="line">     * 同样的，如果要实现Fragment和子Fragment之间的数据共享，只需要在子Fragment中使用父Fragment作为ViewModelStoreOwner</span><br><span class="line">     * 代码：</span><br><span class="line">     * parentFragment?.let &#123; fViewModel = ViewModelProvider(it).get(MainViewModel::class.java) &#125;</span><br><span class="line">     * */</span><br><span class="line">    override fun onCreateView(</span><br><span class="line">        inflater: LayoutInflater,</span><br><span class="line">        container: ViewGroup?,</span><br><span class="line">        savedInstanceState: Bundle?</span><br><span class="line">    ): View? &#123;</span><br><span class="line">        val view = inflater.inflate(R.layout.fragment_main, container, false)</span><br><span class="line">        txtSeekValue = view.findViewById(R.id.txt_seek_value)</span><br><span class="line">        txtSeekValue?.text = &quot;$&#123;(fViewModel as MainViewModel).seekValue&#125;&quot;</span><br><span class="line">        seekBar = view.findViewById(R.id.seek)</span><br><span class="line">        seekBar?.progress = (fViewModel as MainViewModel).seekValue</span><br><span class="line">        seekBar?.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener &#123;</span><br><span class="line">            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) &#123;</span><br><span class="line">                if (fromUser) &#123;</span><br><span class="line">                    (fViewModel as MainViewModel).seekValue = progress</span><br><span class="line">                    txtSeekValue?.text = &quot;$&#123;(fViewModel as MainViewModel).seekValue&#125;&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onStartTrackingTouch(seekBar: SeekBar?) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onStopTrackingTouch(seekBar: SeekBar?) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        return view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ViewModel实现原理"><a href="#ViewModel实现原理" class="headerlink" title="ViewModel实现原理"></a>ViewModel实现原理</h2><p>用几个问题来切入源码阅读</p>
<ol>
<li>ViewModel是怎么创建的</li>
<li>ViewModel为什么能实现Activity重建时保留数据</li>
<li>ViewModel进行数据共享是怎么实现的</li>
</ol>
<h3 id="ViewModel是怎么创建的"><a href="#ViewModel是怎么创建的" class="headerlink" title="ViewModel是怎么创建的"></a>ViewModel是怎么创建的</h3><p>首先看ViewModel的创建过程，我们通常使用这种方式来获取一个ViewModel：<code>ViewModelProvider(this).get(MainViewModel::class.java)</code>，意思是从一个ViewModel提供者中get一个你想要的ViewModel类型的实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public open class ViewModelProvider // 这是ViewModelProvider的类定义</span><br><span class="line"></span><br><span class="line">// 这是ViewModelProvider的构造方法，此时第二个参数传入的是defaultFactory(owner)，从下面方法可以看出来其实真正的factory是一个SavedStateViewModelFactory</span><br><span class="line">public constructor(</span><br><span class="line">    owner: ViewModelStoreOwner</span><br><span class="line">) : this(owner.viewModelStore, defaultFactory(owner), defaultCreationExtras(owner))</span><br><span class="line"></span><br><span class="line">// 调用上一个构造方法只是准备了一些参数然后调用此构造，可见此时ViewModelProvider中有一个关键变量：store、factory、defaultCreationExtras</span><br><span class="line">constructor(</span><br><span class="line">    private val store: ViewModelStore,</span><br><span class="line">    private val factory: Factory,</span><br><span class="line">    private val defaultCreationExtras: CreationExtras = CreationExtras.Empty,</span><br><span class="line">) &#123;</span><br><span class="line">    ...</span><br><span class="line">    public open class AndroidViewModelFactory</span><br><span class="line">    private constructor(</span><br><span class="line">        private val application: Application?,</span><br><span class="line">        @Suppress(&quot;UNUSED_PARAMETER&quot;) unused: Int,</span><br><span class="line">    ) : NewInstanceFactory() &#123;</span><br><span class="line"></span><br><span class="line">        public constructor() : this(null, 0)</span><br><span class="line"></span><br><span class="line">        public constructor(application: Application) : this(application, 0)</span><br><span class="line"></span><br><span class="line">        override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T &#123;</span><br><span class="line">            return if (application != null) &#123;</span><br><span class="line">                create(modelClass, application)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                val application = extras[APPLICATION_KEY]</span><br><span class="line">                if (application != null) &#123;</span><br><span class="line">                    create(modelClass, application)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (AndroidViewModel::class.java.isAssignableFrom(modelClass)) &#123;</span><br><span class="line">                        throw IllegalArgumentException(</span><br><span class="line">                            &quot;CreationExtras must have an application by `APPLICATION_KEY`&quot;</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                    super.create(modelClass)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">            return if (application == null) &#123;</span><br><span class="line">                throw UnsupportedOperationException(</span><br><span class="line">                    &quot;AndroidViewModelFactory constructed &quot; +</span><br><span class="line">                        &quot;with empty constructor works only with &quot; +</span><br><span class="line">                        &quot;create(modelClass: Class&lt;T&gt;, extras: CreationExtras).&quot;</span><br><span class="line">                )</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                create(modelClass, application)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Suppress(&quot;DocumentExceptions&quot;)</span><br><span class="line">        private fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, app: Application): T &#123;</span><br><span class="line">            return if (AndroidViewModel::class.java.isAssignableFrom(modelClass)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    modelClass.getConstructor(Application::class.java).newInstance(app)</span><br><span class="line">                &#125; catch (e: NoSuchMethodException) &#123;</span><br><span class="line">                    throw RuntimeException(&quot;Cannot create an instance of $modelClass&quot;, e)</span><br><span class="line">                &#125; catch (e: IllegalAccessException) &#123;</span><br><span class="line">                    throw RuntimeException(&quot;Cannot create an instance of $modelClass&quot;, e)</span><br><span class="line">                &#125; catch (e: InstantiationException) &#123;</span><br><span class="line">                    throw RuntimeException(&quot;Cannot create an instance of $modelClass&quot;, e)</span><br><span class="line">                &#125; catch (e: InvocationTargetException) &#123;</span><br><span class="line">                    throw RuntimeException(&quot;Cannot create an instance of $modelClass&quot;, e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else super.create(modelClass)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public companion object &#123;</span><br><span class="line">            internal fun defaultFactory(owner: ViewModelStoreOwner): Factory =</span><br><span class="line">                if (owner is HasDefaultViewModelProviderFactory)</span><br><span class="line">                    owner.defaultViewModelProviderFactory else instance</span><br><span class="line"></span><br><span class="line">            internal const val DEFAULT_KEY = &quot;androidx.lifecycle.ViewModelProvider.DefaultKey&quot;</span><br><span class="line"></span><br><span class="line">            private var sInstance: AndroidViewModelFactory? = null</span><br><span class="line">            </span><br><span class="line">            @JvmStatic</span><br><span class="line">            public fun getInstance(application: Application): AndroidViewModelFactory &#123;</span><br><span class="line">                if (sInstance == null) &#123;</span><br><span class="line">                    sInstance = AndroidViewModelFactory(application)</span><br><span class="line">                &#125;</span><br><span class="line">                return sInstance!!</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            private object ApplicationKeyImpl : Key&lt;Application&gt;</span><br><span class="line"></span><br><span class="line">            @JvmField</span><br><span class="line">            val APPLICATION_KEY: Key&lt;Application&gt; = ApplicationKeyImpl</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先对上面ViewModelProvider的构建做一个简单解释：</p>
<ul>
<li>在构造ViewModelProvider时需要传入一个ViewModelStoreOwner，这是一个ViewModel容器的拥有者，后面再说。</li>
<li>紧接着传入了一个<code>ViewModelProvider.Factory</code>，这是一个ViewModel的构造工厂类，此时用的是默认工厂，而针对Activity和Fragment而言这个默认工厂的真正类型是<code>SavedStateViewModelFactory</code>，这个可以通过传入的ViewModelStoreOwner中找到答案，比如传入的是Activity的话，ComponentActivity实现了<code>ViewModelStoreOwner</code>和<code>HasDefaultViewModelProviderFactory</code>两个接口，所以通过查看ComponentActivity的<code>getDefaultViewModelProviderFactory()</code>方法可知defaultFactory其实是SavedStateViewModelFactory类型</li>
<li>最后一个参数是CreationExtras类型，和ViewModelProvider.Factory同理它也是在ComponentActivity中创建，我也没详细看这到底干嘛用的，跳过也没关系</li>
</ul>
<p><strong>什么是ViewModelStoreOwner？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这是一个ViewModel容器的持有者</span><br><span class="line">public interface ViewModelStoreOwner &#123;</span><br><span class="line">    @NonNull</span><br><span class="line">    ViewModelStore getViewModelStore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以实现这个接口的类必然需要实现getViewModelStore()方法并返回一个ViewModelStore，<strong>而ViewModelStore又是什么？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ViewModelStore &#123;</span><br><span class="line"></span><br><span class="line">    private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    final void put(String key, ViewModel viewModel) &#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class="line">        if (oldViewModel != null) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ViewModel get(String key) &#123;</span><br><span class="line">        return mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; keys() &#123;</span><br><span class="line">        return new HashSet&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void clear() &#123;</span><br><span class="line">        for (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是一个ViewModel容器，其内部的数据结构是个Map用于根据key值存放ViewModel并提供了几个方法用于map的管理。例如当调用<code>clear()</code>时就会清空该容器并执行容器中每个ViewModel的clear()方法，插一句：<code>ViewModel.clear()</code>用于释放自身数据，它会回调一个<code>onCleared()</code>方法用于告知开发者数据清理完成。</p>
<p>分析到这里我们已经有了一个ViewModel的提供者ViewModelProvider，我们需要ViewModel的时候就可以找它。那我们现在去找它，<code>ViewModelProvider(this).get(MainViewModel::class.java)</code>这个get方法被重写了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public open operator fun &lt;T : ViewModel&gt; get(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">    val canonicalName = modelClass.canonicalName</span><br><span class="line">        ?: throw IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;)</span><br><span class="line">    return get(&quot;$DEFAULT_KEY:$canonicalName&quot;, modelClass)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@MainThread</span><br><span class="line">public open operator fun &lt;T : ViewModel&gt; get(key: String, modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">    // 先尝试从ViewModelStore中获取需要的ViewModel实例</span><br><span class="line">    val viewModel = store[key]</span><br><span class="line">    if (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        (factory as? OnRequeryFactory)?.onRequery(viewModel)</span><br><span class="line">        // 如果实例存在直接返回，如果不存在走下面逻辑通过Factory去创建</span><br><span class="line">        return viewModel as T</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        @Suppress(&quot;ControlFlowWithEmptyBody&quot;)</span><br><span class="line">        if (viewModel != null) &#123;</span><br><span class="line">            // TODO: log a warning.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val extras = MutableCreationExtras(defaultCreationExtras)</span><br><span class="line">    extras[VIEW_MODEL_KEY] = key</span><br><span class="line">    // ViewModel是第一次创建的话则通过ViewModelProvider.Factory去创建一个新的ViewModel并返回，返回之前也会把它加入ViewModelStore中进行缓存，下一次如果再需要获取同类型的ViewModel时就无需再创建并且数据也能得以保留</span><br><span class="line">    return try &#123;</span><br><span class="line">        factory.create(modelClass, extras)</span><br><span class="line">    &#125; catch (e: AbstractMethodError) &#123;</span><br><span class="line">        factory.create(modelClass)</span><br><span class="line">    &#125;.also &#123; store.put(key, it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分的主要意思是当开发者需要某种类型的ViewModel时，ViewModelProvider会先去ViewModelStore这个容器中获取，如果获取不到就通过<code>ViewModelProvider.Factory.craete()</code>去创建一个ViewModel实例然后将其缓存到ViewModelStore中，此处我们解析到的ViewModelProvider.Factory是SavedStateViewModelFactory类型。而create()方法内部是通过反射生成了所需的ViewModel实例，不详细进入了。</p>
<h3 id="ViewModel为什么能实现Activity重建时保留数据"><a href="#ViewModel为什么能实现Activity重建时保留数据" class="headerlink" title="ViewModel为什么能实现Activity重建时保留数据"></a>ViewModel为什么能实现Activity重建时保留数据</h3><p>先用一张图说明一下ViewModel的生命周期</p>
<img src="/2022/09/06/Jetpack-ViewModel/ViewModel%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" class="" title="ViewModel生命周期">

<p>看下ComponentActivity：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ComponentActivity extends androidx.core.app.ComponentActivity implements</span><br><span class="line">        ContextAware,</span><br><span class="line">        LifecycleOwner,</span><br><span class="line">        ViewModelStoreOwner,</span><br><span class="line">        HasDefaultViewModelProviderFactory,</span><br><span class="line">        SavedStateRegistryOwner,</span><br><span class="line">        OnBackPressedDispatcherOwner,</span><br><span class="line">        ActivityResultRegistryOwner,</span><br><span class="line">        ActivityResultCaller,</span><br><span class="line">        OnConfigurationChangedProvider,</span><br><span class="line">        OnTrimMemoryProvider,</span><br><span class="line">        OnNewIntentProvider,</span><br><span class="line">        OnMultiWindowModeChangedProvider,</span><br><span class="line">        OnPictureInPictureModeChangedProvider,</span><br><span class="line">        MenuHost &#123;</span><br><span class="line">    </span><br><span class="line">    public ComponentActivity() &#123;</span><br><span class="line">        ...</span><br><span class="line">        getLifecycle().addObserver(new LifecycleEventObserver() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onStateChanged(@NonNull LifecycleOwner source,</span><br><span class="line">                    @NonNull Lifecycle.Event event) &#123;</span><br><span class="line">                // 当Activity走到onDestroy时会走到这个回调中</span><br><span class="line">                if (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                    // Clear out the available context</span><br><span class="line">                    mContextAwareHelper.clearAvailableContext();</span><br><span class="line">                    // And clear the ViewModelStore</span><br><span class="line">                    // 在执行Activity的销毁过程中判断是因为配置改变导致的重建还是因为Activity被关闭导致的销毁，如果是配置改变导致的重建则不会清空ViewModel数据</span><br><span class="line">                    if (!isChangingConfigurations()) &#123;</span><br><span class="line">                        getViewModelStore().clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Activity因为某些原因比如在设置页面做了某些改动或者切换横竖屏等导致Activity需要销毁重建时，isChangingConfigurations()会返回true，因此<code>().clear();</code>就不会执行，数据就能得以保留。</p>
<p><strong>那Fragment中的ViewModel是在什么时候释放的呢？</strong><br>因为代码牵扯太多就不贴了，特地画了个流程图。流程图分为init、get、destroy三个过程：</p>
<img src="/2022/09/06/Jetpack-ViewModel/Fragment%E4%B8%AD%E4%BD%BF%E7%94%A8ViewModel%E5%8E%9F%E7%90%86.jpg" class="" title="Fragment中使用ViewModel原理">

<p>结论就是当Fragment执行销毁过程时执行到<code>Fragment.performDestroyView()</code>代码中处理了ViewModel的数据清理逻辑，最终具体清理的代码是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final class FragmentManagerViewModel extends ViewModel &#123;</span><br><span class="line">    ...</span><br><span class="line">    void clearNonConfigState(@NonNull Fragment f) &#123;</span><br><span class="line">        if (FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(TAG, &quot;Clearing non-config state for &quot; + f);</span><br><span class="line">        &#125;</span><br><span class="line">        // Clear and remove the Fragment&#x27;s child non config state</span><br><span class="line">        FragmentManagerViewModel childNonConfig = mChildNonConfigs.get(f.mWho);</span><br><span class="line">        if (childNonConfig != null) &#123;</span><br><span class="line">            childNonConfig.onCleared();</span><br><span class="line">            mChildNonConfigs.remove(f.mWho);</span><br><span class="line">        &#125;</span><br><span class="line">        // Clear and remove the Fragment&#x27;s ViewModelStore</span><br><span class="line">        ViewModelStore viewModelStore = mViewModelStores.get(f.mWho);</span><br><span class="line">        if (viewModelStore != null) &#123;</span><br><span class="line">            viewModelStore.clear();</span><br><span class="line">            mViewModelStores.remove(f.mWho);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>所以在Fragment中使用ViewModel时需要注意，ViewModel在onDestroyView这个生命周期节点中已经执行了clear()相应的就会回调onCleared()，所以尽量不要在后续的onDestroy和onDetach中使用ViewModel中的数据避免出现意想不到的问题，并且尽量在onCleared()中去做一些数据释放的工作</strong></p>
<h3 id="ViewModel进行数据共享是怎么实现的"><a href="#ViewModel进行数据共享是怎么实现的" class="headerlink" title="ViewModel进行数据共享是怎么实现的"></a>ViewModel进行数据共享是怎么实现的</h3><p>如果理解了上面的原理那这个问题就很好回答，以Activity共享数据给Fragment为例，其实进行数据共享的本质就是在Activity和Fragment中使用同一个ViewModel以此达到共享的效果。而我们知道每个ViewModel都会被添加到一个ViewModelStore(也就是容器)中，每个ViewModelStore又从属于一个ViewModelStoreOwner，这是背景。</p>
<img src="/2022/09/06/Jetpack-ViewModel/ViewModel%E5%AD%98%E5%82%A8%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" class="" title="ViewModel存储关系图">
<p>我们在获取ViewModel都会使用这样的代码，这样对于ViewModel的创建、缓存、生命周期绑定都由系统替我们完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val viewModel = ViewModelProvider(this).get(MainViewModel::class.java)</span><br></pre></td></tr></table></figure>
<p>不建议自己这样去创建<code>val viewModel = ViewModel()</code>，这样创建出来的ViewModel不具备数据保留、生命周期绑定等特性，也不建议自行获取ViewModelStore等方式来使用ViewModel，因为ViewModelStore的方法除了clear其他都是默认修饰符，除非反射否则你不能操作ViewModelStore，而且也一样得自己去绑定生命周期等操作。</p>
<p>那Fragment想要获取Activity共享的数据只需要给ViewModelProvider构造传入Activity作为ViewModelStoreOwner即可，这样Fragment得到的ViewModel是从Activity的ViewModelStore这个容器中取的ViewModel，就能达到Activity和Fragment使用的是同一份数据的效果，父Fragment和子Fragment之间共享数据也同理。</p>
<p><strong>还有一点值得注意的是，Activity的销毁和Fragment的替换都会导致当前Fragment的ViewModel执行clear()。（例如Activity A中有FragmentA，Activity销毁和Activity执行replace FragmentB都会导致FragmentA中的ViewModel执行clear() ）</strong></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>android热修复小记</title>
    <url>/2022/04/13/android%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="认识热修复"><a href="#认识热修复" class="headerlink" title="认识热修复"></a>认识热修复</h2><p>由于Android应用程序需要手动安装apk包的特性，如果应用发布上线之后发现有bug只能再下载新包来修复。这样一来影响用户体验，二来是否下载新包的主动权在用户，所以开发者对bug无法把控。</p>
<h2 id="主流热修复方案"><a href="#主流热修复方案" class="headerlink" title="主流热修复方案"></a>主流热修复方案</h2><ol>
<li>腾讯Tinker</li>
<li>腾讯QZone</li>
<li>阿里sophix</li>
<li>美团Robust</li>
</ol>
<span id="more"></span>


<p>做一些简单对比</p>
<table>
<thead>
<tr>
<th>方案对比</th>
<th>Tinker</th>
<th>QZone</th>
<th>Sophix</th>
<th>Robust</th>
</tr>
</thead>
<tbody><tr>
<td>即时生效</td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>类替换(dex插队)</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>So修复</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>资源修复</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>版本支持</td>
<td>all</td>
<td>all</td>
<td>all</td>
<td>all</td>
</tr>
<tr>
<td>是否开源</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>收费情况</td>
<td>基础免费</td>
<td>免费</td>
<td>到达阈值收费</td>
<td>免费</td>
</tr>
</tbody></table>
<h3 id="Tinker"><a href="#Tinker" class="headerlink" title="Tinker"></a>Tinker</h3><p>腾讯自研的需要<strong>重启生效</strong>的java层实现的热修复方案</p>
<p>类修复是通过将原有的dex文件和修复之后的patch.dex文件进行dexdiff算法生成一个差分包下发给端，端收到差分包之后通过DexPatch算法再将差分包与端上的bug dex进行合并形成新的dex并替换掉dexElements数组来实现的。</p>
<p>资源修复过程构造一个新的AssetManager，并通过反射调用addAssetPath，把这个完 整的新资源包加入到AssetManager中。这样就得到了一个含有所有新资源的AssetManager。然后找到所有之前引用到原有AssetManager的地方通过反射将它们替换为这个新的AssetManager。</p>
<p>so的修复过程最简单，目前支持2种方式：</p>
<blockquote>
<ol>
<li>Hack方式：通过反射将补丁so插入到类加载器(这里我们拿到的就是BaseDexClassLoader)的DexPathList.nativeLibraryPathElements的数组最前面,这样做的好处是开发者只需像往常一样使用System.loadLibrary()来加载so，对开发者完全透明。缺点是是线上需要考虑系统版本兼容，毕竟用到了反射。</li>
<li>System.load()方式：可以加载任意路径下的so，好处是没有用到反射所以没有系统版本兼容问题，但是开发者使用时候加载so库的时候就需要调用System.load()方式而不是System.loadLibrary()。</li>
</ol>
</blockquote>
<blockquote>
<p>关于so的加载load逻辑可以参考文章：<a href="http://lianwenhong.top/2022/04/13/Android%E4%B8%A4%E7%A7%8Dso%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8F%8Aso%E7%83%AD%E4%BF%AE%E5%A4%8D/#more">http://lianwenhong.top/2022/04/13/Android两种so加载方式实现及so热修复/#more</a></p>
</blockquote>
<p>CustomTinker代码仓库：<a href="https://github.com/lianwenhong/CustomTinker.git">https://github.com/lianwenhong/CustomTinker.git</a><br>本工程模拟了dexElements插队实现类修复、AssetManager替换实现资源修复、未模拟so库修复，并且未做差分包，补丁校验等逻辑。仅用于学习。</p>
<h3 id="QZone"><a href="#QZone" class="headerlink" title="QZone"></a>QZone</h3><p>Multidex方案是基于ClassLoader的<strong>纯java实现</strong>的<strong>重启生效</strong>的热修复方案。</p>
<p>其实现原理与Tinker基本相同，不同点在于Tinker的补丁包是差分包而Multidex是全量包。并且它不支持so库修复。</p>
<h3 id="Robust"><a href="#Robust" class="headerlink" title="Robust"></a>Robust</h3><p>Robust是<strong>即时生效</strong>的<strong>Java层实现</strong>的热修复实现方案.</p>
<p>其参考了google的InstantRun方案。<a href="https://www.jb51.net/article/216170.htm#_label0">https://www.jb51.net/article/216170.htm#_label0</a></p>
<p>其主要设计思想就是字节码动态插桩(javassist)，在编译打包时都会通过javassist在程序每个方法里都插入这样一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (changeQuickRedirect != null) &#123;</span><br><span class="line">    //</span><br><span class="line">    return 修复的实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javassist原理：在class转dex的过程中会调用Transform，在该时机修改class对象，完成代码的注入。</p>
<p>当changeQuickRedirect不为空的时候，该方法就会命中<code>if(changeQuickRedirect != null)</code>，从而执行修复的实现代码。当为空的时候，则正常执行原逻辑。</p>
<p>在发生bug之后修复完bug方法时需要在方法上打上@Modify注解，这样在补丁包生成的时候该方法会被加入补丁描述类中。</p>
<p>为什么Robust能即时生效？</p>
<p>在补丁下载完成之后使用DexClassLoader将其加载进内存，然后反射将bug类对应的changeQuickRedirect复制为补丁对象。这样当程序执行到bug方法的时候就会命中changeQuickRedirect!&#x3D;null然后去走补丁中的修复之后的方法。定位bug类和bug方法就是通过之前打注解时自动将其加入补丁描述类中来实现的。</p>
<p>当前Robust支持的动态插桩技术有AspectJ、javassist两种。</p>
<p>javassist demo：<a href="https://github.com/lianwenhong/JavassistDemo.git">https://github.com/lianwenhong/JavassistDemo.git</a></p>
<p>AspectJ demo：<a href="https://github.com/lianwenhong/AspectJDemo.git">https://github.com/lianwenhong/AspectJDemo.git</a></p>
<h3 id="sophix"><a href="#sophix" class="headerlink" title="sophix"></a>sophix</h3><p>在native动态替换java层的方法，通过native层hook java层的代码。</p>
<p>没研究所以不做深入探究</p>
<p>思考：</p>
<p>四大组件的热修复？</p>
<p>资源热修复时会不会有冲突？（系统资源package id 0x01，应用资源package id 0x7f）</p>
<p>参考文章：<a href="https://www.jb51.net/article/216170.htm#_label0">https://www.jb51.net/article/216170.htm#_label0</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>binder（一）Linux必备知识篇</title>
    <url>/2022/04/18/binder%EF%BC%88%E4%B8%80%EF%BC%89Linux%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%AF%87/</url>
    <content><![CDATA[<p>对linux操作系统中某些概念做简单预习，旨在为后续Android学习提供前提铺垫。例如学习binder、锁机制等等。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>Linux操作系统将运行中的程序成为进程。而Linux内核控制这Linux操作系统如何管理运行在系统上的所有进程。</p>
<p><strong>内核创建了第一个进程（init进程）来启动系统上所有其他进程。</strong> 当内核启动时，他会将init进程加载到虚拟内存中。内核在启动任何进程时都会在虚拟内存中为该进程分配一块专有区域用于存储该进程用到的数据和代码。</p>
<h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><ul>
<li>Linux中为每一个进程分配内存时都将内存划分为2部分：<strong>用户空间</strong>和<strong>内核空间</strong>。</li>
<li>Linux中一个进程在运行时<strong>cpu的运行状态是用特权等级来区分</strong>，以arm64为例分为4个等级，从低到高分别是EL0～EL3。我们常接触的等级是EL0和EL1，<strong>EL0为用户态，EL1为内核态。当cpu处于用户态时不能访问内核空间的数据（除非通过系统调用将当前cpu状态转入内核态），但是反之如果cpu处于内核态时可以访问用户空间也可以访问内核空间。</strong></li>
<li>Linux中每个进程之间是<strong>相互隔离</strong>的，进程之间不能直接进行通信，这样保证了进程的安全性。</li>
<li>2个用户进程想要相互通信必须借助内核空间来完成，大概原理就是在内核空间中开辟出一块内存缓存区域，各个进程通过操作这块区域达到通信的目的。这就涉及到了用户进程想要访问内核空间的情况，此时只能通过<strong>系统调用（例如copy_from_user就是一个系统调用）</strong> 使cpu从用户态转入内核态，这样该进程就能访问内核空间的数据了，其他进程也通过这种方式来访问该内存缓存就能达到通信的目的。<strong>这也是用户进程访问内核空间的唯一方式。</strong> 这种机制保证了系统内核的安全和稳定，确保用户进程不能随随便便地操作内核空间给内核空间造成未知安全隐患。</li>
</ul>
<h3 id="如何做到进程隔离？如何在各个进程共享内核空间？"><a href="#如何做到进程隔离？如何在各个进程共享内核空间？" class="headerlink" title="如何做到进程隔离？如何在各个进程共享内核空间？"></a>如何做到进程隔离？如何在各个进程共享内核空间？</h3><img src="/2022/04/18/binder%EF%BC%88%E4%B8%80%EF%BC%89Linux%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%AF%87/Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84.jpeg" class="" title="Linux内存映射">

<ul>
<li>要将虚拟地址映射到物理内存上需要用到密码本来翻译虚拟地址</li>
<li>每个进程中有2个密码本，一个是用户空间密码本（task_struct）中，一个是内核空间密码本（swapper_pg_dir），用户空间密码本为进程私有，每个进程都不一样，内核空间密码本为各个进程公用的</li>
<li>当访问用户空间时使用task_struct这个密码本，由于每个进程都不一样，所以最终映射到的物理内存地址就是不一样的，别的进程永远都不可能映射到本进程的相对应的用户空间物理内存。</li>
<li>当访问内核空间时使用swapper_pg_dir这个密码本，因为所有进程都是公用的一个密码本所以最终映射的物理内存是一样的。</li>
</ul>
<p>图中是简化过方便理解的映射，真实情况中物理内存地址极可能是离散的而不是这样连续的内存片段。</p>
<h3 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h3><blockquote>
<p>在Linux中，一切皆对象。也就是说皆可以通过一套统一的接口来控制。</p>
</blockquote>
<p>Linux系统将硬件设备当成特殊的文件，称之为<strong>设备文件</strong>。例如键盘、鼠标、硬盘等等在Linux中都当成文件来处理，Linux提供了一套统一的操作接口来让开发者操作它们。<br>设备文件分为3类：</p>
<ul>
<li><strong>字符设备</strong>：如键盘。提供连续数据流（字节或字符），应用可顺序读取，但<strong>不支持随机存取</strong>。</li>
<li><strong>块设备</strong>：如硬盘等存储设备。应用<strong>可随机存取</strong>设备上的任意位置的数据。</li>
<li><strong>网络设备</strong> ：指采用数据包发送和接受数据的设备，包括各种网卡和一个特殊的回环设备。这种回环设备允许Linux使用常见的网络编程协议同自身通信。</li>
</ul>
<h3 id="设备节点："><a href="#设备节点：" class="headerlink" title="设备节点："></a>设备节点：</h3><p>Linux系统会将所有的设备文件（网络设备除外）在&#x2F;dev目录下生成对应的<strong>设备节点</strong>，生成的<strong>设备节点可以理解为设备文件的操作入口，我们可以Linux提供的统一操作接口（如open()、read()、write()、close()…）来操作这些设备节点来达到对设备的操作。</strong> 这样大大的降低了应用程序操作设备的复杂度。</p>
<p>网络设备之所以不和其他设备一样是因为网络设备的工作是采用报文传输，无法做到和其他设备统一接口，所以并未在&#x2F;dev下生成设备节点。</p>
<h3 id="虚拟设备"><a href="#虚拟设备" class="headerlink" title="虚拟设备"></a>虚拟设备</h3><p>虚拟设备是Linux动态虚拟出来的一种设备，Linux会为其分配内存，但其并不存在真实的物理设备。为了进行某些功能的现实化，让操作更加具象化。这就使得用户能像操作一个真实设备一样去做想要的操作。举个例子就像app中的小键盘它不是一个真实的物理键盘，但是你能像操作一个真实物理键盘一样打字。</p>
<p><strong>Android中的binder就是一个虚拟设备，它的设备节点是&#x2F;dev&#x2F;binder</strong></p>
<h3 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h3><p>每个设备节点都包含了2个设备号：</p>
<ul>
<li>主设备号：表示<strong>设备类型</strong>，也表示与其关联的设备驱动程序，相同设备号所关联的设备驱动是同一个</li>
<li>次设备号：表示某种设备类型下的特定设备，例如有多个usb，可以通过次设备号查找usb0，usb1</li>
</ul>
<p>可以通俗理解为：主设备号是你家单元号，次设备号是你家门牌号</p>
<h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3><p><strong>设备驱动程序是一种可以使系统和设备进行交互的特殊程序</strong>，相当于硬件的接口，系统只有通过驱动程序中的接口才能控制设备的工作。加入某设备的驱动程序未能正确工作则系统也无法正确操作设备。因此，驱动程序是设备和系统之间的桥梁。</p>
<h3 id="设备驱动的工作原理"><a href="#设备驱动的工作原理" class="headerlink" title="设备驱动的工作原理"></a>设备驱动的工作原理</h3><p>Linux中访问&#x2F;dev目录下的设备节点时，Linux内核会把这些对设备节点的操作通过主设备号找到对应的驱动程序，然后将操作映射到驱动程序中的对应代码上，然后驱动程序可根据次设备号执行对指定设备的操作。<br>Linux内核有两种方法来将某个设备驱动插入内核：</p>
<ol>
<li>将驱动程序代码之间编译进内核<br>早前这是驱动程序进入内核的唯一方式，这种方式会导致内核代码要重新编译。每次添加一个新设备都得重新编译一次内核代码，随着设备不断增加这种方式就变得很低效，所以产生了第二种方式</li>
<li>将驱动程序编译为驱动模块再动态插入内核<br>因为第1种方式的低效，开发者提出了<strong>驱动模块</strong>的概念。通过将驱动程序编译成驱动模块，然后在使用的时候将驱动模块动态插入到运行中的系统内核中而无需重新编译内核，当不再使用时也可以将驱动模块从运行中的系统内核中移除。这样的好处一个是简化和扩展了硬件设备在Linux上的使用，另一个是使内核不再臃肿。</li>
</ol>
<img src="/2022/04/18/binder%EF%BC%88%E4%B8%80%EF%BC%89Linux%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%AF%87/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.jpg" class="" title="Linux设备驱动加载流程">

<p><strong>Android中的binder驱动就是以这种方式插入系统内核的。</strong></p>
<p>所以在Android中打开&#x2F;dev&#x2F;binder设备节点时，会执行binder驱动中的相关逻辑。后续的操作都会映射到binder驱动中。</p>
<p>参考文献：<br><a href="https://baijiahao.baidu.com/s?id=1726920239983776761&wfr=spider&for=pc">初识Linux命令行与shell</a><br><a href="https://blog.csdn.net/qianghaohao/article/details/79058121?utm_term=linux%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-1-79058121&spm=3001.4430">Linux设备驱动程序和设备文件</a><br><a href="https://blog.csdn.net/qq_38880380/article/details/79227760">Linux下编写和加载 .ko 文件（驱动模块文件）</a><br><a href="https://zhuanlan.zhihu.com/p/484393580">linux内存管理（一）- 虚拟地址和物理地址</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>binder</tag>
      </tags>
  </entry>
  <entry>
    <title>binder（二）MMU内存管理单元浅析</title>
    <url>/2022/06/28/binder%EF%BC%88%E4%BA%8C%EF%BC%89MMU%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h2><p>在现代的操作系统中，当你对内存地址进行操作时其实操作的并不是物理内存地址，而是系统虚拟出来的一个虚拟内存地址。</p>
<img src="/2022/06/28/binder%EF%BC%88%E4%BA%8C%EF%BC%89MMU%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83%E6%B5%85%E6%9E%90/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80.jpeg" class="" title="虚拟地址与物理地址">

<p>通过简单的图例说明虚拟内存的概念。</p>
<p>操作系统的物理内存是固定的，我们这里指的是RAM。当操作系统运行多个进程时，每个进程如果直接访问物理内存，那是不是就会出现你进程P1访问地址A时如果进程P2也访问该地址，那就会造成进程之间的冲突。所以当代操作系统引入了虚拟内存的概念。</p>
<p>在创建P1和P2进程时，操作系统会分别告诉它们我整个内存都是你的，可是事实上操作系统给它们画了大饼，其实它们得到的是内存地址是虚拟出来的。当P1访问其内部的A地址时，P1.A指向物理地址A中，当P2访问其内部的A地址时它以为它访问的是物理地址A，但其实操作系统通过MMU将它指向了物理地址B。甚至当P1和P2各自访问其内部地址B时，其实它们公用了物理地址C。操作系统这种欺骗的手段就是<strong>虚拟内存</strong>。这些虚拟地址到物理地址之间的地址映射是MMU来完成的，对于P1和P2都只需知道它们占据了整块内存而无需关系它们的每一个地址都映射到物理内存的哪一个地址上。</p>
<p><strong>所以虚拟内存的好处就是：解决各个进程之间的地址访问冲突问题，所有的地址映射都由MMU来处理，发没发生冲突、如何解决冲突等问题也由MMU来处理，各个进程都无需关心。</strong></p>
<p>使用虚拟内存能更方便地实现内存和数据的共享。例如在进程加载系统库时总是先分配一块内存，将磁盘中的库文件加载到这个内存中。在直接使用物理内存时由于物理内存地址唯一，所以即使系统发现同一个库在系统中加载了多次也无能为力，因为每个进程指定的加载内存不一样。使用了虚拟内存之后这个问题就迎刃而解，系统只需将进程的虚拟内存地址指向库文件所在的物理内存地址即可，就如上图中的P1.B和P2.B同时指向了物理地址C。</p>
<h2 id="什么是MMU"><a href="#什么是MMU" class="headerlink" title="什么是MMU"></a>什么是MMU</h2><p><strong>我们知道通过虚拟内存机制，每个进程都以为自己占用了全部内存，进程访问内存时，操作系统都会把进程提供的虚拟内存地址转换为物理地址，再去对应的物理地址上获取数据。CPU 中有一种硬件，内存管理单元 MMU（Memory Management Unit）专门用来将虚拟内存地址翻译为物理内存地址。CPU 还为页表寻址设置了缓存策略，由于程序的局部性，其缓存命中率能达到 98%。</strong></p>
<p>操作系统都是以字节Byte为单位，MMU是使用一张映射表来存储虚拟地址与物理地址之间的映射关系，那每存储一个条目都需要至少8个字节(32位虚拟地址–&gt;32位物理地址)，在32位且只有4G运存的设备上就至少需要32G的空间来存储这张对照表，显然这是不现实的，所以操作系统引入了页的概念。</p>
<p>MMU将虚拟内存划分成以<strong>页</strong> 为单位，相应的物理内存空间也会以<strong>页框</strong> 为单位进行划分。页和页框的大小必须相同。系统启动时会将物理内存以4K为单位划分成许多页框，在分配虚拟内存时也是以4K为单位划分成许多页，这样映射表中的每一个条目都只需存储页索引和其地址针对页索引的偏移量即可，还是在32位且4G运存的设备上只需要8M的空间来存储映射表，大大减少了内存占用。</p>
<h4 id="SWAP"><a href="#SWAP" class="headerlink" title="SWAP"></a>SWAP</h4><p>系统为进程分配内存空间并不是一下子就将进程的所有空间分配给它，而是以页为单位进行动态分配（懒分配），用到的时候才会进行真正的内存分配。当进程访问某个页中的虚拟地址时，MMU去映射对应的物理地址发现当前并未给该页分配物理内存空间，那么系统会执行一个缺页中断然后去分配物理内存空间，分配完成之后再将虚拟内存空间指向该物理内存空间。</p>
<p><strong>问题：假设你有一个4(RAM)+128(ROM)的手机，那么王者荣耀一个应用就1个多G，那么是不是运行4个这样大的游戏直接就把手机撑爆了？</strong><br>因为虚拟内存要通过缺页中断为进程的虚拟内存空间分配真正的物理内存空间，但是现实中物理内存空间一定是有限的，例如你的设备总共只有4G的运存，此时4G内存被占满了怎么办，Linux提出了SWAP概念，其原理是在分配物理内存空间出现可用内存不足的时候，将暂时不用的内存数据先转移到磁盘中去（前提是你的磁盘足够放，例如这里你的磁盘有128G肯定够）让当前需要分配空间的进程先使用，等到被存储到磁盘中的数据再次要被使用时再通过将其他数据转移到磁盘来腾出空间将这些数据再移回内存中。通过这种“交换”技术，使系统可以运行更多的进程使用更多的内存。这就是为什么在虚拟内存解释的时候说系统会欺骗每个进程说它们占有了所有的内存，因为如果必要的时候理论上是可以通过将其他当前不使用的空间数据迁移到磁盘来腾出空间给紧急进程使用的。<br>当然上述过程使用了一些缓存技术来达到让寻址更加快速的目的。</p>
<h2 id="MMU的工作过程"><a href="#MMU的工作过程" class="headerlink" title="MMU的工作过程"></a>MMU的工作过程</h2><p>虚拟地址映射到真正的物理地址的过程是MMU工作的核心</p>
<img src="/2022/06/28/binder%EF%BC%88%E4%BA%8C%EF%BC%89MMU%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83%E6%B5%85%E6%9E%90/%E9%A1%B5%E5%92%8C%E9%A1%B5%E6%A1%86%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png" class="" title="页和页框映射关系图">

<p>在这个例子中我们有一台可以生成16位地址的机器，它的虚拟地址范围从0x0000~0xFFFF(64K),而这台机器只有32K的物理地址，因此他可以运行64K的程序，但该程序不能一次性调入内存运行。这台机器必须有一个达到可以存放64K程序的外部存储器（例如磁盘或是FLASH）以保证程序片段在需要时可以被调用。在这个例子中，页的大小为4K，页框大小与页相同（这点是必须保证的，内存和外围存储器之间的传输总是以页为单位的），对应64K的虚拟地址和32K的物理存储器，他们分别包含了16个页和8个页框。</p>
<p>我们先根据上图解释一下分页后要用到的几个术语，在上面我们已经接触了<strong>页</strong> 和<strong>页框</strong>，上图中蓝色部分是物理空间，其中每一格表示一个物理页框。橙色部分是虚拟空间，每一格表示一个页，它由两部分组成，分别是Frame Index(页框索引)和位p（present 存在位），<strong>Frame Index</strong>的意义很明显，它指出本页是往哪个物理页框进行映射的，<strong>位p</strong>的意义则是指出本页的映射是否有效，如上图，当某个页并没有被映射时（或称映射无效，Frame Index部分为X），该位为0，映射有效则该位为1。</p>
<p>我们执行下面这些指令（本例子的指令不针对任何特定机型，都是伪指令）</p>
<p><strong>例1:</strong></p>
<blockquote>
<p>MOVE REG,0 &#x2F;&#x2F;将0号地址的值传递进寄存器REG</p>
</blockquote>
<p>虚拟地址0将被送往MMU,MMU看到该虚地址落在页0范围内（页0范围是0到4095），从上图我们看到页0所对应（映射）的页框为2（页框2的地址范围是8192到12287），因此MMU将该虚拟地址转化为物理地址8192，并把地址8192送到地址总线上。内存对MMU的映射一无所知，它只看到一个对地址8192的读请求并执行它。MMU从而把0到4096的虚拟地址映射到8192到12287的物理地址。</p>
<p><strong>例2：</strong></p>
<blockquote>
<p>MOVE REG,8192<br>被转换为<br>MOVE REG,24576</p>
</blockquote>
<p>因为虚拟地址8192在页2中，而页2被映射到页框6（物理地址从24576到28671）</p>
<p><strong>例3：</strong></p>
<blockquote>
<p>MOVE REG,20500<br>    被转换为<br>    MOVE REG,12308</p>
</blockquote>
<p>虚拟地址20500在虚页5（虚拟地址范围是20480到24575）距开头20个字节处，虚页5映射到页框3（页框3的地址范围是 12288到16383），于是被映射到物理地址12288+20&#x3D;12308。</p>
<p>通过适当的设置MMU，可以把16个虚页隐射到8个页框中的任何一个，但是这个方法并没有有效的解决虚拟地址空间比物理地址空间大的问题。从上图中我们可以看到，我们只有8个页框（物理地址），但我们有16个页（虚拟地址），所以我们只能把16个页中的8个进行有效的映射。我们看看例4会发生什么情况：</p>
<p><strong>例4：</strong></p>
<blockquote>
<p>MOV REG,32780</p>
</blockquote>
<p>虚拟地址32780落在页8的范围内，从上图总我们看到页8没有被有效的进行映射（该页被打上X），这是又会发生什么？MMU注意到这个页没有被映射，于是通知CPU发生一个缺页故障（page fault）.这种情况下操作系统必须处理这个页故障，它必须从8个物理页框中找到1个当前很少被使用的页框并把该页框的内容写入外围存储器（这个动作被称为page copy），随后把需要引用的页（例4中是页8）映射到刚才释放的页框中（这个动作称为修改映射关系），然后从新执行产生故障的指令（MOV REG,32780）。假设操作系统决定释放页框1，那么它将把虚页8装入物理地址的4-8K,并做两处修改：首先把标记虚页1未被映射（原来虚页1是被影射到页框1的），以使以后任何对虚拟地址4K到8K的访问都引起页故障而使操作系统做出适当的动作（这个动作正是我们现在在讨论的），其次他把虚页8对应的页框号由X变为1，因此重新执行MOV REG,32780时，MMU将把32780映射为4108。</p>
<p>我们大致了解了MMU在我们的机器中扮演了什么角色以及它基本的工作内容是什么，下面我们将举例子说明它究竟是如何工作的（注意，本例中的MMU并无针对某种特定的机型，它是所有MMU工作的一个抽象）。</p>
<p>首先明确一点，MMU的主要工作只有一个，就是把虚拟地址映射到物理地址。<br>我们已经知道，大多数使用虚拟存储器的系统都使用一种称为分页（paging）的技术，就象我们刚才所举的例子，虚拟地址空间被分成大小相同的一组页，每个页有一个用来标示它的页号（这个页号一般是它在该组中的索引，这点和C&#x2F;C++中的数组相似）。<br>在上面的例子中0-4K的页号为0，4-8K的页号为1，8-12K的页号为2，以此类推。而虚拟地址（注意：是一个确定的地址，不是一个空间）被MMU分为2个部分，第一部分是页号索引（page Index），第二部分则是相对该页首地址的偏移量（offset）. 。我们还是以刚才那个16位机器结合下图进行一个实例说明，该实例中，虚拟地址8196被送进MMU,MMU把它映射成物理地址。16位的CPU总共能产生的地址范围是0-64K,按每页4K的大小计算，该空间必须被分成16个页。而我们的虚拟地址第一部分所能够表达的范围也必须等于16（这样才能索引到该页组中的每一个页）,也就是说这个部分至少需要4个bit。一个页的大小是4K(4096),也就是说偏移部分必须使用12个bit来表示(2^12&#x3D;4096，这样才能访问到一个页中的所有地址),8192的二进制码如下图所示：</p>
<img src="/2022/06/28/binder%EF%BC%88%E4%BA%8C%EF%BC%89MMU%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83%E6%B5%85%E6%9E%90/%E9%A1%B5%E7%B4%A2%E5%BC%95%E5%8F%B7%E4%B8%8E%E5%81%8F%E7%A7%BB%E9%87%8F%E5%85%B3%E7%B3%BB%E5%9B%BE.png" class="" title="页索引号与偏移量关系图">
<p>该地址的页号索引为0010（二进制码），既索引的页为页2，第二部分为000000000100（二进制），偏移量为4。页2中的页框号为6（页2映射在页框6，见上图），我们看到页框6的物理地址是24-28K。<br>于是MMU计算出虚拟地址8196应该被映射成物理地址24580（页框首地址+偏移量&#x3D;24576+4&#x3D;24580）。同样的，若我们对虚拟地址1026进行读取，1026的二进制码为0000010000000010，page index&#x3D;”0000”&#x3D;0,offset&#x3D;010000000010&#x3D;1026。页号为0，该页映射的页框号为2，页框2的物理地址范围是8192-12287，故MMU将虚拟地址1026映射为物理地址9218（页框首地址+偏移量&#x3D;8192+1026&#x3D;9218）。</p>
<h2 id="MMU-的-TLB"><a href="#MMU-的-TLB" class="headerlink" title="MMU 的 TLB"></a>MMU 的 TLB</h2><p>由上面的例子可知，在 MMU 工作的时候，软件也需要进行配合，软件需要准备一张表，来告诉 MMU 当前的地址映射的关系（即，虚拟地址和物理地址的对应关系）。而这张表存储在内存中（代码的数据结构），每次 MMU 工作的时候，都去遍历这个表里面的关系，然后找到对应的映射，这个过程叫做 table walk。这样会严重影响系统效率。于是乎，MMU 中增加了 Cache，这个 Cache 叫做 TLB。</p>
<p>为了减少存储器访问的平均消耗， 转换表遍历结果被高速缓存在一个或多个叫作 Translation Lookaside Buffers(TLBs)的结构中。通常在ARM 的实现中每个内存接口有一个TLB。当存储器中的转换表被改变或选中了不同的转换表(通过写CP15 的寄存器，先前高速缓存的转换表遍历结果将不再有效。MMU 结构提供了刷新TLB 的操作。MMU 结构也允许特定的转换表遍历结果被锁定在一个TLB 中，这就保证了对相关的存储器区域的访问绝不会导致转换表遍历，这也对那些把指令和数据锁定在高速缓存中的实时代码有相同的好处。</p>
<p>当ARM 要访问存储器时，MMU 先查找 TLB 中的虚拟地址表，如果没有命中，则，还是要去走 table walk 的流程。即，如果TLB 中没有虚拟地址的入口，则转换表遍历硬件从存在主存储器中的转换表中获取转换和访问权限。一旦取到，这些信息将被放在 TLB 中，它会放在一个没有使用的入口处或覆盖一个已有的入口。</p>
<p>参考文章：<br><a href="https://blog.csdn.net/usstmiracle/article/details/112348497">什么是MMU</a><br><a href="https://baijiahao.baidu.com/s?id=1707689267846151875&wfr=spider&for=pc">关于Linux 虚拟内存，你真的理解到位了嘛？</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>binder</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle插件开发</title>
    <url>/2022/04/12/gradle%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<hr>
<h3 id="gradle插件开发的方式"><a href="#gradle插件开发的方式" class="headerlink" title="gradle插件开发的方式"></a>gradle插件开发的方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;com.android.application&#x27;</span><br><span class="line">apply plugin: &#x27;com.android.library&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Build script脚本</td>
<td>把插件写在build.gradle文件中，一般用于简单逻辑，作用范围为build.gradle文件</td>
</tr>
<tr>
<td>buildSrc目录</td>
<td>将插件源代码放在buildSrc&#x2F;src&#x2F;main&#x2F;中，作用范围为该项目</td>
</tr>
<tr>
<td>独立项目</td>
<td>一个独立的java项目&#x2F;模块,可将文件发布到仓库(jcenter)，使其他项目可以方便引入</td>
</tr>
</tbody></table>
<hr>
<p>任何可以运行在jvm中的语言都能用来开发gradle插件，比如groovy最终编译产物也是.class文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、aapt 打包资源文件 阶段</span><br><span class="line">2、aidl 转 java 文件 阶段</span><br><span class="line">3、Java 编译（Compilers）生成.class 文件 阶段</span><br><span class="line">4、dex（生成 dex 文件）阶段</span><br><span class="line">5、apkbuilder（生成未签名 apk）阶段</span><br><span class="line">6、Jarsigner（签名）阶段</span><br><span class="line">7、zipalign（对齐） 阶段</span><br><span class="line">[https://juejin.cn/post/6844903850453762055#heading-6](https://juejin.cn/post/6844903850453762055#heading-6)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>java类加载原理(ClassLoader工作原理)</title>
    <url>/2022/04/16/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-ClassLoader%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="什么是类加载"><a href="#什么是类加载" class="headerlink" title="什么是类加载"></a>什么是类加载</h2><p>在java开发中我们在.java文件中编写代码，之后通过javac指令编译成.class文件。当然如果是编写的Android应用后续又会经过dx工具将.class变为.dex文件(这不是本章重点)。</p>
<p>当javac编译成.class文件之后，它是以文件的形式存在的。比如MainActivity.java -&gt; javac -&gt; MainActivity.class。当我们程序中要使用MainActivity的时候，肯定要将这个文件加载到内存中来变成一个类对象这样才能去使用它。</p>
<span id="more"></span>

<img src="/2022/04/16/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-ClassLoader%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86.png" class="" title="类加载原理">

<p><strong>具体来说类加载就是将类的.class文件转为二进制数据读取到虚拟机内存的方法区中，当对象实例进行创建的时候会在堆内存中创建这个类的class对象，用来封装类在方法区中的数据结构。</strong></p>
<p><strong>类加载最终的产物就是这个类对应的Class对象，它封装了方法区中的类的数据结构，并向程序员提供了访问接口。</strong></p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>java的类加载分为3个步骤：</p>
<ol>
<li>装载（Load)：查找并加载类的二进制字节码(.class)文件。</li>
<li>链接（Link）</li>
<li>初始化（Initialize）：<strong>对类的静态变量、静态代码块执行初始化操作</strong>。</li>
</ol>
<p>对于链接这一过程分为3个子过程：</p>
<ol>
<li>验证：确保被加载的类的正确性</li>
<li>准备：为类的静态变量分配内存并初始化为默认值（这个初始化与初始化流程中的初始化不一样，这里是初始化为默认值，下一个流程中是初始化为指定值）</li>
<li>解析：把类中的符号引用转换为直接引用</li>
</ol>
<img src="/2022/04/16/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-ClassLoader%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" class="" title="java类加载过程">

<h4 id="思考1-为什么要有验证阶段？"><a href="#思考1-为什么要有验证阶段？" class="headerlink" title="思考1:为什么要有验证阶段？"></a>思考1:为什么要有验证阶段？</h4><p>由Java编译器编译生成的.class文件一定是符合JVM字节码格式的，由JVM加载并运行，为了避免人为写一个.class文件，用于恶意用途，就需要有验证，不符合格式的不让它继续运行，确保安全。</p>
<h4 id="思考2-链接中的准备过程和初始化过程有什么区别？"><a href="#思考2-链接中的准备过程和初始化过程有什么区别？" class="headerlink" title="思考2:链接中的准备过程和初始化过程有什么区别？"></a>思考2:链接中的准备过程和初始化过程有什么区别？</h4><p>准备过程是初始化为默认值，而初始化过程是将变量赋予正确的值。</p>
<h4 id="什么情况会导致类的初始化？"><a href="#什么情况会导致类的初始化？" class="headerlink" title="什么情况会导致类的初始化？"></a>什么情况会导致类的初始化？</h4><ul>
<li>创建类实例时（也就是new）</li>
<li>访问某个类或者接口的静态变量时（其实接口中的变量都是public final static的），或者是对该静态变量进行赋值时</li>
<li>调用类的静态方法</li>
<li>反射时（Class.forName(clzName)），这种情况下面会有说明</li>
<li>初始化一个类的子类(会首先初始化其父类)</li>
<li>JVM启动时表明的启动类，即文件名和类名相同的那个类</li>
</ul>
<h4 id="系统为我们提供了2种类加载方式："><a href="#系统为我们提供了2种类加载方式：" class="headerlink" title="系统为我们提供了2种类加载方式："></a>系统为我们提供了2种类加载方式：</h4><ul>
<li>Class.forName(clzName)</li>
<li>ClassLoader.loadClass(clzName)</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>类加载器是系统为我们提供的加载类的工具类，基类是ClassLoader，在Java中默认提供了：</p>
<ul>
<li>BootStrap:引导类加载器（启动类加载器）</li>
<li>ExtClassLoader:拓展类加载器</li>
<li>AppClassLoader：系统类加载器<br>除了这几个默认的之外我们也可以自定义一个类加载器去加载指定目录中的类。例如Android中定义了：</li>
<li>BootClassLoader:加载AndroidFramework层class文件（Android系统类）</li>
<li>BaseDexClassLoader(其子类有PathClassLoader、DexClassLoader用于加载指定目录虾的.dex文件中的class类)</li>
</ul>
<p><strong>归根结底其实类加载器就是一个加载类的工具，而不同类加载器的区别就是加载的类所处的目录不同而已</strong>，具体原因后续讲双亲委托机制时详述。</p>
<h4 id="思考3-类加载也是类，那类加载器被谁加载？"><a href="#思考3-类加载也是类，那类加载器被谁加载？" class="headerlink" title="思考3:类加载也是类，那类加载器被谁加载？"></a>思考3:类加载也是类，那类加载器被谁加载？</h4><p>BootStrap不是java类，它是c&#x2F;c++写的，是jvm内核的组成部分，它主要用于加载jvm运行必须的类。而ExtClassLoader和AppClassLoadeer是java类，他们是被BootStrap所加载。BootStrap是无法被java程序直接引用的。</p>
<h2 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h2><img src="/2022/04/16/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-ClassLoader%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6.jpg" class="" title="双亲委托机制">

<h4 id="类加载器的父子结构"><a href="#类加载器的父子结构" class="headerlink" title="类加载器的父子结构"></a>类加载器的父子结构</h4><p>jvm所有的类加载器都采用父子关系的树形结构进行组织（但是注意不是java语法上的父子关系，不是继承），它的原理是在实例化每个类加载器的时候都得为其指定一个父类加载器对象或者默认采用系统类加载器为其父类加载器。（类加载器中有一个parent属性，组织父子结构是通过为parent赋值来实现的）</p>
<p>每个类加载器都有自己的加载区域，它只能在自己的加载区域中寻找类。</p>
<h4 id="双亲委托机制工作原理"><a href="#双亲委托机制工作原理" class="headerlink" title="双亲委托机制工作原理"></a>双亲委托机制工作原理</h4><p><strong>当使用某个类加载器去加载一个类的时候，首先会委托给其父类去加载，当父类还有父类的时候会一层层向上委托直至没有父类。也就是说父类相对于子类来说具有绝对的优先加载权。因此，所有的类加载请求都应该被传递到顶层的引导类加载器中，如果父类加载器加载到类了那就直接返回该类，只有当父类加载器在它的加载区域中找不到所要加载的类时，才会把加载权再归还给子类去加载。</strong></p>
<p>这就是大名鼎鼎的双亲委托机制。</p>
<p>这么设计有什么好处呢？</p>
<ol>
<li>保证了同一个类不会被重复加载（不会被多个类加载器加载）</li>
<li>保证了类加载的安全性（例如假如有人自己创建了一个java.lang.String类也无法替换掉系统中的java.lang.String类，因为类加载会最终委托到父类加载器中，所以系统中的java.lang.String一定是先被找到的）</li>
</ol>
<p><strong>类加载器加载一个类的时候会首先从缓存中找，如果找到了就直接返回类，如果没找到才会继续向上委托。当成功加载到某个类的时候，会将得到的Class对象缓存起来用于下次加载这个类的时候直接返回。</strong><br>不信可以看看java ClassLoader类的loadClass()实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        // 找缓存</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        // 缓存中没有，则开始双亲委托机制</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    // 从父类加载器加载</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 没有父说明这个已经是Bootstrap</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 没有加载到，则在自己的区域中寻找类</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思考4-为什么静态元素和静态代码块在虚拟机种只会执行一次？"><a href="#思考4-为什么静态元素和静态代码块在虚拟机种只会执行一次？" class="headerlink" title="思考4:为什么静态元素和静态代码块在虚拟机种只会执行一次？"></a>思考4:为什么静态元素和静态代码块在虚拟机种只会执行一次？</h4><p>因为默认情况下赋值静态域的过程（初始化）或者是执行静态代码块是在类加载流程中执行的，而同一个类根据双亲委托机制只会被加载一次，如果第二次加载它会直接从缓存中取。当然如果你自己定义了一个类加载器再去手动加载它的话就另当别论了（假设加载类A，正常代码中类在AppClassLoader中被加载成功，此时你自定义一个类加载器并且它的加载区域中也有类A一样的class，并且把它的父类加载器设置成ExtClassLoader，那么肯定这时候通过自定义类加载器去加载那也能加载出一个类A，此时类A中的静态代码也会执行，<strong>但是，但是，但是这个但是很重要，但是此时加载出来的这俩类A不是同一个类</strong>）。</p>
<h4 id="届定2个类是不是同一个类对象"><a href="#届定2个类是不是同一个类对象" class="headerlink" title="届定2个类是不是同一个类对象"></a>届定2个类是不是同一个类对象</h4><p><strong>这也就是思考4中的但是，2个类对象是否是同一个取决于：类的全类名、加载它的类加载器以及类加载器的实例这三个条件，这三个条件中只要有一个不相同，加载后生成的Class对象就不是同一个，最终生成的类的实例的类型也不相同。</strong></p>
<p>所以即使是同一个类，用不同的类加载器去加载的话产生的对象也是不同的，不能进行互相赋值否则会出现类转换异常。</p>
<h4 id="Class-forName-clzName-的原理"><a href="#Class-forName-clzName-的原理" class="headerlink" title="Class.forName(clzName)的原理"></a>Class.forName(clzName)的原理</h4><p>直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Class&lt;?&gt; forName(String className)</span><br><span class="line">            throws ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    // 内部也是使用ClassLoader进行类加载，只是加载完成之后会自动执行初始化，同时forName0()的initialize参数决定</span><br><span class="line">    return forName0(className, true, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static native Class&lt;?&gt; forName0(String name, boolean initialize,</span><br><span class="line">                                    ClassLoader loader,</span><br><span class="line">                                    Class&lt;?&gt; caller)</span><br><span class="line">throws ClassNotFoundException;</span><br></pre></td></tr></table></figure>
<p>所以Class.forName(clzName)本质上也是通过ClassLoader.loadClass(clzName)进行类加载，只是它会执行初始化，而直接通过ClassLoader.loadClass(clzName) 加载的类只有达到上面说的几个条件才会执行初始化流程。</p>
<p>下一章我们讲一下Android中的类加载器：<a href="http://lianwenhong.top/2022/04/14/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-App%E7%9A%84ClassLoader/#more">Android源码解析-App的ClassLoader</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>最讨厌QA提按钮快速点击的bug了</title>
    <url>/2022/06/24/%E6%9C%80%E8%AE%A8%E5%8E%8CQA%E6%8F%90%E6%8C%89%E9%92%AE%E5%BF%AB%E9%80%9F%E7%82%B9%E5%87%BB%E7%9A%84bug%E4%BA%86/</url>
    <content><![CDATA[<h1 id="FilterFastClick"><a href="#FilterFastClick" class="headerlink" title="FilterFastClick"></a>FilterFastClick</h1><p><strong>首先声明：本库的编写是被QA逼出来的。</strong></p>
<p>在开发过程中经常被QA提一类恶心的bug（快速点击控件出现多个页面或多个弹窗等）</p>
<p>我司QA拿到包之后第一件事就爱测快速点击的场景，他们认为同一个按钮快速点击可能是误操作不应该得到响应。比如某个按钮点击之后应该弹出一个dialog，QA双击控件就出现2个dialog。这原本应该是个正常的场景，但是奈何抵不过他们一直提，所以就做了这个小功能加以限制。</p>
<p>其实这就是个典型的AOP编程了。</p>
<p>屏蔽快速点击最常见的操作是做一个工具类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Utils&#123;</span><br><span class="line">    // 检测以避免重复多次点击</span><br><span class="line">    private static long lastClickTime;</span><br><span class="line"></span><br><span class="line">    public static boolean isFastDoubleClick() &#123;</span><br><span class="line">        long time = System.currentTimeMillis();</span><br><span class="line">        long timeD = time - lastClickTime;</span><br><span class="line">        if (0 &lt; timeD &amp;&amp; timeD &lt; 500) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        lastClickTime = time;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能解决90%问题。</p>
<p>奈何我司QA测得又比较细，某天提了一个更让人心烦的问题：<br>某个页面上有多个按钮，点击button1的时候紧接着在500毫秒以内又点击了button2，这时候预期应该是button1和button2都应该得到响应。但是因为button1和button2的点击事件都加上了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(Utils.isFastDoubleClick())&#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的限制，由于全局都使用的同一个静态lastClickTime变量，就导致这两个控件之间的点击相互屏蔽了。如果是点击button1之后的500毫秒以内点击了button2将会导致button2点击事件中的<code>Utils.isFastDoubleClick()</code>这句代码为true而走了return。</p>
<p>那么解决的途径只能是不使用全局的lastClickTime这个变量来做上一次点击时间戳的判断，而是对每个控件都单独使用一个变量来记录。</p>
<p>那么最简单的做法就是实现一个自己的OnClickListener类，然后在每个控件设置点击事件的时候都使用这个类来屏蔽快速点击：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class FilterFastClickListener implements View.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    private long lastClickTime;</span><br><span class="line"></span><br><span class="line">    private boolean isFastDoubleClick() &#123;</span><br><span class="line">        long time = System.currentTimeMillis();</span><br><span class="line">        long timeD = time - lastClickTime;</span><br><span class="line">        if (0 &lt; timeD &amp;&amp; timeD &lt; 500) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        lastClickTime = time;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        if (isFastDoubleClick()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        onNoDoubleClick(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void onNoDoubleClick(final View v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用时：</span><br><span class="line">button.setOnClickListener(new FilterFastClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNoDoubleClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样基本就能解决同一页面之间多个控件快速点击的相互干扰问题。但是我又不喜欢这么做，因为这将导致每个控件都得单独设置一个新的<code>FilterFastClickListener</code>对象。这样即占用内存代码又不太优雅，我不爱。</p>
<p>所以就接着想，想过使用动态代理模式来实现AOP编程，但是明显这种方式写出来的代码看着更蠢，不仅要改变原有的代码写法而且上述的问题一个它也逃不脱。不过还是写出来玩玩：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">View.OnClickListener onClickListener = new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        doClickNoFilter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">btnNoFilter.setOnClickListener((View.OnClickListener) Proxy.newProxyInstance(onClickListener.getClass().getClassLoader(), onClickListener.getClass().getInterfaces(), new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">    private long lastClickTime;</span><br><span class="line"></span><br><span class="line">    private boolean isFastDoubleClick() &#123;</span><br><span class="line">        long time = System.currentTimeMillis();</span><br><span class="line">        long timeD = time - lastClickTime;</span><br><span class="line">        if (0 &lt; timeD &amp;&amp; timeD &lt; 500) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        lastClickTime = time;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        if (isFastDoubleClick()) return null;</span><br><span class="line">        return method.invoke(onClickListener, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>最终其实还有很多种方案来实现，比如将系统源码中的<code>mOnClickListener</code>进行接管，但是又得考虑系统版本升级万一要是哪一天系统源码发生变化没有及时适配这可能会是个大雷就放弃了。</p>
<p>因为之前有了解过一些例如AspectJ，ASM，APT，javassist等相关知识，我觉得正好借着这个契机使用一下。</p>
<p>一开始考虑使用类似ButterKnife的实现方案，写个注解然后解析注解再进行动态注入代码，也可以搭配JavaPoet一起，但是由于我是要在原有函数内部实现代码注入而APT和javaPoet搭配一般都是用于生成新的类所以这种方式不合适。用AspectJ这种较为成熟的方案比较麻烦，所以最终我选择用Javassist来对class文件进行动态代码注入来实现功能。</p>
<p>我的思路是：</p>
<p>既然每个点击要互不干扰又能实现单个控件屏蔽快速点击，那就必须每个控件都有一个记录上次点击时间的变量，我选择把这个区分标准转移给方法。这样就能实现每个控件的点击调用一个单独方法，针对每个单独方法我生成一个唯一的类变量，各个控件调用对应方法也就互不影响了。但是生成的类变量要保证唯一，所以我创建了一个注解，给注解指定值来保证每个生成的类变量都可控。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * value属性是标记方法的唯一标识，同一类中的value属性不可相同</span><br><span class="line"> * 否则可能出现2个方法直接互相过滤点击</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 注解保留时机必须持续到RUNTIME，因为javassist处理的就是class文件</span><br><span class="line"> * 如果是SOURCE或CLASS时本注解已被去除所以会导致在解析类时找不到该注解</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface FastClick &#123;</span><br><span class="line">    int value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在javassist工作的时候我只需要扫描出所有类中的所有方法，如果方法中带有@FastClick这个注解我就拿注解的value值拼接生成对应该方法的类变量，并对该方法注入屏蔽快速点击的业务代码。</p>
<p>这样在要屏蔽快速点击时，只需给每个控件对应的点击方法加一个注解，在注解中指定一个在本类中唯一的标识值即可。这样在使用的时候十分方便。</p>
<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    private Button btnFilter, btnNoFilter;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        btnFilter = findViewById(R.id.id_tv_btn1);</span><br><span class="line">        btnNoFilter = findViewById(R.id.id_tv_btn2);</span><br><span class="line">        btnFilter.setOnClickListener(this);</span><br><span class="line">        btnNoFilter.setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        switch (view.getId()) &#123;</span><br><span class="line">            case R.id.id_tv_btn1:</span><br><span class="line">                doClickFilter();</span><br><span class="line">                break;</span><br><span class="line">            case R.id.id_tv_btn2:</span><br><span class="line">                doClickNoFilter();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @FastClick(value = 1)</span><br><span class="line">    public void doClickFilter() &#123;</span><br><span class="line">        Log.e(&quot;lianwenhong&quot;, &quot; &gt;&gt;&gt; 我点击了,时间戳:&quot; + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doClickNoFilter() &#123;</span><br><span class="line">        Log.e(&quot;lianwenhong&quot;, &quot; &gt;&gt;&gt; 我点击了,时间戳:&quot; + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码奉上：<a href="https://github.com/lianwenhong/FilterFastClick">https://github.com/lianwenhong/FilterFastClick</a></p>
<h3 id="如果有朋友想接入，那么可以提供2种方式可接入："><a href="#如果有朋友想接入，那么可以提供2种方式可接入：" class="headerlink" title="如果有朋友想接入，那么可以提供2种方式可接入："></a>如果有朋友想接入，那么可以提供2种方式可接入：</h3><p>假设您的主module名为app。</p>
<h4 id="使用方法1（黑盒方式）"><a href="#使用方法1（黑盒方式）" class="headerlink" title="使用方法1（黑盒方式）:"></a>使用方法1（黑盒方式）:</h4><ol>
<li>拷贝annotations库至自己工程中，放在与app模块同级目录下。</li>
<li>修改settings.gradle文件将这两个工程加入编译<code>include &#39;:annotations&#39;</code></li>
<li>拷贝javassist-jar文件夹至自己工程中，放在与annotations同级目录下。</li>
<li>在工程-&gt;build.gradle文件中repositories{}中增加本地的javassist-jar路径为maven仓库路径（）<code>maven &#123; url(&quot;./javassist-jar&quot;) &#125;</code></li>
<li>在工程-&gt;build.gradle文件中dependencies{}增加<code>classpath &quot;com.lianwenhong.clickfilter:modify:1.0.0&quot;</code>依赖</li>
<li>在app-&gt;build.gradle文件增加plugin: ‘com.lianwenhong.clickfilter’代码</li>
<li>然后Sync工程即可。此时可以直接在想要屏蔽的方法上增加@FastClick就可实现快速点击屏蔽</li>
</ol>
<h4 id="使用方式2（白盒方式）"><a href="#使用方式2（白盒方式）" class="headerlink" title="使用方式2（白盒方式）:"></a>使用方式2（白盒方式）:</h4><ol>
<li>拷贝annotations库至自己工程中，放在与app模块同级目录下。</li>
<li>拷贝lib库至自己工程中，放在与app模块同级目录下。</li>
<li>修改settings.gradle文件将这两个工程加入编译<code>include &#39;:lib&#39; include &#39;:annotations&#39;</code></li>
<li>先执行lib工程的publishing这个task让它生成javassist-jar下的jar包</li>
<li>然后执行方法1中的4.5.6.7步骤即可。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-代理模式</title>
    <url>/2022/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>java的代理模式是很常见的一种设计模式，记录一下我的理解。<a href="https://github.com/HomerLian/DesignMode/tree/master/ProxyMode">源码</a></p>
<p>代理模式主要的思想是将委托类（被代理类）和真正使用委托类逻辑的类做一个解耦。<br>主要有2个好处：<br>    1.保护目标对象：被代理类无需对外公开，外部通信仅通过代理类进行沟通<br>    2.增强目标对象：可以在不改动被代理类的情况下对所需功能做增强，外部调用方对此也无感知<br>不考虑很多根据业务场景的分类（比如远程代理、虚拟代理、保护代理等等等…），我们只考虑编码实现方案那就分为2种：</p>
<ol>
<li>静态代理</li>
<li>动态代理</li>
</ol>
<p>对于真正使用代理的场景有很多，例如Android中Resource与ResourceImpl、Retrofit中获取api接口、Collections.synchronizedList实现线程安全数组等场景。这里暂时不展开说明，如有兴趣再行记录。</p>
<p>举个生活中的例子：</p>
<p>假设你爸让你帮他买张机票此时你想在你爸不知情的情况下赚点零花钱。你上网查携程上的票价是1000元，你跟你爸说这张票1500，这样你就从中赚取了500零花钱。</p>
<span id="more"></span>

<p>这就是一个典型的代理模式。其中的角色分别是：</p>
<p>携程         –&gt; 被代理类<br>你         –&gt; 代理类<br>你爸         –&gt; 用户，享受服务的一方<br>先试写一下对于这件事我们如何编码，我们使用代理模式是为了让结构更灵活更清晰，所以此时我们的实现思路是这样：</p>
<ol>
<li>将买票这个行为抽象出来，不管是哪个角色，最终想要的结果都是买票</li>
<li>找一个真正买票的地方实现买票服务，也就是创建一个被代理类</li>
<li>你去把票买了然后把票给你爸，也就是对外提供一个代理类，用户通过这个代理类获得服务。此时这个代理类就是你。</li>
</ol>
<p>不管是动态代理还是静态代理，都得实现这几个步骤。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>1.我们要做的是买票，那就把它抽象出一个接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抽象出来的买票服务接口，大家想做的事都是买票这么个事</span><br><span class="line"> */</span><br><span class="line">public interface TicketServer &#123;</span><br><span class="line">    float buyTicket(String dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.我从携程去买，那就创建一个携程类，然后去实现买票服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 被代理类</span><br><span class="line"> * 真正提供服务的地方，干实事的</span><br><span class="line"> */</span><br><span class="line">public class XC implements TicketServer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public float buyTicket(String dest) &#123;</span><br><span class="line">        System.out.println(&quot;出票成功 机票 To &quot; + dest + &quot; No:&quot; + (int) (Math.random() * 1000));</span><br><span class="line">        return 1000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.创建一个实体对你爸提供服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Son implements TicketServer &#123;</span><br><span class="line"></span><br><span class="line">    TicketServer server = new XC();</span><br><span class="line"></span><br><span class="line">    public Son() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public float buyTicket(String dest) &#123;</span><br><span class="line">        float fares = server.buyTicket(dest);</span><br><span class="line">        fares += 500;</span><br><span class="line">        return fares;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里你老爸可以通过Son也就是你买到票了，你就是携程的代理，被代理类（目标类）就是携程。</p>
<p>老爸这个类可以这样子指使你：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Father &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      </span><br><span class="line">        TicketServer son = new XC(); // java多态的体现，你爸是想要买个票，所以让你买也行，让你姐去买也可以</span><br><span class="line">        System.out.println(&quot;票价为：&quot; + son.buyTicket(&quot;北京&quot;) + &quot;元&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此静态代理结束，此时你如果发现携程买的票比较贵你可以自己换成去哪儿，换成12306都是OK的，你爸并不知道。</p>
<p>但是有个问题，如果你爸知道你赚他钱就让你姐去买，那你姐是不是也要和Son这个代理类一样去创建一个Daughter类，然后实现和你一样的功能？这样的话如果你爸再想找别人别人还得创建这个类。明显静态代理的方式虽然能达到我们所要的保护目标和增强目标的2个目的，但是略显冗余了。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>用动态代理实现也是一样的步骤，只不过Son类不需要我们再手动创建，而是调用Proxy的API让系统通过反射替我们动态生成。</p>
<p>你老爸这样调用你去买票：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Father &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">      </span><br><span class="line">        TicketServer son = (TicketServer) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;TicketServer.class&#125;, new InvocationHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                TicketServer xc = new XC();</span><br><span class="line">                float fares = (float) method.invoke(xc, args);</span><br><span class="line">                return fares + 500;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;票价为：&quot; + son.buyTicket(&quot;北京&quot;) + &quot;元&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里静态代理和动态代理的写法都写完了。但是为了结构更清晰，我们把对老爸提供的东西做一个抽取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TicketUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态代理方式</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static TicketServer staticTicket() &#123;</span><br><span class="line">        return new Son();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 动态代理方式</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static TicketServer dynamicTicket() &#123;</span><br><span class="line">        TicketServer server = new XC();</span><br><span class="line"></span><br><span class="line">        return (TicketServer) Proxy.newProxyInstance(server.getClass().getClassLoader(), server.getClass().getInterfaces(), new InvocationHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                float fares = (float) method.invoke(server, args);</span><br><span class="line">                fares += 500;</span><br><span class="line">                return fares;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你爸最后调用你就很简单了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Father &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 这段代码可以在ide中输出用户为我们生成的临时类</span><br><span class="line">        System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 静态代理方式</span><br><span class="line">         */</span><br><span class="line">//        TicketServer son = TicketUtils.staticTicket();</span><br><span class="line">//        System.out.println(&quot;票价为：&quot; + son.buyTicket(&quot;北京&quot;) + &quot;元&quot;);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 动态代理方式</span><br><span class="line">         */</span><br><span class="line">        TicketServer son = TicketUtils.dynamicTicket();</span><br><span class="line">        System.out.println(&quot;票价为：&quot; + son.buyTicket(&quot;北京&quot;) + &quot;元&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是最最最基础的讲解了。</p>
<p>接下来我们来看看Proxy这个类如何帮我们完成代理类的创建工作。</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// loader：类加载器，用于在动态生成类之后将类加载进来</span><br><span class="line">// interfaces：所需要实现的接口，也就是我们抽象出来的公共接口，上例中的TicketServer</span><br><span class="line">// h：执行handler</span><br><span class="line">public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure>
<p>首先我们看一下系统为我们生成的类长什么样子这样才能更好的理解它生成的类是如何为我们工作的。<br>通过<code> System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</code><br>这段代码会将动态生成的类保留下来，我们可以在ide中看到类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 它实现了TicketServer接口，和我们自己创建代理类时一样</span><br><span class="line">// 它继承了Proxy</span><br><span class="line">public final class $Proxy0 extends Proxy implements TicketServer &#123;</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public final float buyTicket(String var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Float)super.h.invoke(this, m3, new Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m3 = Class.forName(&quot;com.lianwenhong.proxydemo.TicketServer&quot;).getMethod(&quot;buyTicket&quot;, Class.forName(&quot;java.lang.String&quot;));</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在newProxyInstance（）方法中其实会通过反射调用构造方法，然后将我们传入的h传进来，所以这时候调用到$Proxy0的构造进而调用到父类的构造：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Proxy(InvocationHandler h) &#123;</span><br><span class="line">  	Objects.requireNonNull(h);</span><br><span class="line">  	this.h = h; // 先记住将h赋值给本地对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们拿到代理类调用buyTicket()时其内部是<code>return (Float)super.h.invoke(this, m3, new Object[]&#123;var1&#125;);</code>是调用h的invoke()方法，所以这时候也就是调用我们<code>Proxy.newProxyInstance()</code>时传入的InvocationHandler对象。而m3是在静态代码块中赋值的也就是buyTicket()方法。所以到这里就可以理解了为什么最终我们要在InvocationHandler-&gt;invoke()方法中做买票的逻辑了。</p>
<p>Proxy.newProxyInstance() -&gt; InvocationHandler.invoke()的回调过程已然形成闭环。</p>
<p>接下来我们看下Proxy.newProxyInstance()是如何返回代理类实例的（也就是$Proxy0）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException&#123;</span><br><span class="line">		... 做一些前期判空和Access权限校验工作</span><br><span class="line">	</span><br><span class="line">	 // 返回代理类$Proxy0的Class对象（内部逻辑是缓存中有直接返回，否则通过ProxyClassFactory创建一个）</span><br><span class="line">     Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">		...</span><br><span class="line">     try &#123;</span><br><span class="line">		...</span><br><span class="line">		 // 通过反射找到构造方法</span><br><span class="line">         final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">         final InvocationHandler ih = h;</span><br><span class="line">         if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                 public Void run() &#123;</span><br><span class="line">                     // 设置构造方法可访问</span><br><span class="line">                     cons.setAccessible(true);</span><br><span class="line">                     return null;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">         // 通过反射new出$Proxy0对象并返回</span><br><span class="line">         return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">     &#125; catch (...)&#123;</span><br><span class="line">     	...</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>所以具体创建代理Class类的方法是在getProxyClass0()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    if (interfaces.length &gt; 65535) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   // proxyClassCache是一个缓存结构WeakCache，其使用方式类似map以所要代理的接口interface为key，以ProxyClassFactory为value，如果不存在该key则会通过ProxyClassFactory创建出一个代理类。</span><br><span class="line">    return proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首次进入代理类为空，是通过ProxyClassFactory.apply()方法生成的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">     // 遍历interface，找出代理类所应该继承的所有接口</span><br><span class="line">     for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">         Class&lt;?&gt; interfaceClass = null;</span><br><span class="line">         try &#123;</span><br><span class="line">             // 通过反射将接口Class对象加载进来，内部是使用了classloader类加载机制</span><br><span class="line">             interfaceClass = Class.forName(intf.getName(), false, loader);</span><br><span class="line">         &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">         &#125;</span><br><span class="line">         if (interfaceClass != intf) &#123;</span><br><span class="line">             throw new IllegalArgumentException(</span><br><span class="line">                 intf + &quot; is not visible from class loader&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      </span><br><span class="line">         if (!interfaceClass.isInterface()) &#123;</span><br><span class="line">         	 // 如果传入的不是接口类型，则会在此处抛出IllegalArgumentException异常提示传入的不是一个接口类型</span><br><span class="line">             throw new IllegalArgumentException(</span><br><span class="line">                 interfaceClass.getName() + &quot; is not an interface&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      </span><br><span class="line">         if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</span><br><span class="line">             throw new IllegalArgumentException(</span><br><span class="line">                 &quot;repeated interface: &quot; + interfaceClass.getName());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     String proxyPkg = null;     // package to define proxy class in</span><br><span class="line">     int accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">  </span><br><span class="line">     for (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">         int flags = intf.getModifiers();</span><br><span class="line">         if (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">             accessFlags = Modifier.FINAL;</span><br><span class="line">             String name = intf.getName();</span><br><span class="line">             int n = name.lastIndexOf(&#x27;.&#x27;);</span><br><span class="line">             String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));</span><br><span class="line">             if (proxyPkg == null) &#123;</span><br><span class="line">                 proxyPkg = pkg;</span><br><span class="line">             &#125; else if (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                 throw new IllegalArgumentException(</span><br><span class="line">                     &quot;non-public interfaces from different packages&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (proxyPkg == null) &#123;</span><br><span class="line">         // if no non-public proxy interfaces, use com.sun.proxy package</span><br><span class="line">         // 合成全类名，PROXY_PACKAGE其实是com.sun.proxy</span><br><span class="line">         proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     /*</span><br><span class="line">      * Choose a name for the proxy class to generate.</span><br><span class="line">      */</span><br><span class="line">     long num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">      //  生成文件名，例如$Proxy0，根据不同的需求创建出多个的话根据后面的数字区分</span><br><span class="line">     String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">    // 通过ProxyGenerator工具类根据一定规则编写内部逻辑代码并生成类字节数组，其实是一套通用写法</span><br><span class="line">     byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">         proxyName, interfaces, accessFlags);</span><br><span class="line">     try &#123;</span><br><span class="line">         // 调用defineClass0生成真正的class文件并加载进内存（其内部就是调用类加载器生成class文件并加载）</span><br><span class="line">         return defineClass0(loader, proxyName,</span><br><span class="line">                             proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">     &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">         throw new IllegalArgumentException(e.toString());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们只要了解一下就行。</p>
<p><strong>newProxyInstance()大致原理就是：</strong></p>
<ol>
<li><p>根据传入的接口信息去缓存中获取或创建代理类Class对象。<br><strong>a. 缓存中存在代理类class对象则直接返回</strong></p>
<p><strong>b. 不存在则根据传入的interface接口通过一系列拼接类名、定义修饰符等操作然后调用ProxyGenerator.generateProxyClass()方法生成字节数组，然后将该字节数组交给ClassLoader底层的defineClass0（native方法）生成一个新的class文件并返回。</strong></p>
</li>
<li><p>利用反射机制获取到代理类对象的构造方法并执行生成代理类对象并返回</p>
</li>
</ol>
<p><strong>总结：</strong> 就是根据传入的接口通过反射动态创建一个代理类对象，该对象继承于Proxy并实现代理模式中的接口，然后将创建代理类过程中传入的InvocationHandler对象保存起来，当调用目标方法时是调用保存起来的InvocationHandler对象的invoke()方法回调给使用者。</p>
<p><strong>By the way:</strong><br>源码中的ProxyClassFactory中是使用<code>sun.misc.ProxyGenerator</code> 类来生class的。生成Class文件的方法不止这一个，我们也可以用 Javassist 技术动态生成class。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>动态代理也可以用于实现AOP切面编程。例如方法的埋点，耗时统计等等。只需在invoke内部实现AOP的业务逻辑即可。这样JVM动态生成代理类时就包含了所需的AOP逻辑。</p>
<p>参考文章：<br><a href="https://www.jianshu.com/p/5c8a9a334034">JVM的Proxy.newProxyInstance原理分析</a><br><a href="https://zhuanlan.zhihu.com/p/349659128">自己实现Java 动态代理 Proxy</a><br><a href="https://blog.csdn.net/time_poster/article/details/116140160">Proxy.newProxyInstance源码探究</a><br><a href="https://www.bilibili.com/video/BV1nr4y1y7eZ?p=3&spm_id_from=pageDriver">JDK动态代理底层原理&amp;为什么需要接口?</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-装饰者模式</title>
    <url>/2022/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>装饰者模式（Decorator Pattern）也称为包装模式（Wrapper Pattern），以透明动态的方式来动态扩展对象的功能，也是继承关系的一种代替方案。</p>
<img src="/2022/03/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" class="" title="装饰者设计模式">

<span id="more"></span>

<ul>
<li>Component：抽象组件（可以是抽象类或者接口），被装饰的原始对象</li>
<li>ConcreteComponent：具体实现类，被装饰的具体对象</li>
<li>Decorator：抽象装饰者，职责就是为了装饰我们的组件对象，内部一定要有一个指向组件对象的引用</li>
<li>ConcreteDecoratorA：装饰者具体实现类，只对抽象装饰者做出具体实现</li>
<li>ConcreteDecoratorB：同上</li>
</ul>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>人定义为抽象类，有一个抽象方法eat()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Person &#123;</span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着创建一个NormalPerson类继承Person，对eat()方法有了具体实现；NormalPerson类就是我们需要装饰的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NormalPerson extends Person &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义一个PersonFood类来表示装饰者的抽象类，保持了一个对Person的引用，可以方便调用具体被装饰的对象方法，这样就可以方便的对其进行扩展功能，并且不改变原类的层次结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PersonFood extends Person &#123;</span><br><span class="line">    private Person person;</span><br><span class="line"></span><br><span class="line">    public PersonFood(Person person)&#123;</span><br><span class="line">        this.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        person.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着就是具体的装饰类了，这两个类没有本质上的区别，都是为了扩展NormalPerson类，不修改原有类的方法和结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ExpensiveFood extends PersonFood &#123;</span><br><span class="line">    public ExpensiveFood(Person person) &#123;</span><br><span class="line">        super(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        super.eat();</span><br><span class="line">        eatSteak();</span><br><span class="line">        drinkRedWine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eatSteak()&#123;</span><br><span class="line">        System.out.println(&quot;吃牛排&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void drinkRedWine()&#123;</span><br><span class="line">        System.out.println(&quot;喝拉菲&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CheapFood extends PersonFood &#123;</span><br><span class="line">    public CheapFood(Person person) &#123;</span><br><span class="line">        super(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        super.eat();</span><br><span class="line">        eatNoodles();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eatNoodles()&#123;</span><br><span class="line">        System.out.println(&quot;吃面条&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用装饰者代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Person person = new NormalPerson();</span><br><span class="line"></span><br><span class="line">        PersonFood cheapFood = new CheapFood(person);</span><br><span class="line">        cheapFood.eat();</span><br><span class="line"></span><br><span class="line">        PersonFood expensiveFood = new ExpensiveFood(person);</span><br><span class="line">        expensiveFood.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="android中的装饰者模式"><a href="#android中的装饰者模式" class="headerlink" title="android中的装饰者模式"></a>android中的装饰者模式</h3><p>在android中，Context就是典型的装饰者模式，Context是抽象类，真实的功能实现实在ComtextImpl中完成，ComtextImpl就是Context的实现类；然后看源码会发现Activity是继承于ContextThemeWrapper而不是直接继承于Context。其中ContextThemeWrapper继承于ContextWrapper，而ContextWrapper继承于Context。这里就可以看出来一点装饰者模式了，其中装饰者所调用的方法就是startActivity方法，在ContextWrapper中会发现startActivity方法调用了ComtextImpl中对应的方法，实质上ContextWrapper中所有方法都仅仅是调用了ComtextImpl中的方法，这就和装饰者模式基本就对应上了。<br>想具体了解Context机制可以看我另一篇文章：<a href="https://lianwenhong.top/2022/03/29/Android%E6%BA%90%E7%A0%81%E5%B0%8F%E8%AE%B0-Context%E8%A7%A3%E6%9E%90/#more">Android源码小记-Context解析</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>装饰者模式与继承关系的目的都是要扩展对象的功能，但是装饰者模式可以提供比继承更多的灵活性。</li>
<li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</li>
<li>装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</li>
<li>装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</li>
</ul>
<h3 id="装饰者模式与代理模式对比"><a href="#装饰者模式与代理模式对比" class="headerlink" title="装饰者模式与代理模式对比"></a>装饰者模式与代理模式对比</h3><p>其实装饰者模式和代理模式很像，但是两者的目的不尽相同。装饰者模式是以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；而代理模式则是一个给对象提供一个代理对象，并由代理对象来控制对原有对象的引用。<br>装饰者模式为本装饰的对象进行功能扩展；代理模式对代理对象进行控制，但不做功能扩展</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
